%YAML 1.2
---
# Note that blackslashes don't need to be escaped within single quoted
# strings in YAML. When using single quoted strings, only single quotes
# need to be escaped: this is done by using two single quotes next to each
# other.

# See http://www.sublimetext.com/docs/syntax.html
file_extensions:
  - cy
  - cyber
  - cb
  - cbr
scope: source.cyber
contexts:
  main:
    - match: ''''
      scope: punctuation.definition.string.begin.cyber
      push: single_quoted_string

    - match: '`'
      scope: punctuation.definition.string.begin.cyber
      push: backtick_string

    - match: '"'
      scope: punctuation.definition.string.begin.cyber
      push: double_quoted_string

    # @foo
    # - match: (?<=@)\w+
    - match: \@\w*
      scope: string.quoted.other.cyber

    - match: (?<![\w\]\)])\.\w+(?![\w(])
      scope: string.quoted.other.cyber

    - match: \$\w*
      scope: variable.member.cyber

    - match: '\b(if|else|switch|while|for|break|continue|pass|case|begin|with)\b'
      scope: keyword.control.cyber

    - match: '--'
      scope: punctuation.definition.comment.cyber
      push: line_comment

    - match: '\#\[[\w]*\]'
      scope: comment.line.cyber

    - match: '[-+*/=<>!?&\|%^~:]+|\.\.'
      scope: keyword.operator.cyber

    - match: '\b(not)\b'
      scope: keyword.operator.cyber

    - match: '\b(or|and)\b'
      scope: keyword.control.cyber

    - match: '\b(var|move|const|global)\b'
      scope: keyword.variable.cyber

    - match: \b(fn).*::\s*(\w+)\s*\(.*\b
      captures:
        1: keyword.function.cyber
        2: variable.decl.cyber

    - match: \b(fn).*\(.*\)\s*(\w+)\s*\(.*\b
      captures:
        1: keyword.function.cyber
        2: variable.decl.cyber

    - match: \b(fn)\s+(\w+)\s*\(.*
      captures:
        1: keyword.function.cyber
        2: variable.decl.cyber

    # - match: \b\w+(?=[ ]+:=)
    #   scope: variable.decl.cyber

    - match: \b(?<=type )[\w.]+
      scope: variable.decl.cyber

    # - match: \b(?<=var )[\w.]+
    #   scope: variable.decl.cyber

    - match: \b(?<=const )[\w.]+
      scope: variable.decl.cyber

    - match: '\b(fn|fnsym|return)\b'
      scope: keyword.function.cyber

    - match: '\b(yield)\b'
      scope: keyword.coroutine.cyber

    - match: '\b(type|object|struct|cstruct|cunion|enum|trait|as)\b'
      scope: keyword.type.cyber

    - match: '\b(catch|error)\b'
      scope: keyword.error.cyber

    - match: '\b(use)\b'
      scope: keyword.module.cyber

    - match: '\b0x[0-9a-fA-F]+\b'
      scope: constant.numeric.cyber

    - match: '\b[0-9]+u\b'
      scope: constant.numeric.cyber

    - match: '\b(-)?[0-9]+(.[0-9]+)?\b'
      scope: constant.numeric.cyber

    - match: '\b(true|false|none|undef)\b'
      scope: constant.numeric.cyber

  single_quoted_string:
    - meta_scope: string.quoted.single.cyber
    # Uses backslashes as an escape character.
    - match: '\\.'
      scope: constant.character.escape.cyber
    - match: ''''
      scope: punctuation.definition.string.end.cyber
      pop: true

  backtick_string:
    - meta_scope: string.quoted.single.cyber
    # Uses backslashes as an escape character.
    - match: '\\.'
      scope: constant.character.escape.cyber
    - match: '`'
      scope: punctuation.definition.string.end.cyber
      pop: true

  double_quoted_string:
    - meta_scope: string.quoted.double.cyber
    # Uses backslashes as an escape character.
    - match: '\\.'
      scope: constant.character.escape.cyber
    - match: '"'
      scope: punctuation.definition.string.end.cyber
      pop: true

  line_comment:
    - meta_scope: comment.line.cyber
    - match: $
      pop: true

  # symbol_literal:
  #   - meta_scope: string.cyber
  #   - match: "[^a-zA-Z0-9]"
  #     pop: true
