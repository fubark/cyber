<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts. Primitives include Booleans, Numbers, Integers, Tags, Tag Literals, Errors, Static Strings, and the none value. Object types include Lists, Maps, Strings, Custom Objects, Lambdas, Fibers, Errors with payloads, and several internal object types.
The none value represents an empty value. This is similar to null in other languages."><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Data Types"><meta property="og:description" content="Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts. Primitives include Booleans, Numbers, Integers, Tags, Tag Literals, Errors, Static Strings, and the none value. Object types include Lists, Maps, Strings, Custom Objects, Lambdas, Fibers, Errors with payloads, and several internal object types.
The none value represents an empty value. This is similar to null in other languages."><meta property="og:type" content="article"><meta property="og:url" content="https://fubark.github.io/cyber/docs/toc/data-types/"><meta property="article:section" content="docs"><title>Data Types | Cyber Docs v0.1</title><link rel=manifest href=/cyber/manifest.json><link rel=icon href=/cyber/favicon.png type=image/x-icon><link rel=stylesheet href=/cyber/book.min.4b35fed0bea034bbc19c89c71e14b73fb9c68cfcc586b9382adfb9b7b103ba06.css integrity="sha256-SzX+0L6gNLvBnInHHhS3P7nGjPzFhrk4Kt+5t7EDugY=" crossorigin=anonymous><script defer src=/cyber/flexsearch.min.js></script>
<script defer src=/cyber/en.search.min.1a7328b6e7d8edec2633402ff06a8746104be42472d6019980cd602e5696f1aa.js integrity="sha256-GnMotufY7ewmM0Av8GqHRhBL5CRy1gGZgM1gLlaW8ao=" crossorigin=anonymous></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=/cyber/hljs.min.css><link rel=stylesheet href=/cyber/style.css></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/cyber/><span>Cyber Docs v0.1</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://cyberscript.dev target=_blank rel=noopener>Homepage</a></li><li><a href=https://cyberscript.dev/play.html target=_blank rel=noopener>Playground</a></li></ul><ul><li class=book-section-flat><span>Table of Contents</span><ul><li><a href=/cyber/docs/toc/syntax/>Syntax</a></li><li><a href=/cyber/docs/toc/data-types/ class=active>Data Types</a></li><li><a href=/cyber/docs/toc/control-flow/>Control Flow</a></li><li><a href=/cyber/docs/toc/functions/>Functions</a></li><li><a href=/cyber/docs/toc/modules/>Modules</a></li><li><a href=/cyber/docs/toc/ffi/>FFI</a></li><li><a href=/cyber/docs/toc/errors/>Error Handling</a></li><li><a href=/cyber/docs/toc/concurrency/>Concurrency</a></li><li><a href=/cyber/docs/toc/metaprogramming/>Metaprogramming</a></li><li><a href=/cyber/docs/toc/embedding/>Embedding</a></li><li><a href=/cyber/docs/toc/gradual-typing/>Gradual Typing</a></li><li><a href=/cyber/docs/toc/memory/>Memory</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/cyber/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Data Types</strong>
<label for=toc-control><img src=/cyber/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#booleans>Booleans.</a></li><li><a href=#numbers>Numbers.</a></li><li><a href=#strings>Strings.</a><ul><li><a href=#object-string>object string</a></li><li><a href=#string-interpolation>String Interpolation.</a></li><li><a href=#rawstring>rawstring.</a></li><li><a href=#object-rawstring>object rawstring</a></li></ul></li><li><a href=#lists>Lists.</a><ul><li><a href=#object-list>object list</a></li></ul></li><li><a href=#maps>Maps.</a><ul><li><a href=#object-map>object map</a></li></ul></li><li><a href=#objects>Objects.</a></li><li><a href=#tags>Tags.</a></li></ul></nav></aside></header><article class=markdown><h1 id=data-types>Data Types.
<a class=anchor href=#data-types>#</a></h1><p>In Cyber, there are primitive types and object types. Primitives are copied around by value and don&rsquo;t need additional heap memory or reference counts. Primitives include <a href=#booleans>Booleans</a>, <a href=#numbers>Numbers</a>, Integers, <a href=#tags>Tags</a>, <a href=#tags>Tag Literals</a>, <a href=/cyber/docs/toc/errors/>Errors</a>, <a href=#strings>Static Strings</a>, and the <code>none</code> value. Object types include <a href=#lists>Lists</a>, <a href=#maps>Maps</a>, <a href=#strings>Strings</a>, <a href=#objects>Custom Objects</a>, <a href=/cyber/docs/toc/functions/#lambdas>Lambdas</a>, <a href=/cyber/docs/toc/concurrency/#fibers>Fibers</a>, <a href=/cyber/docs/toc/errors/>Errors with payloads</a>, and several internal object types.</p><p>The <code>none</code> value represents an empty value. This is similar to null in other languages.</p><h2 id=booleans>Booleans.
<a class=anchor href=#booleans>#</a></h2><p>Booleans can be <code>true</code> or <code>false</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>a = true
if a:
    print &#39;a is true&#39;
</code></pre><p>When other value types are coerced to the boolean type, the truthy value is determined as follows.</p><ul><li>The <code>none</code> value is <code>false</code>.</li><li>Other objects and values are always <code>true</code>.</li></ul><h2 id=numbers>Numbers.
<a class=anchor href=#numbers>#</a></h2><p>In Cyber, the <code>number</code> is the default number type and has a 64-bit double precision floating point format.</p><p>You can still use numbers as integers and perform arithmetic without rounding issues in a 32-bit integer range. The safe integer range is from -(2^53-1) to (2^53-1). Any integers beyond this range is not guaranteed to have a unique representation.</p><p>When performing bitwise operations, the number is first converted to an 32-bit integer.</p><pre tabindex=0><code class=language-cy data-lang=cy>a = 123
b = 2.34567
</code></pre><p>There are other number literal notations you can use.</p><pre tabindex=0><code class=language-cy data-lang=cy>-- Scientific notation. 
a = 123.0e4

-- Integer notations.
a = 0xFF     -- hex.
a = 0o17     -- octal.
a = 0b1010   -- binary.
</code></pre><p>The <code>int</code> type is a 32-bit integer and has limited support and you can only declare them in function param and return types.</p><pre tabindex=0><code class=language-cy data-lang=cy>func fib(n int) int:
    if n &lt; 2:
        return n
    return fib(n - 1) + fib(n - 2)
print(fib(30))
</code></pre><p>Big numbers will be supported in a future version of Cyber.</p><h2 id=strings>Strings.
<a class=anchor href=#strings>#</a></h2><p>The <code>string</code> type represents a sequence of UTF-8 characters. Under the hood, Cyber implements 6 different internal string types to optimize string operations, but the user just sees them as one type and doesn&rsquo;t need to care about this detail under normal usage.</p><p>Strings are <strong>immutable</strong>, so operations that do string manipulation return a new string. By default, small strings are interned to reduce memory footprint. To mutate an existing string, use the <a href=#string-buffer>StringBuffer</a>.</p><p>A string is always UTF-8 validated. <a href=#rawstring>rawstrings</a> outperform strings but you&rsquo;ll have to validate them and take care of indexing yourself.</p><p>A single line string literal is surrounded in single quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>apple = &#39;a fruit&#39;
</code></pre><p>You can escape the single quote inside the literal or use double quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>apple = &#39;Bob\&#39;s fruit&#39;
apple = &#34;Bob&#39;s fruit&#34;
</code></pre><p>Strings are UTF-8 encoded.</p><pre tabindex=0><code class=language-cy data-lang=cy>str = &#39;abcü¶äxyzüê∂&#39;
</code></pre><p>Use double quotes to surround a multi-line string.</p><pre tabindex=0><code class=language-cy data-lang=cy>str = &#34;line a
line b
line c&#34;
</code></pre><p>You can escape double quotes inside the literal or use triple quotes.</p><pre tabindex=0><code class=language-cy data-lang=cy>str = &#34;line a
line \&#34;b\&#34;
line c&#34;

-- Using triple quotes.
str = &#39;&#39;&#39;line a
line &#34;b&#34;
line c
&#39;&#39;&#39;
</code></pre><p>The boundary of each line can be set with a vertical line character. This makes it easier to see the whitespace.</p><pre tabindex=0><code class=language-cy data-lang=cy>poem = &#34;line a
       |  two spaces from the left
       |     indented further&#34;
</code></pre><p>Using the index operator will return the UTF-8 character at the given character index. This is equivalent to calling the method <code>charAt()</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>str = &#39;abcd&#39;
print str[1]     -- &#34;b&#34;
print str[-1]    -- &#34;d&#34;
</code></pre><p>Using the slice index operator will return a view of the string at the given start and end (exclusive) indexes. The start index defaults to 0 and the end index defaults to the character length of the string.</p><pre tabindex=0><code class=language-cy data-lang=cy>str = &#39;abcxyz&#39;
sub = str[0..3]
print sub        -- &#34;abc&#34;
print str[..5]   -- &#34;abcxy&#34;
print str[1..]   -- &#34;bcxyz&#34;

-- One way to use slices is to continue a string operation.
str = &#39;abcabcabc&#39;
i = str.indexChar(&#39;c&#39;)
print(i)                            -- &#34;2&#34;
i += 1
print(i + str[i..].indexChar(&#39;c&#39;))  -- &#34;5&#34;
</code></pre><h3 id=object-string>object string
<a class=anchor href=#object-string>#</a></h3><table><thead><tr><th>Method</th><th>Summary</th></tr></thead><tbody><tr><td><code>append(str string) string</code></td><td>Deprecated: Use <code>concat()</code>.</td></tr><tr><td><code>charAt(idx number) string</code></td><td>Returns the UTF-8 character at index <code>idx</code> as a single character string.</td></tr><tr><td><code>codeAt(idx number) number</code></td><td>Returns the codepoint of the UTF-8 character at index <code>idx</code>.</td></tr><tr><td><code>concat(str string) string</code></td><td>Returns a new string that concats this string and <code>str</code>.</td></tr><tr><td><code>endsWith(suffix string) bool</code></td><td>Returns whether the string ends with <code>suffix</code>.</td></tr><tr><td><code>index(needle string) number?</code></td><td>Returns the first index of substring <code>needle</code> in the string or <code>none</code> if not found.</td></tr><tr><td><code>indexChar(needle string) number?</code></td><td>Returns the first index of UTF-8 character <code>needle</code> in the string or <code>none</code> if not found.</td></tr><tr><td><code>indexCharSet(set string) number?</code></td><td>Returns the first index of any UTF-8 character in <code>set</code> or <code>none</code> if not found.</td></tr><tr><td><code>indexCode(needle number) number?</code></td><td>Returns the first index of UTF-8 codepoint <code>needle</code> in the string or <code>none</code> if not found.</td></tr><tr><td><code>insert(idx number, str string) string</code></td><td>Returns a new string with <code>str</code> inserted at index <code>idx</code>.</td></tr><tr><td><code>isAscii() bool</code></td><td>Returns whether the string contains all ASCII characters.</td></tr><tr><td><code>len() number</code></td><td>Returns the number of UTF-8 characters in the string.</td></tr><tr><td><code>less(str string) bool</code></td><td>Returns whether this string is lexicographically before <code>str</code>.</td></tr><tr><td><code>lower() string</code></td><td>Returns this string in lowercase.</td></tr><tr><td><code>replace(needle string, replacement string) string</code></td><td>Returns a new string with all occurrences of <code>needle</code> replaced with <code>replacement</code>.</td></tr><tr><td><code>repeat(n number) string</code></td><td>Returns a new string with this string repeated <code>n</code> times.</td></tr><tr><td><code>slice(start number, end number) string</code></td><td>Returns a slice into this string from <code>start</code> to <code>end</code> (exclusive) indexes. This is equivalent to using the slice index operator <code>[start..end]</code>.</td></tr><tr><td><code>startsWith(prefix string) bool</code></td><td>Returns whether the string starts with <code>prefix</code>.</td></tr><tr><td><code>upper() string</code></td><td>Returns this string in uppercase.</td></tr></tbody></table><h3 id=string-interpolation>String Interpolation.
<a class=anchor href=#string-interpolation>#</a></h3><p>You can embed expressions into string templates using braces.</p><pre tabindex=0><code class=language-cy data-lang=cy>name = &#39;Bob&#39;
points = 123
str = &#39;Scoreboard: {name} {points}&#39;
</code></pre><p>Escape braces with a backslash.</p><pre tabindex=0><code class=language-cy data-lang=cy>points = 123
str = &#39;Scoreboard: \{ Bob \} {points}&#39;
</code></pre><p>String templates can not contain nested string templates.</p><h3 id=rawstring>rawstring.
<a class=anchor href=#rawstring>#</a></h3><p>A <code>rawstring</code> does not automatically validate the string and is indexed by bytes and not UTF-8 characters.</p><p>Using the index operator will return the UTF-8 character starting at the given byte index. If the index does not begin a valid UTF-8 character, <code>error(#InvalidChar)</code> is returned. This is equivalent to calling the method <code>charAt()</code>.</p><pre tabindex=0><code class=language-cy data-lang=cy>str = rawstring(&#39;abcd&#39;).insertByte(1, 255)
print str[0]     -- &#34;a&#34;
print str[1]     -- error(#InvalidChar)
print str[-1]    -- &#34;d&#34;
</code></pre><h3 id=object-rawstring>object rawstring
<a class=anchor href=#object-rawstring>#</a></h3><table><thead><tr><th>Method</th><th>Summary</th></tr></thead><tbody><tr><td><code>append(str string) string</code></td><td>Deprecated: Use <code>concat()</code>.</td></tr><tr><td><code>byteAt(idx number) number</code></td><td>Returns the byte value (0-255) at the given index <code>idx</code>.</td></tr><tr><td><code>charAt(idx number) string</code></td><td>Returns the UTF-8 character at index <code>idx</code> as a single character string. If the index does not begin a UTF-8 character, <code>error(#InvalidChar)</code> is returned.</td></tr><tr><td><code>codeAt(idx number) number</code></td><td>Returns the codepoint of the UTF-8 character at index <code>idx</code>. If the index does not begin a UTF-8 character, <code>error(#InvalidChar)</code> is returned.</td></tr><tr><td><code>concat(str string) string</code></td><td>Returns a new string that concats this string and <code>str</code>.</td></tr><tr><td><code>endsWith(suffix string) bool</code></td><td>Returns whether the string ends with <code>suffix</code>.</td></tr><tr><td><code>index(needle string) number?</code></td><td>Returns the first index of substring <code>needle</code> in the string or <code>none</code> if not found.</td></tr><tr><td><code>indexChar(needle string) number?</code></td><td>Returns the first index of UTF-8 character <code>needle</code> in the string or <code>none</code> if not found.</td></tr><tr><td><code>indexCharSet(set string) number?</code></td><td>Returns the first index of any UTF-8 character in <code>set</code> or <code>none</code> if not found.</td></tr><tr><td><code>indexCode(needle number) number?</code></td><td>Returns the first index of UTF-8 codepoint <code>needle</code> in the string or <code>none</code> if not found.</td></tr><tr><td><code>insert(idx number, str string) string</code></td><td>Returns a new string with <code>str</code> inserted at index <code>idx</code>.</td></tr><tr><td><code>insertByte(idx number, byte number) string</code></td><td>Returns a new string with <code>byte</code> inserted at index <code>idx</code>.</td></tr><tr><td><code>isAscii() bool</code></td><td>Returns whether the string contains all ASCII characters.</td></tr><tr><td><code>len() number</code></td><td>Returns the number of bytes in the string.</td></tr><tr><td><code>less(str rawstring) bool</code></td><td>Returns whether this rawstring is lexicographically before <code>str</code>.</td></tr><tr><td><code>lower() string</code></td><td>Returns this string in lowercase.</td></tr><tr><td><code>repeat(n number) rawstring</code></td><td>Returns a new rawstring with this rawstring repeated <code>n</code> times.</td></tr><tr><td><code>replace(needle string, replacement string) string</code></td><td>Returns a new string with all occurrences of <code>needle</code> replaced with <code>replacement</code>.</td></tr><tr><td><code>slice(start number, end number) rawstring</code></td><td>Returns a slice into this string from <code>start</code> to <code>end</code> (exclusive) indexes. This is equivalent to using the slice index operator <code>[start..end]</code>.</td></tr><tr><td><code>startsWith(prefix string) bool</code></td><td>Returns whether the string starts with <code>prefix</code>.</td></tr><tr><td><code>toString() string</code></td><td>Deprecated: Use <code>utf8()</code>.</td></tr><tr><td><code>upper() string</code></td><td>Returns this string in uppercase.</td></tr><tr><td><code>utf8() string</code></td><td>Returns a valid UTF-8 string or returns <code>error(#InvalidChar)</code>.</td></tr></tbody></table><h2 id=lists>Lists.
<a class=anchor href=#lists>#</a></h2><p>Lists are a builtin type that holds an ordered collection of elements. Lists grow or shrink as you insert or remove elements.</p><pre tabindex=0><code class=language-cy data-lang=cy>-- Construct a new list.
list = [1, 2, 3]

-- The first element of the list starts at index 0.
print list[0]    -- Prints &#39;1&#39;

-- Using a negative index starts at the back of the list.
print list[-1]   -- Prints &#39;3&#39;
</code></pre><p>Lists can be sliced with the range <code>..</code> clause. The sliced list becomes a new list that you can modify without affecting the original list. The end index is non-inclusive. Negative start or end values count from the end of the list.</p><pre tabindex=0><code class=language-cy data-lang=cy>list = [ 1, 2, 3, 4, 5 ]
list[0..0]  -- []          Empty list.
list[0..3]  -- [ 1, 2, 3 ] From start to end index.
list[3..]   -- [ 4, 5 ]    From start index to end of list. 
list[..3]   -- [ 1, 2, 3 ] From start of list to end index.
list[2..+2] -- [ 3, 4 ]    From start index to start index + amount.
</code></pre><p>List operations.</p><pre tabindex=0><code class=language-cy data-lang=cy>list = [234]
-- Append a value.
list.append 123
print list[-1]     -- Prints &#39;123&#39;

-- Inserting a value at an index.
list.insert(1, 345)

-- Get the length.
print list.len()  -- Prints &#39;2&#39;

-- Sort the list in place.
list.sort((a, b) =&gt; a &lt; b)

-- Iterating a list.
for list each it:
    print it

-- Remove an element at a specific index.
list.remove(1)
</code></pre><h3 id=object-list>object list
<a class=anchor href=#object-list>#</a></h3><table><thead><tr><th>Method</th><th>Summary</th></tr></thead><tbody><tr><td><code>add(val any) none</code></td><td>Deprecated: Use <code>append()</code>.</td></tr><tr><td><code>append(val any) none</code></td><td>Appends a value to the end of the list.</td></tr><tr><td><code>concat(val any) none</code></td><td>Concats the elements of another list to the end of this list.</td></tr><tr><td><code>insert(idx number, val any) none</code></td><td>Inserts a value at index <code>idx</code>.</td></tr><tr><td><code>iterator() Iterator&lt;any></code></td><td>Returns a new iterator over the list elements.</td></tr><tr><td><code>joinString(separator any) string</code></td><td>Returns a new string that joins the elements with <code>separator</code>.</td></tr><tr><td><code>len() number</code></td><td>Returns the number of elements in the list.</td></tr><tr><td><code>pairIterator() PairIterator&lt;number, any></code></td><td>Returns a new pair iterator over the list elements.</td></tr><tr><td><code>remove(idx number) none</code></td><td>Removes an element at index <code>idx</code>.</td></tr><tr><td><code>resize(len number) none</code></td><td>Resizes the list to <code>len</code> elements. If the new size is bigger, <code>none</code> values are appended to the list. If the new size is smaller, elements at the end of the list are removed.</td></tr><tr><td><code>sort(less func (a, b) bool) none</code></td><td>Sorts the list with the given <code>less</code> function. If element <code>a</code> should be ordered before <code>b</code>, the function should return <code>true</code> otherwise <code>false</code>.</td></tr></tbody></table><h2 id=maps>Maps.
<a class=anchor href=#maps>#</a></h2><p>Maps are a builtin type that store key value pairs in dictionaries.</p><pre tabindex=0><code class=language-cy data-lang=cy>map = { a: 123, b: () =&gt; 5 }
print map[&#39;a&#39;]

-- You can also access the map using an access expression.
print map.a

-- Map entries can be separated by the new line.
map = {
    foo: 1
    bar: 2
}
</code></pre><p>Entries can also follow a <code>{}:</code> block.
This gives structure to the entries and has
the added benefit of allowing multi-line lambdas.</p><pre tabindex=0><code class=language-cy data-lang=cy>colors = {}:
    red: 0xFF0000
    green: 0x00FF00
    blue: 0x0000FF
    dump func (c):
        print c.red
        print c.green
        print c.blue

    -- Nested map.
    darker {}: 
        red: 0xAA0000
        green: 0x00AA00
        blue: 0x0000AA
</code></pre><p>Map operations.</p><pre tabindex=0><code class=language-cy data-lang=cy>map = {}
-- Set a key value pair.
map[123] = 234

-- Get the size of the map.
print map.size()

-- Remove an entry by key.
map.remove 123

-- Iterating a list.
for map each val, key:
    print &#39;{key} -&gt; {value}&#39;
</code></pre><h3 id=object-map>object map
<a class=anchor href=#object-map>#</a></h3><table><thead><tr><th>Method</th><th>Summary</th></tr></thead><tbody><tr><td><code>iterator() Iterator&lt;any></code></td><td>Returns a new iterator over the map elements.</td></tr><tr><td><code>pairIterator() PairIterator&lt;number, any></code></td><td>Returns a new pair iterator over the map elements.</td></tr><tr><td><code>remove(key any) none</code></td><td>Removes the element with the given key <code>key</code>.</td></tr><tr><td><code>size() number</code></td><td>Returns the number of key-value pairs in the map.</td></tr></tbody></table><h2 id=objects>Objects.
<a class=anchor href=#objects>#</a></h2><p>Any value that isn&rsquo;t a primitive is an object. You can declare your own object types using the <code>object</code> keyword. Object templates are similar to structs and classes in other languages. You can declare members and methods. Unlike classes, there is no concept of inheritance at the language level.</p><pre tabindex=0><code class=language-cy data-lang=cy>object Node:
    value
    next

node = Node{ value: 123, next: none }
print node.value          -- &#39;123&#39;
</code></pre><p>New instances of an object template are created using the type name and braces that surround the initial member values.
When declaring methods, the first parameter must be <code>self</code>. Otherwise, it becomes a function that can only be invoked from the type&rsquo;s namespace.</p><pre tabindex=0><code class=language-cy data-lang=cy>object Node:
    value
    next

    -- A static function.
    func create():
        return Node{ value: 123, next: none }

    -- A method.
    func dump(self)
        print self.value

n = Node.create()
n.dump()
</code></pre><h2 id=tags>Tags.
<a class=anchor href=#tags>#</a></h2><p>Tags are similar to enums in other languages. A new tag type can be declared with the <code>tagtype</code> keyword.
A tag value can only be one of the unique tags declared in its tag type.
By default, the tags have a unique id generated starting from 0.</p><pre tabindex=0><code class=language-cy data-lang=cy>tagtype Fruit:
    apple
    orange
    banana
    kiwi

fruit = Fruit#kiwi
print fruit          -- &#39;#kiwi&#39;
print number(fruit)  -- &#39;3&#39;
</code></pre><p>When the type of the value is known to be a tag, it can be assigned using a tag literal.</p><pre tabindex=0><code class=language-cy data-lang=cy>fruit = Fruit#kiwi
fruit = #orange
print(fruit == Fruit#orange)   -- &#39;true&#39;
</code></pre><p>Tag literals by themselves also have a global unique id. When assigned to a non tag value, it becomes a tag literal value.</p><pre tabindex=0><code class=language-cy data-lang=cy>tagtype MyColor:
    red
    green
    blue
color = #red                 -- The variable `color` does not become a `MyColor` tag.
print(color == Color#red)    -- &#39;false&#39;
print(color == #red)         -- &#39;true&#39;
print number(color)          -- &#39;123&#39; or some arbitrary id.
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/fubark/cyber/edit/master/docs/hugo/content/docs/toc/data-types.md target=_blank rel=noopener><img src=/cyber/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#booleans>Booleans.</a></li><li><a href=#numbers>Numbers.</a></li><li><a href=#strings>Strings.</a><ul><li><a href=#object-string>object string</a></li><li><a href=#string-interpolation>String Interpolation.</a></li><li><a href=#rawstring>rawstring.</a></li><li><a href=#object-rawstring>object rawstring</a></li></ul></li><li><a href=#lists>Lists.</a><ul><li><a href=#object-list>object list</a></li></ul></li><li><a href=#maps>Maps.</a><ul><li><a href=#object-map>object map</a></li></ul></li><li><a href=#objects>Objects.</a></li><li><a href=#tags>Tags.</a></li></ul></nav></div></aside></main><script src=/cyber/highlight.min.js></script>
<script>hljs.registerLanguage("cy",function(){return{keywords:["func","import","for","coinit","coresume","coyield","return","if","then","else","as","each","while","var","tagtype","object","break","continue","match","export","pass","or","and","not","is","static","capture","true","false","none","try","catch","recover","compt"],contains:[{scope:"string",begin:"'",end:"'"},hljs.COMMENT("--",`
`,{contains:[]}),hljs.C_NUMBER_MODE]}}),hljs.highlightAll()</script></body></html>