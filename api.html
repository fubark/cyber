<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber API</title>
    <style>/* Global variables. */
:root {
  /* Set sans-serif & mono fonts */
  --sans-font: -apple-system, BlinkMacSystemFont, "Avenir Next", Avenir,
    "Nimbus Sans L", Roboto, "Noto Sans", "Segoe UI", Arial, Helvetica,
    "Helvetica Neue", sans-serif;
  --mono-font: Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace;

  /* Default (light) theme */
  --bg: #fff;
  --accent-bg: #f5f7ff;
  --text: #212121;
  --text-light: #585858;
  --border: #898EA4;
  --accent: #0d47a1;
  --code: #d81b60;
  --preformatted: #444;
  --marked: #ffdd33;
  --disabled: #efefef;
}

/* Dark theme */
@media (prefers-color-scheme: dark) {
  :root {
    color-scheme: dark;
    --bg: #212121;
    --accent-bg: #2b2b2b;
    --text: #dcdcdc;
    --text-light: #ababab;
    --accent: #ffb300;
    --code: #f06292;
    --preformatted: #ccc;
    --disabled: #111;
  }
  /* Add a bit of transparency so light media isn't so glaring in dark mode */
  img,
  video {
    opacity: 0.8;
  }
}

/* Reset box-sizing */
*, *::before, *::after {
  box-sizing: border-box;
}

/* Reset default appearance */
textarea,
select,
input,
progress {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

html {
  /* Set the font globally */
  font-family: var(--sans-font);
  scroll-behavior: smooth;
}

/* Make the body a nice central block */
body {
  color: var(--text);
  background-color: var(--bg);
  font-size: 1.15rem;
  line-height: 1.5;
  display: grid;
  grid-template-columns: 1fr min(45rem, 90%) 1fr;
  margin: 0;
}
body > * {
  grid-column: 2;
}

/* Make the header bg full width, but the content inline with body */
body > header {
  background-color: var(--accent-bg);
  border-bottom: 1px solid var(--border);
  text-align: center;
  padding: 0 0.5rem 2rem 0.5rem;
  grid-column: 1 / -1;
}

body > header h1 {
  max-width: 1200px;
  margin: 1rem auto;
}

body > header p {
  max-width: 40rem;
  margin: 1rem auto;
}

/* Add a little padding to ensure spacing is correct between content and header > nav */
main {
  padding-top: 1.5rem;
}

body > footer {
  margin-top: 4rem;
  padding: 2rem 1rem 1.5rem 1rem;
  color: var(--text-light);
  font-size: 0.9rem;
  text-align: center;
  border-top: 1px solid var(--border);
}

/* Format headers */
h1 {
  font-size: 3rem;
}

h2 {
  font-size: 2.6rem;
  margin-top: 3rem;
}

h3 {
  font-size: 2rem;
  margin-top: 3rem;
}

h4 {
  font-size: 1.44rem;
}

h5 {
  font-size: 1.15rem;
}

h6 {
  font-size: 0.96rem;
}

/* Prevent long strings from overflowing container */
p, h1, h2, h3, h4, h5, h6 {
  overflow-wrap: break-word;
}

/* Fix line height when title wraps */
h1,
h2,
h3 {
  line-height: 1.1;
}

/* Reduce header size on mobile */
@media only screen and (max-width: 720px) {
  h1 {
    font-size: 2.5rem;
  }

  h2 {
    font-size: 2.1rem;
  }

  h3 {
    font-size: 1.75rem;
  }

  h4 {
    font-size: 1.25rem;
  }
}

/* Format links & buttons */
a,
a:visited {
  color: var(--accent);
}

a:hover {
  text-decoration: none;
}

button,
[role="button"],
input[type="submit"],
input[type="reset"],
input[type="button"],
label[type="button"] {
  border: none;
  border-radius: 5px;
  background-color: var(--accent);
  font-size: 1rem;
  color: var(--bg);
  padding: 0.7rem 0.9rem;
  margin: 0.5rem 0;
}

button[disabled],
[role="button"][aria-disabled="true"],
input[type="submit"][disabled],
input[type="reset"][disabled],
input[type="button"][disabled],
input[type="checkbox"][disabled],
input[type="radio"][disabled],
select[disabled] {
  opacity: 0.5;
  cursor: not-allowed;
}

input:disabled,
textarea:disabled,
select:disabled {
  cursor: not-allowed;
  background-color: var(--disabled);
}

input[type="range"] {
  padding: 0;
}

/* Set the cursor to '?' on an abbreviation and style the abbreviation to show that there is more information underneath */
abbr[title] {
  cursor: help;
  text-decoration-line: underline;
  text-decoration-style: dotted;
}

button:focus,
button:enabled:hover,
[role="button"]:focus,
[role="button"]:not([aria-disabled="true"]):hover,
input[type="submit"]:focus,
input[type="submit"]:enabled:hover,
input[type="reset"]:focus,
input[type="reset"]:enabled:hover,
input[type="button"]:focus,
input[type="button"]:enabled:hover,
label[type="button"]:focus,
label[type="button"]:hover {
  filter: brightness(1.4);
  cursor: pointer;
}

/* Format navigation */
header > nav {
  font-size: 1rem;
  line-height: 2;
  padding: 1rem 0 0 0;
}

/* Use flexbox to allow items to wrap, as needed */
header > nav ul,
header > nav ol {
  align-content: space-around;
  align-items: center;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  list-style-type: none;
  margin: 0;
  padding: 0;
}

/* List items are inline elements, make them behave more like blocks */
header > nav ul li,
header > nav ol li {
  display: inline-block;
}

header > nav a,
header > nav a:visited {
  margin: 0 0.5rem 1rem 0.5rem;
  border: 1px solid var(--border);
  border-radius: 5px;
  color: var(--text);
  display: inline-block;
  padding: 0.1rem 1rem;
  text-decoration: none;
}

header > nav a:hover {
  border-color: var(--accent);
  color: var(--accent);
  cursor: pointer;
}

/* Reduce nav side on mobile */
@media only screen and (max-width: 720px) {
  header > nav a {
    border: none;
    padding: 0;
    text-decoration: underline;
    line-height: 1;
  }
}

/* Consolidate box styling */
aside, details, pre, progress {
  background-color: var(--accent-bg);
  border: 1px solid var(--border);
  border-radius: 5px;
  margin-bottom: 1rem;
}

aside {
  font-size: 1rem;
  width: 30%;
  padding: 0 15px;
  margin-left: 15px;
  float: right;
}

/* Make aside full-width on mobile */
@media only screen and (max-width: 720px) {
  aside {
    width: 100%;
    float: none;
    margin-left: 0;
  }
}

article, fieldset {
  border: 1px solid var(--border);
  padding: 1rem;
  border-radius: 5px;
  margin-bottom: 1rem;
}

article h2:first-child,
section h2:first-child {
  margin-top: 1rem;
}

section {
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 2rem 1rem;
  margin: 3rem 0;
}

/* Don't double separators when chaining sections */
section + section,
section:first-child {
  border-top: 0;
  padding-top: 0;
}

section:last-child {
  border-bottom: 0;
  padding-bottom: 0;
}

details {
  padding: 0.7rem 1rem;
}

summary {
  cursor: pointer;
  font-weight: bold;
  padding: 0.7rem 1rem;
  margin: -0.7rem -1rem;
  word-break: break-all;
}

details[open] > summary + * {
  margin-top: 0;
}

details[open] > summary {
  margin-bottom: 0.5rem;
}

details[open] > :last-child {
  margin-bottom: 0;
}

/* Format tables */
table {
  border-collapse: collapse;
  display: block;
  margin: 1.5rem 0;
  overflow: auto;
  width: 100%;
}

td,
th {
  border: 1px solid var(--border);
  text-align: left;
  padding: 0.5rem;
}

th {
  background-color: var(--accent-bg);
  font-weight: bold;
}

tr:nth-child(even) {
  /* Set every other cell slightly darker. Improves readability. */
  background-color: var(--accent-bg);
}

table caption {
  font-weight: bold;
  margin-bottom: 0.5rem;
}

/* Format forms */
textarea,
select,
input {
  font-size: inherit;
  font-family: inherit;
  padding: 0.5rem;
  margin-bottom: 0.5rem;
  color: var(--text);
  background-color: var(--bg);
  border: 1px solid var(--border);
  border-radius: 5px;
  box-shadow: none;
  max-width: 100%;
  display: inline-block;
}
label {
  display: block;
}
textarea:not([cols]) {
  width: 100%;
}

/* Add arrow to drop-down */
select:not([multiple]) {
  background-image: linear-gradient(45deg, transparent 49%, var(--text) 51%),
    linear-gradient(135deg, var(--text) 51%, transparent 49%);
  background-position: calc(100% - 15px), calc(100% - 10px);
  background-size: 5px 5px, 5px 5px;
  background-repeat: no-repeat;
  padding-right: 25px;
}

/* checkbox and radio button style */
input[type="checkbox"],
input[type="radio"] {
  vertical-align: middle;
  position: relative;
  width: min-content;
}

input[type="checkbox"] + label,
input[type="radio"] + label {
  display: inline-block;
}

input[type="radio"] {
  border-radius: 100%;
}

input[type="checkbox"]:checked,
input[type="radio"]:checked {
  background-color: var(--accent);
}

input[type="checkbox"]:checked::after {
  /* Creates a rectangle with colored right and bottom borders which is rotated to look like a check mark */
  content: " ";
  width: 0.18em;
  height: 0.32em;
  border-radius: 0;
  position: absolute;
  top: 0.05em;
  left: 0.17em;
  background-color: transparent;
  border-right: solid var(--bg) 0.08em;
  border-bottom: solid var(--bg) 0.08em;
  font-size: 1.8em;
  transform: rotate(45deg);
}
input[type="radio"]:checked::after {
  /* creates a colored circle for the checked radio button  */
  content: " ";
  width: 0.25em;
  height: 0.25em;
  border-radius: 100%;
  position: absolute;
  top: 0.125em;
  background-color: var(--bg);
  left: 0.125em;
  font-size: 32px;
}

/* Makes input fields wider on smaller screens */
@media only screen and (max-width: 720px) {
  textarea,
  select,
  input {
    width: 100%;
  }
}

/* Set a height for color input */
input[type="color"] {
  height: 2.5rem;
  padding:  0.2rem;
}

/* do not show border around file selector button */
input[type="file"] {
  border: 0;
}

/* Misc body elements */
hr {
  border: none;
  height: 1px;
  background: var(--border);
  margin: 1rem auto;
}

mark {
  padding: 2px 5px;
  border-radius: 4px;
  background-color: var(--marked);
}

img,
video {
  max-width: 100%;
  height: auto;
  border-radius: 5px;
}

figure {
  margin: 0;
  text-align: center;
}

figcaption {
  font-size: 0.9rem;
  color: var(--text-light);
  margin-bottom: 1rem;
}

blockquote {
  margin: 2rem 0 2rem 2rem;
  padding: 0.4rem 0.8rem;
  border-left: 0.35rem solid var(--accent);
  color: var(--text-light);
  font-style: italic;
}

cite {
  font-size: 0.9rem;
  color: var(--text-light);
  font-style: normal;
}

dt {
    color: var(--text-light);
}

/* Use mono font for code elements */
code,
pre,
pre span,
kbd,
samp {
  font-family: var(--mono-font);
  color: var(--code);
}

kbd {
  color: var(--preformatted);
  border: 1px solid var(--preformatted);
  border-bottom: 3px solid var(--preformatted);
  border-radius: 5px;
  padding: 0.1rem 0.4rem;
}

pre {
  padding: 1rem 1.4rem;
  max-width: 100%;
  overflow: auto;
  color: var(--preformatted);
}

/* Fix embedded code within pre */
pre code {
  color: var(--preformatted);
  background: none;
  margin: 0;
  padding: 0;
}

/* Progress bars */
/* Declarations are repeated because you */
/* cannot combine vendor-specific selectors */
progress {
  width: 100%;
}

progress:indeterminate {
  background-color: var(--accent-bg);
}

progress::-webkit-progress-bar {
  border-radius: 5px;
  background-color: var(--accent-bg);
}

progress::-webkit-progress-value {
  border-radius: 5px;
  background-color: var(--accent);
}

progress::-moz-progress-bar {
  border-radius: 5px;
  background-color: var(--accent);
  transition-property: width;
  transition-duration: 0.3s;
}

progress:indeterminate::-moz-progress-bar {
  background-color: var(--accent-bg);
}
</style><style></style><style>:root {
    --bg: #0c0c0c;
    --accent-bg: #0d0707;
    --border: #614721;
/*    --text: #d2d2d2;*/
    --text: #fff;
    --text-light: #888888;
    --accent-light: #ffc57b;
/*    --header: #c4beb9;*/
    --header: #b5aea8;
    /* --accent-light: #fab760; */
    --accent: #ffa430;
    --marked: #ffa430;
    --mono-font: Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
    --keyword: #ff7d67;
    --declaration: #ffc57b;
    --type: #ffabab;

    --header-line: #333;

    --nav-width: 15em;
}

html {
    scroll-behavior: auto;
}

h1 {
    font-size: 2em;
    font-weight: normal;
    margin-top: 1.5em;
}

h2 {
    font-size: 1.5em;
    font-weight: normal;
}

h3 {
    font-weight: normal;
}

h4 {
    font-weight: normal;
}

h5 {
    font-weight: normal;
}

h6 {
    font-weight: normal;
}

h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
    opacity: 0;
    text-decoration: none
}

h1:hover a, h2:hover a, h3:hover a, h4:hover a, h5:hover a, h6:hover a {
    opacity: initial
}

h1.title {
    color: var(--accent);
    margin-bottom: 10px;
}

html, body {
    font-size: 18px;

    /* Reset to defaults */ 
    letter-spacing: normal;
    -webkit-font-smoothing: auto;
    -moz-osx-font-smoothing: auto;
    background-color: var(--bg);
    color: var(--text);
}

header ul {
    list-style-type: none;
    padding-left: 0px;
}

header a {
    white-space: nowrap;
}

body > header {
    height: 100%;
    width: var(--nav-width);
    padding-left: 40px;
    text-align: left;
    position: fixed;
    top: 0;
    left: 0;
    overflow-y: auto;
    background-color: var(--bg);
}

header ul li {
    display: list-item;
    margin-right: 0px;
}

body {
    display: block;
}

main {
    padding-top: 0px;
    padding-left: calc(var(--nav-width) + 20px);
    padding-right: 40px;
}

em {
    font-style: normal;
    color: #fb6767;
}

div.desc ul li {
    padding-bottom: 15px;
}

/* mobile */
@media screen and (max-width: 720px) {
    body {
        display: grid;
    }

    /* Make 2 column navs fit */
    table ul {
        padding-left: 20px;
    }
    table ul ul {
        padding-left: 0px;
    }
    table td {
        padding: 0.5rem 0 0.5rem 0;
    }

    body > header {
        position: static;
        padding-left: 0px;
        height: initial;
        width: initial;
        top: initial;
        left: initial;
        text-align: center;
        overflow-y: visible;
        background-color: var(--accent-bg);
    }

    main {
        padding-left: 0px;
        padding-right: 0px;
    }

    header ul {
        margin-top: 0px;
        margin-bottom: 0px;
    }

    header ul li {
        display: inline;
        margin-right: 5px;
    }
}

a.current {
    text-decoration: none;
}

h1 {
/*    color: var(--accent);*/
/*    font-weight: bold;*/
}

.markdown h2 {
    color: var(--header);
    font-weight: bold; 
    margin-top: 60px;
}

h3 {
    color: var(--header);
/*    font-weight: bold; */
    font-size: 1.2em;
    margin-top: 2.2em;

    padding: 0.5rem 1rem 0.7rem 0.75rem;
    border-bottom: 0.15rem solid var(--header-line);
    border-radius: 0rem;
}

main h2 > code {
    color: var(--header);
    font-size: 0.9em;
    background-color: transparent;
}

main h3 > code {
    color: var(--header);
    font-size: 0.9em;
    background-color: transparent;
}

.markdown table tr th {
    text-align: left;
    color: var(--text-light);
    font-weight: normal;
}

.markdown table tr th, .markdown table tr td {
    border: 3px solid #222;
}

.markdown table tr td:first-child code {
    font-size: 15px;
}

.book-search input {
    background-color: var(--bg);
    border: 3px solid #222;
}

.book-menu .book-brand a {
    color: var(--accent);
    font-weight: bold;
}

.book-menu a {
    color: var(--accent-light);
}
.book-menu a:hover {
    opacity: 1;
    color: var(--accent-light);
    text-decoration: underline;
}

.book-menu a.active {
    color: var(--accent);
    font-weight: bold;
    text-decoration: underline;
}

ul a {
    color: var(--accent-light);
}

a {
    color: var(--accent);
}

.markdown a:visited {
    color: var(--accent);
    text-decoration: underline;
}
.markdown a {
    color: var(--accent);
    text-decoration: underline;
}

:focus {
    outline-style: none;
}

/* inline code */
main code {
    font-size: 17px;
    background: none;
    color: var(--accent-light);
    padding: 2px 6px;
}

main.api code {
    color: var(--text);
}

main.api code .type {
    color: var(--type);
}
main.api code .keyword {
    color: var(--keyword);
}
main.api code .op {
    color: var(--keyword);
}
main.api code .decl {
    color: var(--declaration);
}
main.api h1 code {
    font-size: 24px;
}
main.api blockquote.type {
    border-left: 3px solid var(--type);
}

main.api table.index-table {
    table-layout: fixed;
    width: 100%;
}

main.api table.index-table td {
    vertical-align: top;
}

main.api table.index-table td div.double {
    display: flex;
    flex-direction: row;
}

main.api table.index-table td div.double div {
    flex: 1;
}

@media screen and (max-width: 1199px) {
    main.api table.index-table td div.double {
        flex-direction: column;
    }
}

main.api table.index-table code {
    font-size: 15px;
}

main.api table.index-table a {
    color: var(--declaration);
}

/* block code */
main pre code {
    font-size: 15px;
    color: var(--text);
    font-weight: normal;
    font-family: var(--mono-font);
}

pre {
/*    padding: 10px;*/
    font-size: 15px;
    border: 0px solid var(--border);
    background-color: #171717;
}

pre code.hljs {
    padding: 0px;
    white-space: pre-wrap;
}

.hljs {
/*    background-color: var(--accent-bg);*/
    background-color: transparent;
}

.hljs-params {
    color: #c9d1d9;
}

blockquote {
    margin: 20px 0 20px 0;
    font-style: normal;
    border-left: 3px solid var(--header-line);
    padding: 3px 0px 3px 15px;
    color: var(--text);
}

blockquote p:nth-child(2) {
    margin-top: 5px;
}

blockquote p {
    margin: 0px;
    padding: 0px;
}

p {
    margin-block-start: 1.3em;
    margin-block-end: 1.3em;
}

blockquote em {
    color: #fb6767;
}

table {
    font-size: 18px;
    width: auto;
    line-height: 1.5em;
    display: table;
    margin: 0 0;
}

table thead {
    border-bottom: 0.15rem solid var(--header-line);
    width: auto;
}

table th {
    border: 0px solid var(--border);
    width: auto;
    background-color: transparent;
}

table td {
    border: 0px solid var(--border);
    width: auto;
}

table tbody tr:nth-child(even) {
    background-color: #111;
}

strong {
    color: var(--accent);
}</style>
</head>
<body id="table-of-contents">
<header>
    <h1 class="title">Cyber API</h1>
    <div class="sub-title">v0.4-dev 487-99baa59</div>
    <ul>
        <li><a href="https://cyberscript.dev" target="_blank" rel="noopener">Homepage</a></li>
        <li><a href="docs.html">Language Docs</a></li>
        <li><a href="https://cyberscript.dev/play.html" target="_blank" rel="noopener">Playground</a></li>
    </ul>
<!--     <div class="sub-title">Table of Contents</div>
    <ul>
        <li><a href="#introduction">Introduction.</a></li>
        <li><a href="#syntax">Syntax.</a></li>
        <li><a href="#basic-types">Basic Types.</a></li>
        <li><a href="#type-declarations">Type Declarations.</a></li>
        <li><a href="#c-types">C Types.</a></li>
        <li><a href="#control-flow">Control Flow.</a></li>
        <li><a href="#functions">Functions.</a></li>
        <li><a href="#memory">Memory.</a></li>
        <li><a href="#error-handling">Error Handling.</a></li>
        <li><a href="#concurrency">Concurrency.</a></li>
        <li><a href="#metaprogramming">Metaprogramming.</a></li>
        <li><a href="#modules">Modules.</a></li>
        <li><a href="#ffi">FFI.</a></li>
        <li><a href="#libcyber">libcyber.</a></li>
        <li><a href="#cli">CLI.</a></li>
    </ul>
 -->
    <div class="sub-title">core modules</div><ul><li><a href="#core">mod core</a></li><li><a href="#c">mod c</a></li><li><a href="#cy">mod cy</a></li><li><a href="#meta">mod meta</a></li></ul><div class="sub-title">std modules</div><ul><li><a href="#cli">mod cli</a></li><li><a href="#libc">mod libc</a></li><li><a href="#io">mod io</a></li><li><a href="#math">mod math</a></li><li><a href="#os">mod os</a></li><li><a href="#test">mod test</a></li></ul>
</header>
<main class="api">
    <h1 id="core"><code><span class="keyword">mod</span> <span class="decl">core</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl577"><span class="keyword">const</span> NullId</a></code></div><div><code><a href="#decl116"><span class="keyword">fn</span> @asr</a></code></div><div><code><a href="#decl572"><span class="keyword">fn</span> @await_</a></code></div><div><code><a href="#decl420"><span class="keyword">fn</span> @bitCast</a></code></div><div><code><a href="#decl123"><span class="keyword">fn</span> @bitTrunc</a></code></div><div><code><a href="#decl409"><span class="keyword">fn</span> @breakpoint</a></code></div><div><code><a href="#decl627"><span class="keyword">fn</span> @call</a></code></div><div><code><a href="#decl413"><span class="keyword">fn</span> @cmp</a></code></div><div><code><a href="#decl25"><span class="keyword">fn</span> @compute_int_max</a></code></div><div><code><a href="#decl26"><span class="keyword">fn</span> @compute_int_min</a></code></div><div><code><a href="#decl412"><span class="keyword">fn</span> @consume</a></code></div><div><code><a href="#decl423"><span class="keyword">fn</span> @copy</a></code></div><div><code><a href="#decl417"><span class="keyword">fn</span> @copyStruct</a></code></div><div><code><a href="#decl430"><span class="keyword">fn</span> @deinitObject</a></code></div><div><code><a href="#decl434"><span class="keyword">fn</span> @destruct</a></code></div><div><code><a href="#decl433"><span class="keyword">fn</span> @destruct_span</a></code></div><div><code><a href="#decl431"><span class="keyword">fn</span> @destructBox</a></code></div><div><code><a href="#decl424"><span class="keyword">fn</span> @enumToInt</a></code></div><div><code><a href="#decl416"><span class="keyword">fn</span> @eq</a></code></div><div><code><a href="#decl157"><span class="keyword">fn</span> @fabs</a></code></div><div><code><a href="#decl126"><span class="keyword">fn</span> @floatToInt</a></code></div><div><code><a href="#decl429"><span class="keyword">fn</span> @freeObject</a></code></div><div><code><a href="#decl613"><span class="keyword">fn</span> @gen_end</a></code></div><div><code><a href="#decl615"><span class="keyword">fn</span> @gen_next</a></code></div><div><code><a href="#decl427"><span class="keyword">fn</span> @getDeinitObject</a></code></div><div><code><a href="#decl428"><span class="keyword">fn</span> @getTypeDtor</a></code></div><div><code><a href="#decl400"><span class="keyword">fn</span> @init_astr_undef</a></code></div><div><code><a href="#decl401"><span class="keyword">fn</span> @init_astr_undef</a></code></div><div><code><a href="#decl402"><span class="keyword">fn</span> @init_ustr_undef</a></code></div><div><code><a href="#decl403"><span class="keyword">fn</span> @init_ustr_undef</a></code></div><div><code><a href="#decl425"><span class="keyword">fn</span> @intToEnum</a></code></div><div><code><a href="#decl426"><span class="keyword">fn</span> @intToEnumResult</a></code></div><div><code><a href="#decl127"><span class="keyword">fn</span> @intToFloat</a></code></div><div><code><a href="#decl407"><span class="keyword">fn</span> @isUniqueRef</a></code></div><div><code><a href="#decl414"><span class="keyword">fn</span> @memByteEqs</a></code></div><div><code><a href="#decl395"><span class="keyword">fn</span> @memcpy</a></code></div><div><code><a href="#decl394"><span class="keyword">fn</span> @memeq</a></code></div><div><code><a href="#decl415"><span class="keyword">fn</span> @memEqs</a></code></div><div><code><a href="#decl397"><span class="keyword">fn</span> @memmove</a></code></div><div><code><a href="#decl396"><span class="keyword">fn</span> @memset</a></code></div><div><code><a href="#decl398"><span class="keyword">fn</span> @new_object_undef</a></code></div><div><code><a href="#decl399"><span class="keyword">fn</span> @new_object_undef</a></code></div><div><code><a href="#decl623"><span class="keyword">fn</span> @new_shared_state</a></code></div><div><code><a href="#decl624"><span class="keyword">fn</span> @new_thread</a></code></div><div><code><a href="#decl408"><span class="keyword">fn</span> @nop</a></code></div><div><code><a href="#decl573"><span class="keyword">fn</span> @notifyFutureComplete</a></code></div><div><code><a href="#decl432"><span class="keyword">fn</span> @partial_destruct</a></code></div><div><code><a href="#decl556"><span class="keyword">fn</span> @ptr_init</a></code></div><div><code><a href="#decl557"><span class="keyword">fn</span> @ref_addr</a></code></div><div><code><a href="#decl406"><span class="keyword">fn</span> @refCount</a></code></div><div><code><a href="#decl404"><span class="keyword">fn</span> @releaseOnly</a></code></div></div><div><div><code><a href="#decl567"><span class="keyword">fn</span> @result_unwrap</a></code></div><div><code><a href="#decl569"><span class="keyword">fn</span> @result_unwrap_error</a></code></div><div><code><a href="#decl405"><span class="keyword">fn</span> @retain</a></code></div><div><code><a href="#decl419"><span class="keyword">fn</span> @scope_ptr_to_borrow</a></code></div><div><code><a href="#decl422"><span class="keyword">fn</span> @send</a></code></div><div><code><a href="#decl124"><span class="keyword">fn</span> @sext</a></code></div><div><code><a href="#decl625"><span class="keyword">fn</span> @start_thread</a></code></div><div><code><a href="#decl626"><span class="keyword">fn</span> @thread_entry</a></code></div><div><code><a href="#decl605"><span class="keyword">fn</span> @trackMainLocal</a></code></div><div><code><a href="#decl418"><span class="keyword">fn</span> @unsafeCast</a></code></div><div><code><a href="#decl125"><span class="keyword">fn</span> @zext</a></code></div><div><code><a href="#decl2"><span class="keyword">fn</span> abort</a></code></div><div><code><a href="#decl3"><span class="keyword">fn</span> alloc</a></code></div><div><code><a href="#decl4"><span class="keyword">fn</span> alloc</a></code></div><div><code><a href="#decl6"><span class="keyword">fn</span> assert</a></code></div><div><code><a href="#decl7"><span class="keyword">fn</span> assert</a></code></div><div><code><a href="#decl137"><span class="keyword">fn</span> atof</a></code></div><div><code><a href="#decl138"><span class="keyword">fn</span> atof32</a></code></div><div><code><a href="#decl437"><span class="keyword">fn</span> AutoEq</a></code></div><div><code><a href="#decl436"><span class="keyword">fn</span> AutoHash</a></code></div><div><code><a href="#decl8"><span class="keyword">fn</span> binary_search</a></code></div><div><code><a href="#decl9"><span class="keyword">fn</span> binary_search_lower</a></code></div><div><code><a href="#decl10"><span class="keyword">fn</span> dump</a></code></div><div><code><a href="#decl11"><span class="keyword">fn</span> dump_str</a></code></div><div><code><a href="#decl12"><span class="keyword">fn</span> dump_str</a></code></div><div><code><a href="#decl13"><span class="keyword">fn</span> eprint</a></code></div><div><code><a href="#decl14"><span class="keyword">fn</span> eprints</a></code></div><div><code><a href="#decl144"><span class="keyword">fn</span> f32_fmt</a></code></div><div><code><a href="#decl141"><span class="keyword">fn</span> f32_to_f64</a></code></div><div><code><a href="#decl143"><span class="keyword">fn</span> f64_fmt</a></code></div><div><code><a href="#decl142"><span class="keyword">fn</span> f64_to_f32</a></code></div><div><code><a href="#decl139"><span class="keyword">fn</span> float_pow</a></code></div><div><code><a href="#decl140"><span class="keyword">fn</span> float_pow32</a></code></div><div><code><a href="#decl16"><span class="keyword">fn</span> free</a></code></div><div><code><a href="#decl120"><span class="keyword">fn</span> int_fmt</a></code></div><div><code><a href="#decl19"><span class="keyword">fn</span> log</a></code></div><div><code><a href="#decl619"><span class="keyword">fn</span> max</a></code></div><div><code><a href="#decl618"><span class="keyword">fn</span> min</a></code></div><div><code><a href="#decl221"><span class="keyword">fn</span> new_slice_buffer</a></code></div><div><code><a href="#decl17"><span class="keyword">fn</span> panic</a></code></div><div><code><a href="#decl27"><span class="keyword">fn</span> panic_unwrap_error</a></code></div><div><code><a href="#decl21"><span class="keyword">fn</span> print</a></code></div><div><code><a href="#decl22"><span class="keyword">fn</span> prints</a></code></div><div><code><a href="#decl74"><span class="keyword">fn</span> raw_fmt</a></code></div><div><code><a href="#decl622"><span class="keyword">fn</span> spawn</a></code></div><div><code><a href="#decl438"><span class="keyword">fn</span> splitmix64_hash</a></code></div><div><code><a href="#decl24"><span class="keyword">fn</span> to_print_string</a></code></div><div><code><a href="#decl482"><span class="keyword">fn</span> utf8Check</a></code></div><div><code><a href="#decl483"><span class="keyword">fn</span> utf8Decode</a></code></div><div><code><a href="#decl484"><span class="keyword">fn</span> utf8SeqLen</a></code></div><div><code><a href="#decl188"><span class="keyword">type</span> AcquireBorrowKind</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl167"><span class="keyword">type</span> Any</a></code></div><div><code><a href="#decl291"><span class="keyword">type</span> Array</a> (40)</code></div><div><code><a href="#decl279"><span class="keyword">type</span> ArrayStore</a> (11)</code></div><div><code><a href="#decl254"><span class="keyword">type</span> AsSpan</a></code></div><div><code><a href="#decl30"><span class="keyword">type</span> bool</a> (4)</code></div><div><code><a href="#decl585"><span class="keyword">type</span> Borrow</a></code></div><div><code><a href="#decl198"><span class="keyword">type</span> Buffer</a> (20)</code></div><div><code><a href="#decl46"><span class="keyword">type</span> byte =</a></code></div><div><code><a href="#decl411"><span class="keyword">type</span> ClosureData</a></code></div><div><code><a href="#decl172"><span class="keyword">type</span> Code =</a></code></div><div><code><a href="#decl333"><span class="keyword">type</span> CompareIndexFn =</a></code></div><div><code><a href="#decl334"><span class="keyword">type</span> CompareOrder</a></code></div><div><code><a href="#decl255"><span class="keyword">type</span> Const</a> (1)</code></div><div><code><a href="#decl257"><span class="keyword">type</span> ConstSpan</a></code></div><div><code><a href="#decl180"><span class="keyword">type</span> Copyable</a> (1)</code></div><div><code><a href="#decl410"><span class="keyword">type</span> DeinitFn =</a></code></div><div><code><a href="#decl168"><span class="keyword">type</span> dependent</a></code></div><div><code><a href="#decl620"><span class="keyword">type</span> Dyn</a></code></div><div><code><a href="#decl128"><span class="keyword">type</span> Endian</a></code></div><div><code><a href="#decl351"><span class="keyword">type</span> EqFn =</a></code></div><div><code><a href="#decl37"><span class="keyword">type</span> error</a> (2)</code></div><div><code><a href="#decl193"><span class="keyword">type</span> EvalBuffer</a> (4)</code></div><div><code><a href="#decl40"><span class="keyword">type</span> EvalInt</a></code></div><div><code><a href="#decl41"><span class="keyword">type</span> EvalStr</a> (3)</code></div><div><code><a href="#decl185"><span class="keyword">type</span> Ex</a> (2)</code></div><div><code><a href="#decl586"><span class="keyword">type</span> ExBorrow</a></code></div><div><code><a href="#decl183"><span class="keyword">type</span> ExDefaultInner</a></code></div><div><code><a href="#decl184"><span class="keyword">type</span> ExInner</a></code></div><div><code><a href="#decl130"><span class="keyword">type</span> f32 =</a></code></div><div><code><a href="#decl131"><span class="keyword">type</span> f64 =</a></code></div><div><code><a href="#decl132"><span class="keyword">type</span> float =</a></code></div><div><code><a href="#decl133"><span class="keyword">type</span> Float</a> (16)</code></div><div><code><a href="#decl339"><span class="keyword">type</span> FnTuple</a></code></div><div><code><a href="#decl341"><span class="keyword">type</span> Func</a> (1)</code></div><div><code><a href="#decl340"><span class="keyword">type</span> funcptr_t</a></code></div><div><code><a href="#decl335"><span class="keyword">type</span> FuncSig</a> (3)</code></div><div><code><a href="#decl345"><span class="keyword">type</span> funcsym_t</a></code></div><div><code><a href="#decl574"><span class="keyword">type</span> Future</a> (3)</code></div><div><code><a href="#decl580"><span class="keyword">type</span> FutureResolver</a> (3)</code></div><div><code><a href="#decl576"><span class="keyword">type</span> FutureValue</a></code></div><div><code><a href="#decl608"><span class="keyword">type</span> Generator</a> (6)</code></div><div><code><a href="#decl617"><span class="keyword">type</span> GeneratorStatus</a></code></div><div><code><a href="#decl532"><span class="keyword">type</span> GenericVector</a></code></div><div><code><a href="#decl350"><span class="keyword">type</span> HashFn =</a></code></div><div><code><a href="#decl374"><span class="keyword">type</span> HashMap</a> (18)</code></div><div><code><a href="#decl76"><span class="keyword">type</span> i16 =</a></code></div><div><code><a href="#decl77"><span class="keyword">type</span> i32 =</a></code></div><div><code><a href="#decl78"><span class="keyword">type</span> i64 =</a></code></div><div><code><a href="#decl75"><span class="keyword">type</span> i8 =</a></code></div><div><code><a href="#decl169"><span class="keyword">type</span> Infer</a></code></div><div><code><a href="#decl79"><span class="keyword">type</span> int =</a></code></div></div><div><div><div><code><a href="#decl81"><span class="keyword">type</span> Int</a> (39)</code></div><div><code><a href="#decl80"><span class="keyword">type</span> isize =</a></code></div><div><code><a href="#decl346"><span class="keyword">type</span> LessFn =</a></code></div><div><code><a href="#decl360"><span class="keyword">type</span> Map</a> (13)</code></div><div><code><a href="#decl435"><span class="keyword">type</span> MapEntry</a></code></div><div><code><a href="#decl29"><span class="keyword">type</span> never</a></code></div><div><code><a href="#decl182"><span class="keyword">type</span> NoCopy</a></code></div><div><code><a href="#decl129"><span class="keyword">type</span> NumberFormat</a></code></div><div><code><a href="#decl45"><span class="keyword">type</span> NumberFormatConfig</a></code></div><div><code><a href="#decl159"><span class="keyword">type</span> Object</a> (6)</code></div><div><code><a href="#decl343"><span class="keyword">type</span> OpaqueFunc</a> (1)</code></div><div><code><a href="#decl570"><span class="keyword">type</span> Option</a> (1)</code></div><div><code><a href="#decl348"><span class="keyword">type</span> Pair</a></code></div><div><code><a href="#decl171"><span class="keyword">type</span> PartialStructLayout =</a></code></div><div><code><a href="#decl533"><span class="keyword">type</span> PartialVector</a> (5)</code></div><div><code><a href="#decl553"><span class="keyword">type</span> Ptr</a> (6)</code></div><div><code><a href="#decl587"><span class="keyword">type</span> PtrSpan</a> (17)</code></div><div><code><a href="#decl48"><span class="keyword">type</span> r16 =</a></code></div><div><code><a href="#decl49"><span class="keyword">type</span> r32 =</a></code></div><div><code><a href="#decl50"><span class="keyword">type</span> r64 =</a></code></div><div><code><a href="#decl47"><span class="keyword">type</span> r8 =</a></code></div><div><code><a href="#decl562"><span class="keyword">type</span> Range</a></code></div><div><code><a href="#decl52"><span class="keyword">type</span> Raw</a> (21)</code></div><div><code><a href="#decl173"><span class="keyword">type</span> RawBuffer</a> (6)</code></div><div><code><a href="#decl584"><span class="keyword">type</span> Ref</a></code></div><div><code><a href="#decl349"><span class="keyword">type</span> RefChild</a></code></div><div><code><a href="#decl564"><span class="keyword">type</span> Result</a> (3)</code></div><div><code><a href="#decl51"><span class="keyword">type</span> rsize =</a></code></div><div><code><a href="#decl191"><span class="keyword">type</span> RtBorrow</a> (1)</code></div><div><code><a href="#decl189"><span class="keyword">type</span> RtExBorrow</a> (1)</code></div><div><code><a href="#decl219"><span class="keyword">type</span> Slice</a> (33)</code></div><div><code><a href="#decl258"><span class="keyword">type</span> Span</a> (20)</code></div><div><code><a href="#decl352"><span class="keyword">type</span> StaticMap</a> (7)</code></div><div><code><a href="#decl458"><span class="keyword">type</span> Str</a></code></div><div><code><a href="#decl459"><span class="keyword">type</span> str</a> (69)</code></div><div><code><a href="#decl456"><span class="keyword">type</span> StrBuffer</a> (1)</code></div><div><code><a href="#decl35"><span class="keyword">type</span> symbol</a> (1)</code></div><div><code><a href="#decl606"><span class="keyword">type</span> SystemKind</a></code></div><div><code><a href="#decl347"><span class="keyword">type</span> Table</a></code></div><div><code><a href="#decl166"><span class="keyword">type</span> TaskCallback =</a></code></div><div><code><a href="#decl563"><span class="keyword">type</span> TccState</a></code></div><div><code><a href="#decl621"><span class="keyword">type</span> Thread</a></code></div><div><code><a href="#decl421"><span class="keyword">type</span> TraitStruct</a></code></div><div><code><a href="#decl170"><span class="keyword">type</span> type =</a></code></div><div><code><a href="#decl607"><span class="keyword">type</span> VaList</a></code></div><div><code><a href="#decl539"><span class="keyword">type</span> Vector</a> (13)</code></div><div><code><a href="#decl28"><span class="keyword">type</span> void</a></code></div><div><code><a href="#decl439"><span class="keyword">type</span> Wyhash</a> (16)</code></div></div></div></td></tr></tbody></table><blockquote id="decl577"><code><span class="keyword">const</span> <span class="decl">NullId</span> = (1 << 32) - 1<br/></code></blockquote><blockquote id="decl116"><code><span class="keyword">fn</span> <span class="decl">@asr</span>(x <span class="type">Int[%Bits]</span>, amt <span class="type">Int[Bits]</span>) </code><br /></blockquote><blockquote id="decl572"><code><span class="keyword">fn</span> <span class="decl">@await_</span>(fut <span class="type">&FutureValue[%T]</span>) </code><br /></blockquote><blockquote id="decl420"><code><span class="keyword">fn</span> <span class="decl">@bitCast</span>(T <span class="type">type</span>, x <span class="type">%S</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl123"><code><span class="keyword">fn</span> <span class="decl">@bitTrunc</span>(T <span class="type">type</span>, src <span class="type">Code</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl409"><code><span class="keyword">fn</span> <span class="decl">@breakpoint</span>() </code><br /></blockquote><blockquote id="decl627"><code><span class="keyword">fn</span> <span class="decl">@call</span>(func <span class="type">funcptr_t[%Sig]</span>, args <span class="type">&FnTuple[Sig]</span>) -> <span class="type">Sig.ret()</span></code><br /></blockquote><blockquote id="decl413"><code><span class="keyword">fn</span> <span class="decl">@cmp</span>(a <span class="type">Code</span>, b <span class="type">Code</span>) -> <span class="type">bool</span></code><br />Compare like a primitive.</blockquote><blockquote id="decl25"><code><span class="keyword">fn</span> <span class="decl">@compute_int_max</span>(T <span class="type">type</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl26"><code><span class="keyword">fn</span> <span class="decl">@compute_int_min</span>(T <span class="type">type</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl412"><code><span class="keyword">fn</span> <span class="decl">@consume</span>(a <span class="type">Code</span>) </code><br />Consumes a local. Does not invoke destructor.</blockquote><blockquote id="decl423"><code><span class="keyword">fn</span> <span class="decl">@copy</span>(src <span class="type">Ptr[%T]</span>) -> <span class="type">T</span></code><br />Generic copy for any type. Marked unsafe to allow copying borrow containers.</blockquote><blockquote id="decl417"><code><span class="keyword">fn</span> <span class="decl">@copyStruct</span>(T <span class="type">type</span>, src_ptr <span class="type">Code</span>) -> <span class="type">T</span></code><br />Marked unsafe to allow copying borrow containers.</blockquote><blockquote id="decl430"><code><span class="keyword">fn</span> <span class="decl">@deinitObject</span>[T <span class="type">Any</span>](obj <span class="type">Ptr[void]</span>) </code><br /></blockquote><blockquote id="decl434"><code><span class="keyword">fn</span> <span class="decl">@destruct</span>(T <span class="type">type</span>, val <span class="type">Ptr[T]</span>) </code><br />Generic destructor for any type.</blockquote><blockquote id="decl433"><code><span class="keyword">fn</span> <span class="decl">@destruct_span</span>(span <span class="type">PtrSpan[%T]</span>) </code><br /></blockquote><blockquote id="decl431"><code><span class="keyword">fn</span> <span class="decl">@destructBox</span>(ptr <span class="type">Ptr[void]</span>) </code><br />Exposed for VM.</blockquote><blockquote id="decl424"><code><span class="keyword">fn</span> <span class="decl">@enumToInt</span>(val <span class="type">%T</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl416"><code><span class="keyword">fn</span> <span class="decl">@eq</span>(a <span class="type">&%T</span>, b <span class="type">&T</span>) -> <span class="type">bool</span></code><br />This is invoked for the comparison operator for non primitive types. Comparing references returns true if they refer to the same instance.</blockquote><blockquote id="decl157"><code><span class="keyword">fn</span> <span class="decl">@fabs</span>(x <span class="type">Float[%Bits]</span>) -> <span class="type">Float[Bits]</span></code><br /></blockquote><blockquote id="decl126"><code><span class="keyword">fn</span> <span class="decl">@floatToInt</span>(F <span class="type">type</span>, x <span class="type">Code</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl429"><code><span class="keyword">fn</span> <span class="decl">@freeObject</span>(ref <span class="type">Ptr[void]</span>, size <span class="type">int</span>) </code><br /></blockquote><blockquote id="decl613"><code><span class="keyword">fn</span> <span class="decl">@gen_end</span>(gen <span class="type">Generator[%FnPtr]</span>) </code><br /></blockquote><blockquote id="decl615"><code><span class="keyword">fn</span> <span class="decl">@gen_next</span>(gen <span class="type">Generator[%FnPtr]</span>) -> <span class="type">?(type.fn_ret(FnPtr))</span></code><br /></blockquote><blockquote id="decl427"><code><span class="keyword">fn</span> <span class="decl">@getDeinitObject</span>(obj <span class="type">Ptr[void]</span>) -> <span class="type">?DeinitFn</span></code><br />Returns a function to release and destroy for a object runtime type. Returns `none` if the function is a no-op. Panics if the function could not be found.</blockquote><blockquote id="decl428"><code><span class="keyword">fn</span> <span class="decl">@getTypeDtor</span>(type_id <span class="type">int</span>) -> <span class="type">?DeinitFn</span></code><br />Returns `@destruct` for the given type.</blockquote><blockquote id="decl400"><code><span class="keyword">fn</span> <span class="decl">@init_astr_undef</span>(len <span class="type">int</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl401"><code><span class="keyword">fn</span> <span class="decl">@init_astr_undef</span>(thread <span class="type">Thread</span>, len <span class="type">int</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl402"><code><span class="keyword">fn</span> <span class="decl">@init_ustr_undef</span>(len <span class="type">int</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl403"><code><span class="keyword">fn</span> <span class="decl">@init_ustr_undef</span>(thread <span class="type">Thread</span>, len <span class="type">int</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl425"><code><span class="keyword">fn</span> <span class="decl">@intToEnum</span>(T <span class="type">type</span>, val <span class="type">int</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl426"><code><span class="keyword">fn</span> <span class="decl">@intToEnumResult</span>(T <span class="type">type</span>, val <span class="type">int</span>) -> <span class="type">!T</span></code><br /></blockquote><blockquote id="decl127"><code><span class="keyword">fn</span> <span class="decl">@intToFloat</span>(F <span class="type">type</span>, x <span class="type">Code</span>) -> <span class="type">F</span></code><br /></blockquote><blockquote id="decl407"><code><span class="keyword">fn</span> <span class="decl">@isUniqueRef</span>(ptr <span class="type">Ptr[void]</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl414"><code><span class="keyword">fn</span> <span class="decl">@memByteEqs</span>(a <span class="type">PtrSpan[byte]</span>, b <span class="type">PtrSpan[byte]</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl395"><code><span class="keyword">fn</span> <span class="decl">@memcpy</span>(dst <span class="type">Ptr[byte]</span>, src <span class="type">Ptr[byte]</span>, len <span class="type">int</span>) </code><br />Assumes no-alias `dst` and `src` regions.</blockquote><blockquote id="decl394"><code><span class="keyword">fn</span> <span class="decl">@memeq</span>(a <span class="type">[]%T</span>, b <span class="type">[]T</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl415"><code><span class="keyword">fn</span> <span class="decl">@memEqs</span>(a <span class="type">PtrSpan[%T]</span>, b <span class="type">PtrSpan[T]</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl397"><code><span class="keyword">fn</span> <span class="decl">@memmove</span>(dst <span class="type">Ptr[byte]</span>, src <span class="type">Ptr[byte]</span>, len <span class="type">int</span>) </code><br /></blockquote><blockquote id="decl396"><code><span class="keyword">fn</span> <span class="decl">@memset</span>(dst <span class="type">Ptr[byte]</span>, val <span class="type">Ptr[byte]</span>, val_len <span class="type">int</span>, n <span class="type">int</span>) </code><br /></blockquote><blockquote id="decl398"><code><span class="keyword">fn</span> <span class="decl">@new_object_undef</span>(type_id <span class="type">int</span>, nbytes <span class="type">int</span>) -> <span class="type">Ptr[void]</span></code><br /></blockquote><blockquote id="decl399"><code><span class="keyword">fn</span> <span class="decl">@new_object_undef</span>(thread <span class="type">Thread</span>, type_id <span class="type">int</span>, nbytes <span class="type">int</span>) -> <span class="type">Ptr[void]</span></code><br /></blockquote><blockquote id="decl623"><code><span class="keyword">fn</span> <span class="decl">@new_shared_state</span>() -> <span class="type">Ptr[byte]</span></code><br /></blockquote><blockquote id="decl624"><code><span class="keyword">fn</span> <span class="decl">@new_thread</span>() -> <span class="type">Thread</span></code><br /></blockquote><blockquote id="decl408"><code><span class="keyword">fn</span> <span class="decl">@nop</span>(label <span class="type">EvalStr</span>) </code><br />Insert a nop IR with a label.</blockquote><blockquote id="decl573"><code><span class="keyword">fn</span> <span class="decl">@notifyFutureComplete</span>(f <span class="type">Future[%T]</span>) </code><br /></blockquote><blockquote id="decl432"><code><span class="keyword">fn</span> <span class="decl">@partial_destruct</span>(T <span class="type">type</span>, Layout <span class="type">PartialStructLayout</span>, val <span class="type">Ptr[T]</span>) </code><br />Partial destructor.</blockquote><blockquote id="decl556"><code><span class="keyword">fn</span> <span class="decl">@ptr_init</span>(ptr <span class="type">Ptr[%T]</span>, value <span class="type">T</span>) </code><br /></blockquote><blockquote id="decl557"><code><span class="keyword">fn</span> <span class="decl">@ref_addr</span>(ref <span class="type">^%T</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl406"><code><span class="keyword">fn</span> <span class="decl">@refCount</span>(obj <span class="type">Object</span>) -> <span class="type">int</span></code><br />Returns the current reference count of an object.</blockquote><blockquote id="decl404"><code><span class="keyword">fn</span> <span class="decl">@releaseOnly</span>(obj <span class="type">Ptr[void]</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl567"><code><span class="keyword">fn</span> <span class="decl">@result_unwrap</span>(T <span class="type">type</span>, res <span class="type">Code</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl569"><code><span class="keyword">fn</span> <span class="decl">@result_unwrap_error</span>(res <span class="type">Code</span>) -> <span class="type">error</span></code><br /></blockquote><blockquote id="decl405"><code><span class="keyword">fn</span> <span class="decl">@retain</span>(obj <span class="type">Ptr[void]</span>) </code><br /></blockquote><blockquote id="decl419"><code><span class="keyword">fn</span> <span class="decl">@scope_ptr_to_borrow</span>(scope_param <span class="type">EvalStr</span>, ptr <span class="type">Ptr[%T]</span>) -> <span class="type">&T</span></code><br /></blockquote><blockquote id="decl422"><code><span class="keyword">fn</span> <span class="decl">@send</span>(dst <span class="type">Thread</span>, src <span class="type">Ptr[%T]</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl124"><code><span class="keyword">fn</span> <span class="decl">@sext</span>(T <span class="type">type</span>, src <span class="type">%S</span>) -> <span class="type">T</span></code><br />Sign extension.</blockquote><blockquote id="decl625"><code><span class="keyword">fn</span> <span class="decl">@start_thread</span>(thread <span class="type">Thread</span>, entry <span class="type">funcptr_t[%EntrySig]</span>, func <span class="type">funcptr_t[%Sig]</span>, args_size <span class="type">int</span>, args <span class="type">FnTuple[Sig]</span>, future <span class="type">^FutureValue[Sig.ret()]</span>, ret_size <span class="type">int</span>) </code><br /></blockquote><blockquote id="decl626"><code><span class="keyword">fn</span> <span class="decl">@thread_entry</span>[Sig <span class="type">FuncSig</span>](result_thread <span class="type">Thread</span>, func <span class="type">funcptr_t[Sig]</span>, args <span class="type">FnTuple[Sig]</span>) -> <span class="type">Sig.ret()</span></code><br /></blockquote><blockquote id="decl605"><code><span class="keyword">fn</span> <span class="decl">@trackMainLocal</span>(name <span class="type">str</span>, type_id <span class="type">int</span>, addr <span class="type">Ptr[void]</span>) </code><br /></blockquote><blockquote id="decl418"><code><span class="keyword">fn</span> <span class="decl">@unsafeCast</span>(T <span class="type">type</span>, src <span class="type">Code</span>) -> <span class="type">T</span></code><br />Casting without compatibility checking.</blockquote><blockquote id="decl125"><code><span class="keyword">fn</span> <span class="decl">@zext</span>(T <span class="type">type</span>, src <span class="type">%S</span>) -> <span class="type">T</span></code><br />Zero extension.</blockquote><blockquote id="decl2"><code><span class="keyword">fn</span> <span class="decl">abort</span>(err <span class="type">str</span>) -> <span class="type">never</span></code><br />Terminate program with an error message.</blockquote><blockquote id="decl3"><code><span class="keyword">fn</span> <span class="decl">alloc</span>(T <span class="type">type</span>) -> <span class="type">Ptr[T]</span></code><br /></blockquote><blockquote id="decl4"><code><span class="keyword">fn</span> <span class="decl">alloc</span>(T <span class="type">type</span>, n <span class="type">int</span>) -> <span class="type">PtrSpan[T]</span></code><br />Unsafe. Allocate memory using the default allocator.</blockquote><blockquote id="decl6"><code><span class="keyword">fn</span> <span class="decl">assert</span>(pred <span class="type">bool</span>) </code><br /></blockquote><blockquote id="decl7"><code><span class="keyword">fn</span> <span class="decl">assert</span>(exp <span class="type">%T</span>, act <span class="type">T</span>) </code><br /></blockquote><blockquote id="decl137"><code><span class="keyword">fn</span> <span class="decl">atof</span>(x <span class="type">str</span>) -> <span class="type">float</span></code><br /></blockquote><blockquote id="decl138"><code><span class="keyword">fn</span> <span class="decl">atof32</span>(x <span class="type">str</span>) -> <span class="type">f32</span></code><br /></blockquote><blockquote id="decl437"><code><span class="keyword">fn</span> <span class="decl">AutoEq</span>[K <span class="type">Any</span>](a <span class="type">K</span>, b <span class="type">K</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl436"><code><span class="keyword">fn</span> <span class="decl">AutoHash</span>[K <span class="type">Any</span>](key <span class="type">K</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl8"><code><span class="keyword">fn</span> <span class="decl">binary_search</span>(len <span class="type">int</span>, needle <span class="type">%T</span>, compare <span class="type">&OpaqueFunc[CompareIndexFn[T]]</span>) -> <span class="type">?int</span></code><br />Assumes a sorted span in ascending order.</blockquote><blockquote id="decl9"><code><span class="keyword">fn</span> <span class="decl">binary_search_lower</span>(len <span class="type">int</span>, needle <span class="type">%T</span>, compare <span class="type">&OpaqueFunc[CompareIndexFn[T]]</span>) -> <span class="type">int</span></code><br />Assumes a sorted span in ascending order. Returns the lowest index where the element at the index is greater than or equal to the needle. If no such element exists, the index after the last element is returned.</blockquote><blockquote id="decl10"><code><span class="keyword">fn</span> <span class="decl">dump</span>(val <span class="type">%T</span>) </code><br />Deep dump of a value.</blockquote><blockquote id="decl11"><code><span class="keyword">fn</span> <span class="decl">dump_str</span>(val <span class="type">%T</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl12"><code><span class="keyword">fn</span> <span class="decl">dump_str</span>(val <span class="type">&%T</span>, indent <span class="type">int</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl13"><code><span class="keyword">fn</span> <span class="decl">eprint</span>(x <span class="type">%T</span>) </code><br />Prints a value to the error stream.</blockquote><blockquote id="decl14"><code><span class="keyword">fn</span> <span class="decl">eprints</span>(x <span class="type">%T</span>) </code><br /></blockquote><blockquote id="decl144"><code><span class="keyword">fn</span> <span class="decl">f32_fmt</span>(x <span class="type">f32</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl141"><code><span class="keyword">fn</span> <span class="decl">f32_to_f64</span>(x <span class="type">f32</span>) -> <span class="type">float</span></code><br /></blockquote><blockquote id="decl143"><code><span class="keyword">fn</span> <span class="decl">f64_fmt</span>(x <span class="type">float</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl142"><code><span class="keyword">fn</span> <span class="decl">f64_to_f32</span>(x <span class="type">float</span>) -> <span class="type">f32</span></code><br /></blockquote><blockquote id="decl139"><code><span class="keyword">fn</span> <span class="decl">float_pow</span>(x, y <span class="type">float</span>) -> <span class="type">float</span></code><br /></blockquote><blockquote id="decl140"><code><span class="keyword">fn</span> <span class="decl">float_pow32</span>(x, y <span class="type">float</span>) -> <span class="type">f32</span></code><br /></blockquote><blockquote id="decl16"><code><span class="keyword">fn</span> <span class="decl">free</span>(ptr <span class="type">Ptr[void]</span>) </code><br />Unsafe. Frees memory allocated by the default allocator.</blockquote><blockquote id="decl120"><code><span class="keyword">fn</span> <span class="decl">int_fmt</span>(x <span class="type">int</span>, format <span class="type">NumberFormat</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl19"><code><span class="keyword">fn</span> <span class="decl">log</span>(x <span class="type">%T</span>) </code><br />Logs a value to the host. Thread-safe.</blockquote><blockquote id="decl619"><code><span class="keyword">fn</span> <span class="decl">max</span>(a <span class="type">%T</span>, b <span class="type">T</span>) -> <span class="type">T</span></code><br />Returns the largest of two values.</blockquote><blockquote id="decl618"><code><span class="keyword">fn</span> <span class="decl">min</span>(a <span class="type">%T</span>, b <span class="type">T</span>) -> <span class="type">T</span></code><br />Returns the smallest of two values.</blockquote><blockquote id="decl221"><code><span class="keyword">fn</span> <span class="decl">new_slice_buffer</span>(T <span class="type">type</span>, cap <span class="type">int</span>) -> <span class="type">^RawBuffer[byte]</span></code><br /></blockquote><blockquote id="decl17"><code><span class="keyword">fn</span> <span class="decl">panic</span>(msg <span class="type">str</span>) -> <span class="type">never</span></code><br />Builds a stack trace and aborts the current thread.</blockquote><blockquote id="decl27"><code><span class="keyword">fn</span> <span class="decl">panic_unwrap_error</span>(err <span class="type">error</span>) -> <span class="type">never</span></code><br /></blockquote><blockquote id="decl21"><code><span class="keyword">fn</span> <span class="decl">print</span>(x <span class="type">%T</span>) </code><br />Prints a value to the output stream. Not thread-safe.</blockquote><blockquote id="decl22"><code><span class="keyword">fn</span> <span class="decl">prints</span>(x <span class="type">%T</span>) </code><br /></blockquote><blockquote id="decl74"><code><span class="keyword">fn</span> <span class="decl">raw_fmt</span>(x <span class="type">r64</span>, format <span class="type">NumberFormat</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl622"><code><span class="keyword">fn</span> <span class="decl">spawn</span>(func <span class="type">funcptr_t[%Sig]</span>, args <span class="type">FnTuple[Sig]</span>) -> <span class="type">Future[Sig.ret()]</span></code><br /></blockquote><blockquote id="decl438"><code><span class="keyword">fn</span> <span class="decl">splitmix64_hash</span>(x_ <span class="type">int</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl24"><code><span class="keyword">fn</span> <span class="decl">to_print_string</span>(x <span class="type">%T</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl482"><code><span class="keyword">fn</span> <span class="decl">utf8Check</span>(s <span class="type">Ptr[byte]</span>, remaining <span class="type">int</span>) -> <span class="type">bool</span></code><br />Source: https://github.com/sheredom/utf8.h</blockquote><blockquote id="decl483"><code><span class="keyword">fn</span> <span class="decl">utf8Decode</span>(s <span class="type">Ptr[byte]</span>) -> <span class="type">r32</span></code><br /></blockquote><blockquote id="decl484"><code><span class="keyword">fn</span> <span class="decl">utf8SeqLen</span>(first <span class="type">byte</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl188" class="type"><code><span class="keyword">type</span> <span class="decl">AcquireBorrowKind</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> acquired</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> borrowed</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ex_borrowed</code><br /></blockquote><blockquote id="decl167" class="type"><code><span class="keyword">type</span> <span class="decl">Any</span> _</code><br/></blockquote><blockquote id="decl291" class="type"><code><span class="keyword">type</span> <span class="decl">Array</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">NoCopy</span>, <span class="decl">AsSpan[T]</span></code><br/>A dynamically sized data structure that contains a sequence of elements. Can be cloned or sliced into mutable spans. Any operation that resizes the array requires an exclusive borrow.</blockquote><blockquote id="decl294"><code><span class="keyword">fn</span> <span class="type">Array[]</span> :: <span class="decl">@init</span>(n <span class="type">int</span>, val <span class="type">T</span>) -> <span class="type">Self</span></code><br />Creates an array with initial length and capacity of `n` and values set to `val`.</blockquote><blockquote id="decl293"><code><span class="keyword">fn</span> <span class="type">Array[]</span> :: <span class="decl">@init_sequence</span>(init <span class="type">[&]T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">@acquire_borrow</span>() -> <span class="type">AcquireBorrowKind</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">@acquire_ex_borrow</span>() -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">@index</span>(idx <span class="type">int</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Array[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">&T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">@release_borrow</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">@release_ex_borrow</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">@set_index</span>(idx <span class="type">int</span>, val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Array[]</span>) <span class="decl">@slice</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Array[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Array[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>, end <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">`<<`</span>(val <span class="type">T</span>) </code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">`<<`</span>(span <span class="type">[&]T</span>) </code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">`<<`</span>(arr <span class="type">AsSpan[T]</span>) </code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">append</span>(val <span class="type">T</span>) </code><br />Appends a value to the end of the array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">append</span>(span <span class="type">[&]T</span>) </code><br />Appends the elements of a span to the end of this array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">append</span>(arr <span class="type">AsSpan[T]</span>) </code><br />Appends the elements of a `AsSpan` to the end of this array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Array[]</span>) <span class="decl">as_buffer</span>() -> <span class="type">Buffer[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">cap</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">clear</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">clone</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">contains</span>(needle <span class="type">T</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">ensure_cap</span>(new_cap <span class="type">int</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">ensureUnusedCap</span>(unused <span class="type">int</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">index</span>(needle <span class="type">T</span>) -> <span class="type">?int</span></code><br />Returns the first index of `needle` in the array or `none` if not found.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">insert</span>(idx <span class="type">int</span>, val <span class="type">T</span>) </code><br />Inserts a value at index `idx`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br />Returns a new iterator over the slice elements.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">join</span>(sep <span class="type">str</span>) -> <span class="type">str</span></code><br />Returns a new string that joins the elements with `separator`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">last</span>() -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">own_msb</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">remove</span>(idx <span class="type">int</span>) </code><br />Removes an element at index `idx`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">setLast</span>(val <span class="type">T</span>) -> <span class="type">void</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">size_down</span>(new_len <span class="type">int</span>) </code><br />Decreases the size of the array to `new_len` elements. If the new size is smaller, elements at the end of the array are removed.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Array[]</span>) <span class="decl">size_up</span>(new_len <span class="type">int</span>, init <span class="type">T</span>) </code><br />Increases the size of the array to `new_len` elements. If the new size is bigger, `init` values are appended to the array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Array[]</span>) <span class="decl">sort</span>(less <span class="type">&OpaqueFunc[LessFn[T]]</span>) </code><br />Sorts the array with the given `less` function. If element `a` should be ordered before `b`, the function should return `true` otherwise `false`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Array[]</span>) <span class="decl">span</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote id="decl279" class="type"><code><span class="keyword">type</span> <span class="decl">ArrayStore</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">NoCopy</span></code><br/>A dynamically sized data structure that contains a sequence of elements. Meant for storing and retrieving small value types such as primitives and references. Cannot be sliced and does not allow referencing to the elements. These constraints allow resizing operations without an exclusive borrow.</blockquote><blockquote id="decl280"><code><span class="keyword">fn</span> <span class="type">ArrayStore[]</span> :: <span class="decl">@init_sequence</span>(init <span class="type">[&]T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">@index</span>(idx <span class="type">int</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">@set_index</span>(idx <span class="type">int</span>, val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">`<<`</span>(val <span class="type">T</span>) </code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">`<<`</span>(arr <span class="type">AsSpan[T]</span>) </code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">append</span>(val <span class="type">T</span>) </code><br />Appends a value to the end of the array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">append</span>(slice <span class="type">[&]T</span>) </code><br />Appends the elements of a `Span` to the end of this `ArrayStore`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">append</span>(arr <span class="type">AsSpan[T]</span>) </code><br />Appends the elements of a `AsSpan` to the end of this `ArrayStore`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">ensure_cap</span>(new_cap <span class="type">int</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArrayStore[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl254" class="type"><code><span class="keyword">type</span> <span class="decl">AsSpan</span>[T <span class="type">Any</span>] <span class="keyword">trait</span></code><br/></blockquote><blockquote id=""><code><span class="keyword">fn</span> <span class="decl">span</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote id="decl30" class="type"><code><span class="keyword">type</span> <span class="decl">bool</span> _</code><br/></blockquote><blockquote id="decl31"><code><span class="keyword">fn</span> <span class="type">bool</span> :: <span class="decl">@init</span>(val <span class="type">int</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl32"><code><span class="keyword">fn</span> <span class="type">bool</span> :: <span class="decl">@init</span>(val <span class="type">float</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl33"><code><span class="keyword">fn</span> <span class="type">bool</span> :: <span class="decl">@init</span>(val <span class="type">str</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">bool</span>) <span class="decl">`!`</span>() -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl585" class="type"><code><span class="keyword">type</span> <span class="decl">Borrow</span>[T <span class="type">Any</span>] _</code><br/></blockquote><blockquote id="decl198" class="type"><code><span class="keyword">type</span> <span class="decl">Buffer</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">NoCopy</span>, <span class="decl">AsSpan[T]</span></code><br/>A data structure that holds sequential elements up to a maximum capacity. `len()` indicates which elements are initialized. `cap()` is the total number of elements the buffer can hold.</blockquote><blockquote id="decl200"><code><span class="keyword">fn</span> <span class="type">Buffer[]</span> :: <span class="decl">@init</span>(nelems <span class="type">int</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl201"><code><span class="keyword">fn</span> <span class="type">Buffer[]</span> :: <span class="decl">@init</span>(n <span class="type">int</span>, value <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl199"><code><span class="keyword">fn</span> <span class="type">Buffer[]</span> :: <span class="decl">@init_sequence</span>(init <span class="type">[&]T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">@acquire_borrow</span>() -> <span class="type">AcquireBorrowKind</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">@acquire_ex_borrow</span>() -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Buffer[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">&T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">@release_borrow</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">@release_ex_borrow</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Buffer[]</span>) <span class="decl">@slice</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Buffer[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Buffer[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>, end <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Buffer[]</span>) <span class="decl">`<<`</span>(elem <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">cap</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">last</span>() -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Buffer[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&&Buffer[]</span>) <span class="decl">size_down</span>(new_len <span class="type">int</span>) </code><br />Decreases the size of the Buffer to `new_len` elements. If the new size is smaller, elements at the end of the Buffer are removed.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Buffer[]</span>) <span class="decl">span</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote id="decl46" class="type"><code><span class="keyword">type</span> <span class="decl">byte</span> = <span class="type">Raw[8]</span></code></blockquote><blockquote id="decl411" class="type"><code><span class="keyword">type</span> <span class="decl">ClosureData</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl172" class="type"><code><span class="keyword">type</span> <span class="decl">Code</span> = <span class="type">meta.Code</span></code></blockquote><blockquote id="decl333" class="type"><code><span class="keyword">type</span> <span class="decl">CompareIndexFn</span>[Context <span class="type">Any</span>] = <span class="type">fn(cx Context, idx int) -> CompareOrder</span></code></blockquote><blockquote id="decl334" class="type"><code><span class="keyword">type</span> <span class="decl">CompareOrder</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> eq</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> lt</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> gt</code><br /></blockquote><blockquote id="decl255" class="type"><code><span class="keyword">type</span> <span class="decl">Const</span> <span class="keyword">trait</span></code><br/>An implicit trait that conforms to a const eligible type.</blockquote><blockquote id="decl256"><code><span class="keyword">fn</span> <span class="type">Const</span> :: <span class="decl">@predicate</span>(T <span class="type">type</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl257" class="type"><code><span class="keyword">type</span> <span class="decl">ConstSpan</span>[T <span class="type">Const</span>] <span class="keyword">struct</span></code><br/>TODO: A `ConstSpan` behaves like a `Span` except it can only perform read operations. The element type `T` is restricted to be a const eligible type.</blockquote><blockquote id="decl180" class="type"><code><span class="keyword">type</span> <span class="decl">Copyable</span> <span class="keyword">trait</span></code><br/>An implicit trait that describes a type that allows implicit copying. A type is `Copyable` if these two conditions are met: 1. All its members are `Copyable` or the `@copy` method is implemented. 2. The type does not also implement `NoCopy`.</blockquote><blockquote id="decl181"><code><span class="keyword">fn</span> <span class="type">Copyable</span> :: <span class="decl">@predicate</span>(T <span class="type">type</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl410" class="type"><code><span class="keyword">type</span> <span class="decl">DeinitFn</span> = <span class="type">fn(Ptr[void]) -> void</span></code></blockquote><blockquote id="decl168" class="type"><code><span class="keyword">type</span> <span class="decl">dependent</span> _</code><br/></blockquote><blockquote id="decl620" class="type"><code><span class="keyword">type</span> <span class="decl">Dyn</span>[T <span class="type">Any</span>] _</code><br/>Wraps generic traits for dynamic dispatch. `Dyn` is an opaque type.</blockquote><blockquote id="decl128" class="type"><code><span class="keyword">type</span> <span class="decl">Endian</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> little</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> big</code><br /></blockquote><blockquote id="decl351" class="type"><code><span class="keyword">type</span> <span class="decl">EqFn</span>[T <span class="type">Any</span>] = <span class="type">fnsym(T, T) -> bool</span></code></blockquote><blockquote id="decl37" class="type"><code><span class="keyword">type</span> <span class="decl">error</span> _</code><br/></blockquote><blockquote id="decl38"><code><span class="keyword">fn</span> <span class="type">error</span> :: <span class="decl">@init</span>(val <span class="type">symbol</span>) -> <span class="type">error</span></code><br />Create an error from symbol.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">error</span>) <span class="decl">sym</span>() -> <span class="type">symbol</span></code><br />Return the underlying `symbol`.</blockquote><blockquote id="decl193" class="type"><code><span class="keyword">type</span> <span class="decl">EvalBuffer</span>[T <span class="type">Any</span>] _</code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">EvalBuffer[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="type">Ptr[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">EvalBuffer[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">EvalBuffer[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">EvalBuffer[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?T</span></code><br /></blockquote><blockquote id="decl40" class="type"><code><span class="keyword">type</span> <span class="decl">EvalInt</span> _</code><br/></blockquote><blockquote id="decl41" class="type"><code><span class="keyword">type</span> <span class="decl">EvalStr</span> _</code><br/>Const eval string.</blockquote><blockquote id="decl42"><code><span class="keyword">fn</span> <span class="type">EvalStr</span> :: <span class="decl">@init</span>(x <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl43"><code><span class="keyword">fn</span> <span class="type">EvalStr</span> :: <span class="decl">@init</span>(x <span class="type">%T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">EvalStr</span>) <span class="decl">`+`</span>(o <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl185" class="type"><code><span class="keyword">type</span> <span class="decl">Ex</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/>Exclusive borrow container. Allows exclusive borrowing to a child `T` in a shared reference `^Ex[T]`. Defers borrow checking to runtime.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Ex[]</span>) <span class="decl">borrow</span>() -> <span class="type">RtBorrow[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Ex[]</span>) <span class="decl">ex_borrow</span>() -> <span class="type">RtExBorrow[T]</span></code><br /></blockquote><blockquote id="decl586" class="type"><code><span class="keyword">type</span> <span class="decl">ExBorrow</span>[T <span class="type">Any</span>] _</code><br/></blockquote><blockquote id="decl183" class="type"><code><span class="keyword">type</span> <span class="decl">ExDefaultInner</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl184" class="type"><code><span class="keyword">type</span> <span class="decl">ExInner</span>[T <span class="type">Any</span>] <span class="keyword">const</span></code></blockquote><blockquote id="decl130" class="type"><code><span class="keyword">type</span> <span class="decl">f32</span> = <span class="type">Float[32]</span></code></blockquote><blockquote id="decl131" class="type"><code><span class="keyword">type</span> <span class="decl">f64</span> = <span class="type">Float[64]</span></code></blockquote><blockquote id="decl132" class="type"><code><span class="keyword">type</span> <span class="decl">float</span> = <span class="type">Float[64]</span></code></blockquote><blockquote id="decl133" class="type"><code><span class="keyword">type</span> <span class="decl">Float</span>[Bits <span class="type">EvalInt</span>] _</code><br/></blockquote><blockquote id="decl134"><code><span class="keyword">fn</span> <span class="type">Float[]</span> :: <span class="decl">@init</span>(x <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl135"><code><span class="keyword">fn</span> <span class="type">Float[]</span> :: <span class="decl">@init</span>(x <span class="type">int</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl136"><code><span class="keyword">fn</span> <span class="type">Float[]</span> :: <span class="decl">@init</span>(x <span class="type">%T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`%`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`**`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`*`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`+`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`-`</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`-`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`/`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`<=`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`<`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`>=`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">`>`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">abs</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Float[]</span>) <span class="decl">fmt</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl339" class="type"><code><span class="keyword">type</span> <span class="decl">FnTuple</span>[Sig <span class="type">FuncSig</span>] <span class="keyword">const</span></code></blockquote><blockquote id="decl341" class="type"><code><span class="keyword">type</span> <span class="decl">Func</span>[SIG <span class="type">Any</span>] _</code><br/>Function union. Requires a `funcptr_t` parameter. Can contain static functions or closures.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Func[]</span>) <span class="decl">@size</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl340" class="type"><code><span class="keyword">type</span> <span class="decl">funcptr_t</span>[SIG <span class="type">FuncSig</span>] _</code><br/>Function pointer.</blockquote><blockquote id="decl335" class="type"><code><span class="keyword">type</span> <span class="decl">FuncSig</span> _</code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">FuncSig</span>) <span class="decl">num_params</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">FuncSig</span>) <span class="decl">param_at</span>(i <span class="type">int</span>) -> <span class="type">meta.FuncParam</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">FuncSig</span>) <span class="decl">ret</span>() -> <span class="type">type</span></code><br /></blockquote><blockquote id="decl345" class="type"><code><span class="keyword">type</span> <span class="decl">funcsym_t</span>[SIG <span class="type">FuncSig</span>] _</code><br/></blockquote><blockquote id="decl574" class="type"><code><span class="keyword">type</span> <span class="decl">Future</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl579"><code><span class="keyword">fn</span> <span class="type">Future</span> :: <span class="decl">@init</span>(T <span class="type">type</span>) -> <span class="type">Future[T]</span></code><br /></blockquote><blockquote id="decl578"><code><span class="keyword">fn</span> <span class="type">Future</span> :: <span class="decl">complete</span>(val <span class="type">%T</span>) -> <span class="type">Future[T]</span></code><br />Returns a `Future[T]` that has a completed value.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Future[]</span>) <span class="decl">await</span>() -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl580" class="type"><code><span class="keyword">type</span> <span class="decl">FutureResolver</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl581"><code><span class="keyword">fn</span> <span class="type">FutureResolver</span> :: <span class="decl">new</span>(T <span class="type">type</span>) -> <span class="type">FutureResolver[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&FutureResolver[]</span>) <span class="decl">complete</span>(val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&FutureResolver[]</span>) <span class="decl">future</span>() -> <span class="type">Future[T]</span></code><br /></blockquote><blockquote id="decl576" class="type"><code><span class="keyword">type</span> <span class="decl">FutureValue</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl608" class="type"><code><span class="keyword">type</span> <span class="decl">Generator</span>[FnPtr <span class="type">Any</span>] <span class="keyword">struct</span></code><br/>A generator is a stackless coroutine that can `yield` values back to the dispatcher. For an isolated execution context, consider using threads.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Generator[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Generator[]</span>) <span class="decl">@size</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Generator[]</span>) <span class="decl">deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Generator[]</span>) <span class="decl">end</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Generator[]</span>) <span class="decl">next</span>() -> <span class="type">?(type.fn_ret(FnPtr))</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Generator[]</span>) <span class="decl">status</span>() -> <span class="type">GeneratorStatus</span></code><br /></blockquote><blockquote id="decl617" class="type"><code><span class="keyword">type</span> <span class="decl">GeneratorStatus</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> paused</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> running</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> done</code><br /></blockquote><blockquote id="decl532" class="type"><code><span class="keyword">type</span> <span class="decl">GenericVector</span>[T <span class="type">Any</span>] _</code><br/></blockquote><blockquote id="decl350" class="type"><code><span class="keyword">type</span> <span class="decl">HashFn</span>[T <span class="type">Any</span>] = <span class="type">fnsym(T) -> int</span></code></blockquote><blockquote id="decl374" class="type"><code><span class="keyword">type</span> <span class="decl">HashMap</span>[K <span class="type">Any</span>, V <span class="type">Any</span>, HASH <span class="type">HashFn[K]</span>, EQ <span class="type">EqFn[K]</span>] <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">NoCopy</span></code><br/>Generic hash map implemented with open addressing and linear probing.</blockquote><blockquote id="decl376"><code><span class="keyword">fn</span> <span class="type">HashMap[]</span> :: <span class="decl">@init_record</span>(pairs <span class="type">[&]Pair[K, V]</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl375"><code><span class="keyword">const</span> <span class="type">HashMap</span> :: <span class="decl">LoadFactor</span> = 75<br/></code></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">@index</span>(key <span class="type">K</span>) -> <span class="type">V</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">@set_index</span>(key <span class="type">K</span>, val <span class="type">V</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">clear</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">contains</span>(key <span class="type">K</span>) -> <span class="type">bool</span></code><br />Returns whether there is a value mapped to `key`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">findSlot</span>(key <span class="type">K</span>) -> <span class="type">int</span></code><br />Returns -1 if not found.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">get</span>(key <span class="type">K</span>) -> <span class="type">?V</span></code><br />Returns value mapped to `key` or returns `none`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">grow</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br />Iterates over the map elements.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">keys</span>() -> <span class="type">[]K</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?MapEntry[K, V]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">remove</span>(key <span class="type">K</span>) </code><br />Removes the element with the given key `key` or panic.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">resize</span>(new_cap <span class="type">int</span>) </code><br />Perform rehashing.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">set</span>(key <span class="type">K</span>, val <span class="type">V</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">size</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&HashMap[]</span>) <span class="decl">try_remove</span>(key <span class="type">K</span>) -> <span class="type">bool</span></code><br />Removes the element with the given key `key`.</blockquote><blockquote id="decl76" class="type"><code><span class="keyword">type</span> <span class="decl">i16</span> = <span class="type">Int[16]</span></code></blockquote><blockquote id="decl77" class="type"><code><span class="keyword">type</span> <span class="decl">i32</span> = <span class="type">Int[32]</span></code></blockquote><blockquote id="decl78" class="type"><code><span class="keyword">type</span> <span class="decl">i64</span> = <span class="type">Int[64]</span></code></blockquote><blockquote id="decl75" class="type"><code><span class="keyword">type</span> <span class="decl">i8</span> = <span class="type">Int[8]</span></code></blockquote><blockquote id="decl169" class="type"><code><span class="keyword">type</span> <span class="decl">Infer</span> _</code><br/></blockquote><blockquote id="decl79" class="type"><code><span class="keyword">type</span> <span class="decl">int</span> = <span class="type">Int[64]</span></code></blockquote><blockquote id="decl81" class="type"><code><span class="keyword">type</span> <span class="decl">Int</span>[Bits <span class="type">EvalInt</span>] _</code><br/>A two's complement signed integer for bit widths: 8, 16, 32, and 64.</blockquote><blockquote id="decl86"><code><span class="keyword">fn</span> <span class="type">Int[]</span> :: <span class="decl">@init</span>(x <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl87"><code><span class="keyword">fn</span> <span class="type">Int[]</span> :: <span class="decl">@init</span>(x <span class="type">%T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl89"><code><span class="keyword">fn</span> <span class="type">Int[]</span> :: <span class="decl">decode</span>(ptr <span class="type">Ptr[byte]</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl90"><code><span class="keyword">fn</span> <span class="type">Int[]</span> :: <span class="decl">decode</span>(ptr <span class="type">Ptr[byte]</span>, endian <span class="type">Endian</span>) -> <span class="type">Self</span></code><br />Returns the integer value starting from the pointer with the given endian.</blockquote><blockquote id="decl83"><code><span class="keyword">const</span> <span class="type">Int[]</span> :: <span class="decl">max</span> = @compute_int_max(Self)<br/></code></blockquote><blockquote id="decl82"><code><span class="keyword">const</span> <span class="type">Int[]</span> :: <span class="decl">min</span> = @compute_int_min(Self)<br/></code></blockquote><blockquote id="decl91"><code><span class="keyword">fn</span> <span class="type">Int[]</span> :: <span class="decl">parse</span>(s <span class="type">str</span>) -> <span class="type">!Self</span></code><br /></blockquote><blockquote id="decl85"><code><span class="keyword">const</span> <span class="type">Int[]</span> :: <span class="decl">umax</span> <span class="type">Self</span> = -1<br/></code></blockquote><blockquote id="decl84"><code><span class="keyword">const</span> <span class="type">Int[]</span> :: <span class="decl">umin</span> <span class="type">Self</span> = 0<br/></code></blockquote><blockquote id="decl88"><code><span class="keyword">fn</span> <span class="type">Int[]</span> :: <span class="decl">unsigned</span>(x <span class="type">%T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`%`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`&&`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`**`</span>(e <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`*`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`+`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`-`</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`-`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`/`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`<<`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`<=`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`<`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`>=`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`>>`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`>`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`||`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`~`</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">`~`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">asr</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">fmt</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">fmt</span>(format <span class="type">NumberFormat</span>) -> <span class="type">str</span></code><br />Formats the integer using a NumberFormat.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">udiv</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">ufmt</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">ufmt</span>(format <span class="type">NumberFormat</span>) -> <span class="type">str</span></code><br />Formats the integer (interpreted as unsigned) using a NumberFormat.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">uge</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">ugt</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">ule</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">ult</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">umod</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Int[]</span>) <span class="decl">umul</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl80" class="type"><code><span class="keyword">type</span> <span class="decl">isize</span> = <span class="type">if (meta.pointer_width() == 64) i64 else i32</span></code></blockquote><blockquote id="decl346" class="type"><code><span class="keyword">type</span> <span class="decl">LessFn</span>[T <span class="type">Any</span>] = <span class="type">fn(T, T) -> bool</span></code></blockquote><blockquote id="decl360" class="type"><code><span class="keyword">type</span> <span class="decl">Map</span>[K <span class="type">Any</span>, V <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl361"><code><span class="keyword">fn</span> <span class="type">Map[]</span> :: <span class="decl">@init_record</span>(pairs <span class="type">[&]Pair[K, V]</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">@index</span>(key <span class="type">K</span>) -> <span class="type">V</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">@set_index</span>(key <span class="type">K</span>, val <span class="type">V</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">clear</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">contains</span>(key <span class="type">K</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">get</span>(key <span class="type">K</span>) -> <span class="type">?V</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">keys</span>() -> <span class="type">[]K</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?MapEntry[K, V]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">remove</span>(key <span class="type">K</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">set</span>(key <span class="type">K</span>, val <span class="type">V</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">size</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Map[]</span>) <span class="decl">try_remove</span>(key <span class="type">K</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl435" class="type"><code><span class="keyword">type</span> <span class="decl">MapEntry</span>[K <span class="type">Any</span>, V <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl29" class="type"><code><span class="keyword">type</span> <span class="decl">never</span> _</code><br/></blockquote><blockquote id="decl182" class="type"><code><span class="keyword">type</span> <span class="decl">NoCopy</span> <span class="keyword">trait</span></code><br/>Describes a type that forbids implicit copying disregarding whether the type is implicitly `Copyable`.</blockquote><blockquote id="decl129" class="type"><code><span class="keyword">type</span> <span class="decl">NumberFormat</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> ch</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bin</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dec</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> hex</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> oct</code><br /></blockquote><blockquote id="decl45" class="type"><code><span class="keyword">type</span> <span class="decl">NumberFormatConfig</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl159" class="type"><code><span class="keyword">type</span> <span class="decl">Object</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl160"><code><span class="keyword">fn</span> <span class="type">Object</span> :: <span class="decl">@init</span>(ref <span class="type">^%T</span>) -> <span class="type">Object</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Object</span>) <span class="decl">@copy</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Object</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Object</span>) <span class="decl">downcast</span>(Ref <span class="type">type</span>) -> <span class="type">Ref</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Object</span>) <span class="decl">toString</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Object</span>) <span class="decl">type</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl343" class="type"><code><span class="keyword">type</span> <span class="decl">OpaqueFunc</span>[SIG <span class="type">Any</span>] _</code><br/>Opaque function union. Cannot be moved or copied. These constraints allow it to contain a pinned closure which can capture locals as well as references. A `Func` can be implicitly converted to an `OpaqueFunc`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">OpaqueFunc[]</span>) <span class="decl">@size</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl570" class="type"><code><span class="keyword">type</span> <span class="decl">Option</span>[T <span class="type">Any</span>] _</code><br/></blockquote><blockquote id="decl571"><code><span class="keyword">fn</span> <span class="type">Option[]</span> :: <span class="decl">@init</span>(x <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl348" class="type"><code><span class="keyword">type</span> <span class="decl">Pair</span>[K <span class="type">Any</span>, V <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl171" class="type"><code><span class="keyword">type</span> <span class="decl">PartialStructLayout</span> = <span class="type">meta.PartialStructLayout</span></code></blockquote><blockquote id="decl533" class="type"><code><span class="keyword">type</span> <span class="decl">PartialVector</span>[T <span class="type">Any</span>, N <span class="type">int</span>] _</code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &PartialVector[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">&T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PartialVector[]</span>) <span class="decl">`<<`</span>(x <span class="type">T</span>) </code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PartialVector[]</span>) <span class="decl">append</span>(x <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PartialVector[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br />Returns the number of elements in the partial array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PartialVector[]</span>) <span class="decl">setLength</span>(len <span class="type">int</span>) </code><br /></blockquote><blockquote id="decl553" class="type"><code><span class="keyword">type</span> <span class="decl">Ptr</span>[T <span class="type">Any</span>] _</code><br/>Unsafe pointer type. NOTE: Should not have any regular methods because they could shadow child methods.</blockquote><blockquote id="decl554"><code><span class="keyword">fn</span> <span class="type">Ptr[]</span> :: <span class="decl">@init</span>(x <span class="type">%T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Ptr[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="type">Ptr[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Ptr[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>, end <span class="type">int</span>) -> <span class="type">PtrSpan[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Ptr[]</span>) <span class="decl">`+`</span>(offset <span class="type">int</span>) -> <span class="type">Ptr[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Ptr[]</span>) <span class="decl">`-`</span>(right <span class="type">Self</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Ptr[]</span>) <span class="decl">`<`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl587" class="type"><code><span class="keyword">type</span> <span class="decl">PtrSpan</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">AsSpan[T]</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="type">Ptr[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">@set_index</span>(idx <span class="type">int</span>, val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>) -> <span class="type">PtrSpan[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>, end <span class="type">int</span>) -> <span class="type">PtrSpan[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">ends_with</span>(suffix <span class="type">PtrSpan[T]</span>) -> <span class="type">bool</span></code><br />Returns whether the array ends with `suffix`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">index</span>(needle <span class="type">T</span>) -> <span class="type">?int</span></code><br />Returns the first index of `needle` in the slice or `none` if not found.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">init</span>(o <span class="type">Self</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">init</span>(val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">set</span>(o <span class="type">Self</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">set</span>(val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">set_backwards</span>(o <span class="type">Self</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">span</span>() -> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">starts_with</span>(target <span class="type">PtrSpan[T]</span>) -> <span class="type">bool</span></code><br />Returns whether the `PtrSpan` starts with `target`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&PtrSpan[]</span>) <span class="decl">toBytes</span>() -> <span class="type">PtrSpan[byte]</span></code><br /></blockquote><blockquote id="decl48" class="type"><code><span class="keyword">type</span> <span class="decl">r16</span> = <span class="type">Raw[16]</span></code></blockquote><blockquote id="decl49" class="type"><code><span class="keyword">type</span> <span class="decl">r32</span> = <span class="type">Raw[32]</span></code></blockquote><blockquote id="decl50" class="type"><code><span class="keyword">type</span> <span class="decl">r64</span> = <span class="type">Raw[64]</span></code></blockquote><blockquote id="decl47" class="type"><code><span class="keyword">type</span> <span class="decl">r8</span> = <span class="type">Raw[8]</span></code></blockquote><blockquote id="decl562" class="type"><code><span class="keyword">type</span> <span class="decl">Range</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl52" class="type"><code><span class="keyword">type</span> <span class="decl">Raw</span>[Bits <span class="type">EvalInt</span>] _</code><br/>Represents a raw integer value with bits of widths 8, 16, 32, or 64.</blockquote><blockquote id="decl55"><code><span class="keyword">fn</span> <span class="type">Raw[]</span> :: <span class="decl">@init</span>(x <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl56"><code><span class="keyword">fn</span> <span class="type">Raw[]</span> :: <span class="decl">@init</span>(x <span class="type">%T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl54"><code><span class="keyword">const</span> <span class="type">Raw[]</span> :: <span class="decl">ones</span> <span class="type">Self</span> = ~0<br/></code></blockquote><blockquote id="decl53"><code><span class="keyword">const</span> <span class="type">Raw[]</span> :: <span class="decl">zero</span> <span class="type">Self</span> = 0<br/></code></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`%`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`&&`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`*`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`+`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`-`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`/`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`<<`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`<=`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`<`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`>=`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`>>`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`>`</span>(right <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`||`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`~`</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">`~`</span>(right <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">fmt</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Raw[]</span>) <span class="decl">fmt</span>(format <span class="type">NumberFormat</span>) -> <span class="type">str</span></code><br />Formats the integer (interpreted as unsigned) using a NumberFormat.</blockquote><blockquote id="decl173" class="type"><code><span class="keyword">type</span> <span class="decl">RawBuffer</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/>Can only be created as an object. Unsafe because elements are not guaranteed to be initialized.</blockquote><blockquote id="decl174"><code><span class="keyword">fn</span> <span class="type">RawBuffer[]</span> :: <span class="decl">@init</span>(nelems <span class="type">int</span>) -> <span class="type">^Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&RawBuffer[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&RawBuffer[]</span>) <span class="decl">@size</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&RawBuffer[]</span>) <span class="decl">elems</span>() -> <span class="type">PtrSpan[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&RawBuffer[]</span>) <span class="decl">elems_ptr</span>() -> <span class="type">Ptr[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&RawBuffer[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl584" class="type"><code><span class="keyword">type</span> <span class="decl">Ref</span>[T <span class="type">Any</span>] _</code><br/></blockquote><blockquote id="decl349" class="type"><code><span class="keyword">type</span> <span class="decl">RefChild</span>[P <span class="type">Any</span>, T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl564" class="type"><code><span class="keyword">type</span> <span class="decl">Result</span>[T <span class="type">Any</span>] _</code><br/></blockquote><blockquote id="decl565"><code><span class="keyword">fn</span> <span class="type">Result[]</span> :: <span class="decl">@init</span>(x <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Result[]</span>) <span class="decl">unwrap</span>() -> <span class="type">T</span></code><br />Returns the Result's successful value case or panics.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Result[]</span>) <span class="decl">unwrap_error</span>() -> <span class="type">error</span></code><br />Returns the Result's error case or panics.</blockquote><blockquote id="decl51" class="type"><code><span class="keyword">type</span> <span class="decl">rsize</span> = <span class="type">if (meta.pointer_width() == 64) r64 else r32</span></code></blockquote><blockquote id="decl191" class="type"><code><span class="keyword">type</span> <span class="decl">RtBorrow</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&RtBorrow[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote id="decl189" class="type"><code><span class="keyword">type</span> <span class="decl">RtExBorrow</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&RtExBorrow[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote id="decl219" class="type"><code><span class="keyword">type</span> <span class="decl">Slice</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">AsSpan[T]</span></code><br/>A dynamically sized data structure that contains a sequence of elements. Two copies initially point to the same element buffer and allow read/write to the elements. However, any resize operation on a slice that is shared results in a clone of the underlying buffer. Any resize operation on a sub-slice clones the underlying buffer regardless if it's shared.</blockquote><blockquote id="decl222"><code><span class="keyword">fn</span> <span class="type">Slice[]</span> :: <span class="decl">@init</span>(n <span class="type">int</span>, val <span class="type">T</span>) -> <span class="type">Self</span></code><br />Creates a `Slice` with initial length and capacity of `n` and values set to `val`.</blockquote><blockquote id="decl220"><code><span class="keyword">fn</span> <span class="type">Slice[]</span> :: <span class="decl">@init_sequence</span>(init <span class="type">[&]T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">@index</span>(idx <span class="type">int</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Slice[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">&T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">@set_index</span>(idx <span class="type">int</span>, val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">@slice</span>() -> <span class="type">[]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>) -> <span class="type">[]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>, end <span class="type">int</span>) -> <span class="type">[]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">`<<`</span>(val <span class="type">T</span>) -> <span class="type">Self</span></code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">`<<`</span>(slice <span class="type">[&]T</span>) -> <span class="type">Self</span></code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">`<<`</span>(arr <span class="type">AsSpan[T]</span>) -> <span class="type">Self</span></code><br />Alias for `append`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">append</span>(val <span class="type">T</span>) -> <span class="type">Self</span></code><br />Appends a value to the end of the `Slice`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">append</span>(span <span class="type">[&]T</span>) -> <span class="type">Self</span></code><br />Appends the elements of a `Span` to the end of this `Slice`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">append</span>(arr <span class="type">AsSpan[T]</span>) -> <span class="type">Self</span></code><br />Appends the elements of a `AsSpan` to the end of this array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">as_ptr_span</span>() -> <span class="type">PtrSpan[byte]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">clear</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">clone_on_resize</span>(new_cap <span class="type">int</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">contains</span>(needle <span class="type">T</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">index</span>(needle <span class="type">T</span>) -> <span class="type">?int</span></code><br />Returns the first index of `needle` in the array or `none` if not found.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">insert</span>(idx <span class="type">int</span>, val <span class="type">T</span>) -> <span class="type">Self</span></code><br />Inserts a value at index `idx`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br />Returns a new iterator over the slice elements.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">join</span>(sep <span class="type">str</span>) -> <span class="type">str</span></code><br />Returns a new string that joins the elements with `separator`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">last</span>() -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">remove</span>(idx <span class="type">int</span>) -> <span class="type">Self</span></code><br />Removes an element at index `idx`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">set</span>(o <span class="type">Self</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">set_last</span>(val <span class="type">T</span>) -> <span class="type">void</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">size_down</span>(new_len <span class="type">int</span>) -> <span class="type">Self</span></code><br />Decreases the size of the `Slice` to `new_len` elements. If the new size is smaller, elements at the end of the `Slice` are removed.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">size_up</span>(new_len <span class="type">int</span>, init <span class="type">T</span>) -> <span class="type">Self</span></code><br />Increases the size of the `Slice` to `new_len` elements. If the new size is bigger, `init` values are appended to the `Slice`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Slice[]</span>) <span class="decl">sort</span>(less <span class="type">&OpaqueFunc[LessFn[T]]</span>) </code><br />Sorts the array with the given `less` function. If element `a` should be ordered before `b`, the function should return `true` otherwise `false`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Slice[]</span>) <span class="decl">span</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote id="decl258" class="type"><code><span class="keyword">type</span> <span class="decl">Span</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">AsSpan[T]</span></code><br/>A `Span` is a borrowed view over a sequence of elements. It can also be denoted as `[&]T` where `T` is the element type.</blockquote><blockquote id="decl259"><code><span class="keyword">fn</span> <span class="type">Span[]</span> :: <span class="decl">@init_sequence</span>(<span class="keyword">scope</span> span <span class="type">[&]T</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="type">Ptr[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Span[]</span>) <span class="decl">@slice</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Span[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Span[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>, end <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">`==`</span>(o <span class="type">Self</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Span[]</span>) <span class="decl">as_bytes</span>() -> <span class="keyword">scope</span> <span class="type">[&]byte</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">contains</span>(needle <span class="type">T</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">ends_with</span>(target <span class="type">Self</span>) -> <span class="type">bool</span></code><br />Returns whether the `Span` ends with `target`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">index</span>(needle <span class="type">T</span>) -> <span class="type">?int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">init</span>(o <span class="type">Self</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">init</span>(val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">set</span>(o <span class="type">Self</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">set</span>(val <span class="type">T</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">sort</span>(less <span class="type">&OpaqueFunc[LessFn[T]]</span>) </code><br />Sorts the span with the given `less` function. If element `a` should be ordered before `b`, the function should return `true` otherwise `false`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Span[]</span>) <span class="decl">span</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Span[]</span>) <span class="decl">starts_with</span>(target <span class="type">Self</span>) -> <span class="type">bool</span></code><br />Returns whether the `Span` starts with `target`.</blockquote><blockquote id="decl352" class="type"><code><span class="keyword">type</span> <span class="decl">StaticMap</span>[K <span class="type">type</span>, V <span class="type">type</span>, HASH <span class="type">HashFn[K]</span>, EQ <span class="type">EqFn[K]</span>] <span class="keyword">struct</span></code><br/>NOTE: Unused, may be redesigned or removed. A precomputed hash map from an initial set of entries. Insertions and deletions are not allowed. Implemented with open addressing and linear probing.</blockquote><blockquote id="decl359" class="type"><code><span class="keyword">type</span> <span class="type">StaticMap</span> :: <span class="decl">Auto</span> = <span class="type">StaticMap[K, V, AutoHash[K], AutoEq[K]]</span></code></blockquote><blockquote id="decl353"><code><span class="keyword">fn</span> <span class="type">StaticMap[]</span> :: <span class="decl">init</span>(pairs <span class="type">[]Pair[K, V]</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl354"><code><span class="keyword">fn</span> <span class="type">StaticMap[]</span> :: <span class="decl">init</span>(nslots <span class="type">int</span>, pairs <span class="type">[]Pair[K, V]</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&StaticMap[]</span>) <span class="decl">@index</span>(key <span class="type">K</span>) -> <span class="type">Ptr[V]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&StaticMap[]</span>) <span class="decl">get</span>(key <span class="type">K</span>) -> <span class="type">?Ptr[V]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&StaticMap[]</span>) <span class="decl">is_vacant</span>(slot <span class="type">int</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&StaticMap[]</span>) <span class="decl">set</span>(key <span class="type">K</span>, val <span class="type">V</span>) </code><br /></blockquote><blockquote id="decl458" class="type"><code><span class="keyword">type</span> <span class="decl">Str</span> <span class="keyword">struct</span></code><br/>TODO: Mutable string type.</blockquote><blockquote id="decl459" class="type"><code><span class="keyword">type</span> <span class="decl">str</span> <span class="keyword">struct</span></code><br/>Immutable string type. Short strings are interned.</blockquote><blockquote id="decl460"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">@init</span>(slice <span class="type">[]byte</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl461"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">@init</span>(span <span class="type">[&]byte</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl462"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">@init</span>(span <span class="type">PtrSpan[byte]</span>) -> <span class="type">str</span></code><br />Returns a `str` copied from the byte slice.</blockquote><blockquote id="decl463"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">@init</span>(x <span class="type">%T</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl471"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">ascii_lower</span>(ch <span class="type">byte</span>) -> <span class="type">byte</span></code><br /></blockquote><blockquote id="decl472"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">ascii_upper</span>(ch <span class="type">byte</span>) -> <span class="type">byte</span></code><br /></blockquote><blockquote id="decl464"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">initRune</span>(val <span class="type">int</span>) -> <span class="type">str</span></code><br />Converts a rune to a string.</blockquote><blockquote id="decl465"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">initz</span>(src <span class="type">str</span>) -> <span class="type">str</span></code><br />Reallocates with zero sentinel for C compatibility. The sentinel does not count as a character in the string.</blockquote><blockquote id="decl466"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">interpolate</span>(strs <span class="type">[&]str</span>, args <span class="type">[&]str</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl467"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">is_ascii_alpha</span>(ch <span class="type">byte</span>) -> <span class="type">bool</span></code><br />Returns whether a byte is an ASCII alphabetic letter.</blockquote><blockquote id="decl468"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">is_ascii_digit</span>(ch <span class="type">byte</span>) -> <span class="type">bool</span></code><br />Returns whether a byte is an ASCII digit.</blockquote><blockquote id="decl469"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">is_ascii_lower</span>(ch <span class="type">byte</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl470"><code><span class="keyword">fn</span> <span class="type">str</span> :: <span class="decl">is_ascii_upper</span>(ch <span class="type">byte</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">@index</span>(idx <span class="type">int</span>) -> <span class="type">byte</span></code><br />Returns the byte value (0-255) at the given index `idx`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">@send</span>(thread <span class="type">Thread</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">@slice</span>(start <span class="type">int</span>) -> <span class="type">str</span></code><br />Returns a substring from `start` (inclusive) to `end` (exclusive) byte indexes.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">@slice</span>(start <span class="type">int</span>, end <span class="type">int</span>) -> <span class="type">str</span></code><br />Returns a substring from `start` (inclusive) to `end` (exclusive) byte indexes.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">`**`</span>(n <span class="type">int</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">`+`</span>(s <span class="type">str</span>) -> <span class="type">str</span></code><br />Returns a new string that concats this string and `s`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">as_ptr_span</span>() -> <span class="type">PtrSpan[byte]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">beforeLast</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">str</span>) <span class="decl">compare</span>(right <span class="type">str</span>) -> <span class="type">CompareOrder</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">concat</span>(s <span class="type">str</span>) -> <span class="type">str</span></code><br />Returns a new string that concats this string and `s`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">contains</span>(needle <span class="type">str</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">count</span>() -> <span class="type">int</span></code><br />Returns the number of runes in the string.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">ends_with</span>(suffix <span class="type">str</span>) -> <span class="type">bool</span></code><br />Returns whether the string ends with `suffix`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">fmt</span>(args <span class="type">%T</span>) -> <span class="type">str</span></code><br />Replaces each placeholder `{}` from the receiver string with the corresponding value in `args` converted to a string. TODO: This should accept tuple instead of []Object.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">fmt</span>(placeholder <span class="type">str</span>, args <span class="type">%T</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">fmtBytes</span>(format <span class="type">NumberFormat</span>) -> <span class="type">str</span></code><br />Formats each byte in the string using a NumberFormat. Each byte is zero padded.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">hasAsciiFlag</span>() -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">i32At</span>(idx <span class="type">int</span>) -> <span class="type">i32</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">i32At</span>(idx <span class="type">int</span>, endian <span class="type">Endian</span>) -> <span class="type">i32</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">index</span>(needle <span class="type">str</span>) -> <span class="type">?int</span></code><br />Returns the first byte index of substring `needle` in the string or `none` if not found. SIMD accelerated.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">index</span>(b <span class="type">byte</span>) -> <span class="type">?int</span></code><br />Returns the first index of `byte` in the array or `none` if not found.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">index_any</span>(set <span class="type">[&]byte</span>) -> <span class="type">?int</span></code><br />Returns the first index of any byte in `set` or `none` if not found.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">index_any</span>(set <span class="type">AsSpan[byte]</span>) -> <span class="type">?int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">index_any_rune</span>(runes <span class="type">[&]int</span>) -> <span class="type">?int</span></code><br />Returns the first byte index of any rune in `runes` or `none` if not found. SIMD accelerated.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">index_any_rune</span>(runes <span class="type">AsSpan[int]</span>) -> <span class="type">?int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">index_newline</span>() -> <span class="type">?int</span></code><br />Returns the first byte index of `\n` or `\r` or `none`. SIMD accelerated.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">index_rune</span>(needle <span class="type">int</span>) -> <span class="type">?int</span></code><br />Returns the first byte index of a rune `needle` in the string or `none` if not found. SIMD accelerated.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">insert</span>(idx <span class="type">int</span>, s <span class="type">str</span>) -> <span class="type">str</span></code><br />Returns a new string with `str` inserted at byte index `idx`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">insert</span>(idx <span class="type">int</span>, b <span class="type">byte</span>) -> <span class="type">str</span></code><br />Returns a new array with `byte` inserted at index `idx`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">intAt</span>(idx <span class="type">int</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">intAt</span>(idx <span class="type">int</span>, endian <span class="type">Endian</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">isAscii</span>() -> <span class="type">bool</span></code><br />Returns whether the string contains all ASCII runes. Every time this function is called a full scan is performed.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">last</span>() -> <span class="type">byte</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">lastIndexOf</span>(needle <span class="type">str</span>) -> <span class="type">?int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br />Returns the byte length of the string. See `count()` to obtain the number of runes.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">str</span>) <span class="decl">less</span>(other <span class="type">str</span>) -> <span class="type">bool</span></code><br />Returns whether this string is lexicographically before `other`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">lower</span>() -> <span class="type">str</span></code><br />Returns this string in lowercase.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?byte</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">repeat</span>(n <span class="type">int</span>) -> <span class="type">str</span></code><br />Returns a new string with this string repeated `n` times.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">replace</span>(needle <span class="type">str</span>, replacement <span class="type">str</span>) -> <span class="type">str</span></code><br />Returns a new string with all occurrences of `needle` replaced with `replacement`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">rune_at</span>(idx <span class="type">int</span>) -> <span class="type">r32</span></code><br />Returns the rune at byte index `idx`. The replacement character (0xFFFD) is returned for an invalid UTF-8 rune.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">runeStrAt</span>(idx <span class="type">int</span>) -> <span class="type">str</span></code><br />Returns the UTF-8 rune starting at byte index `idx` as a string.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">seek</span>(n <span class="type">int</span>) -> <span class="type">r32</span></code><br />Returns the n'th rune.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">seek_pos</span>(n <span class="type">int</span>) -> <span class="type">int</span></code><br />Returns the starting byte index for the n'th rune.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">set</span>(idx <span class="type">int</span>, x <span class="type">byte</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">split</span>(sep <span class="type">str</span>) -> <span class="type">[]str</span></code><br />Returns a list of UTF-8 strings split at occurrences of `sep`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">starts_with</span>(prefix <span class="type">str</span>) -> <span class="type">bool</span></code><br />Returns whether the `str` starts with `prefix`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">to_bytes</span>() -> <span class="type">[]byte</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">trim</span>(delim <span class="type">str</span>) -> <span class="type">str</span></code><br />Returns the string with both ends trimmed.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">trim</span>(delims <span class="type">AsSpan[str]</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">trimLeft</span>(delim <span class="type">str</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">trimLeft</span>(delims <span class="type">AsSpan[str]</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">trimRight</span>(delim <span class="type">str</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">trimRight</span>(delims <span class="type">AsSpan[str]</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&str</span>) <span class="decl">upper</span>() -> <span class="type">str</span></code><br />Returns this string in uppercase.</blockquote><blockquote id="decl456" class="type"><code><span class="keyword">type</span> <span class="decl">StrBuffer</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&StrBuffer</span>) <span class="decl">@size</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl35" class="type"><code><span class="keyword">type</span> <span class="decl">symbol</span> _</code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">symbol</span>) <span class="decl">name</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl606" class="type"><code><span class="keyword">type</span> <span class="decl">SystemKind</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> linux</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> macos</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> windows</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> freestanding</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> wasi</code><br /></blockquote><blockquote id="decl347" class="type"><code><span class="keyword">type</span> <span class="decl">Table</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl166" class="type"><code><span class="keyword">type</span> <span class="decl">TaskCallback</span> = <span class="type">fn() -> void</span></code></blockquote><blockquote id="decl563" class="type"><code><span class="keyword">type</span> <span class="decl">TccState</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl621" class="type"><code><span class="keyword">type</span> <span class="decl">Thread</span> _</code><br/>Handle to a thread. Should only be used internally and in `@send` implementations.</blockquote><blockquote id="decl421" class="type"><code><span class="keyword">type</span> <span class="decl">TraitStruct</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl170" class="type"><code><span class="keyword">type</span> <span class="decl">type</span> = <span class="type">meta.type</span></code></blockquote><blockquote id="decl607" class="type"><code><span class="keyword">type</span> <span class="decl">VaList</span>[T <span class="type">Any</span>] _</code><br/></blockquote><blockquote id="decl539" class="type"><code><span class="keyword">type</span> <span class="decl">Vector</span>[T <span class="type">Any</span>, N <span class="type">int</span>] _</code><br/></blockquote><blockquote id="decl540"><code><span class="keyword">fn</span> <span class="type">Vector[]</span> :: <span class="decl">@init</span>(elem <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Vector[]</span>) <span class="decl">@copy</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Vector[]</span>) <span class="decl">@index_addr</span>(idx <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">&T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Vector[]</span>) <span class="decl">@slice</span>() -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Vector[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type"><span class="keyword">scope</span> &Vector[]</span>) <span class="decl">@slice</span>(start <span class="type">int</span>, end <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">[&]T</span></code><br />Returns a slice of this vector from `start` (inclusive) to `end` (exclusive) indexes.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Vector[]</span>) <span class="decl">`**`</span>(M <span class="type">int</span>) -> <span class="type">Vector[T, N * M]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Vector[]</span>) <span class="decl">`+`</span>(o <span class="type">Vector[T, %M]</span>) -> <span class="type">Vector[T, N + M]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Vector[]</span>) <span class="decl">as_ptr_span</span>() -> <span class="type">PtrSpan[T]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Vector[]</span>) <span class="decl">ct_repeat</span>(M <span class="type">int</span>) -> <span class="type">Vector[T, N * M]</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Vector[]</span>) <span class="decl">iterator</span>() -> <span class="type">int</span></code><br />Returns a new iterator over the array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Vector[]</span>) <span class="decl">len</span>() -> <span class="type">int</span></code><br />Returns the number of elements in the array.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Vector[]</span>) <span class="decl">next</span>(idx <span class="type">&int</span>) -> <span class="type">?T</span></code><br /></blockquote><blockquote id="decl28" class="type"><code><span class="keyword">type</span> <span class="decl">void</span> _</code><br/></blockquote><blockquote id="decl439" class="type"><code><span class="keyword">type</span> <span class="decl">Wyhash</span> <span class="keyword">struct</span></code><br/>Wyhash implementation ported from Zig's std.</blockquote><blockquote id="decl441"><code><span class="keyword">fn</span> <span class="type">Wyhash</span> :: <span class="decl">@init</span>(seed <span class="type">int</span>) -> <span class="type">Wyhash</span></code><br /></blockquote><blockquote id="decl442"><code><span class="keyword">fn</span> <span class="type">Wyhash</span> :: <span class="decl">hash</span>(seed <span class="type">int</span>, input <span class="type">AsSpan[byte]</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl450"><code><span class="keyword">fn</span> <span class="type">Wyhash</span> :: <span class="decl">mix</span>(a <span class="type">int</span>, b <span class="type">int</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl449"><code><span class="keyword">fn</span> <span class="type">Wyhash</span> :: <span class="decl">mum</span>(a <span class="type">Ptr[int]</span>, b <span class="type">Ptr[int]</span>) </code><br />32-bit mum</blockquote><blockquote id="decl452"><code><span class="keyword">fn</span> <span class="type">Wyhash</span> :: <span class="decl">readI32</span>(ptr <span class="type">Ptr[byte]</span>) -> <span class="type">i32</span></code><br /></blockquote><blockquote id="decl451"><code><span class="keyword">fn</span> <span class="type">Wyhash</span> :: <span class="decl">readInt</span>(ptr <span class="type">Ptr[byte]</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl448"><code><span class="keyword">fn</span> <span class="type">Wyhash</span> :: <span class="decl">rot</span>(x <span class="type">int</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl440"><code><span class="keyword">global</span> <span class="type">Wyhash</span> :: <span class="decl">secret</span> <span class="type">[4]int</span> = {
    0xa0761d6478bd642f,
    0xe7037ed1a0b428db,
    0x8ebc6af09c88c6e3,
    0x589965cc75374cc3,
}<br/></code></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Wyhash</span>) <span class="decl">final</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Wyhash</span>) <span class="decl">final0</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Wyhash</span>) <span class="decl">final1</span>(input_lb <span class="type">[&]byte</span>, start_pos <span class="type">int</span>) </code><br />input_lb must be at least 16-bytes long (in shorter key cases the smallKey function will be used instead). We use an index into a slice to for comptime processing as opposed to if we used pointers.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Wyhash</span>) <span class="decl">final2</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Wyhash</span>) <span class="decl">round</span>(input <span class="type">Ptr[byte]</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Wyhash</span>) <span class="decl">shallowCopy</span>() -> <span class="type">Self</span></code><br />Copies the core wyhash state but not any internal buffers.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Wyhash</span>) <span class="decl">smallKey</span>(input <span class="type">[&]byte</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Wyhash</span>) <span class="decl">update</span>(input <span class="type">[&]byte</span>) </code><br />This is subtly different from other hash function update calls. Wyhash requires the last full 48-byte block to be run through final1 if is exactly aligned to 48-bytes.</blockquote><h1 id="c"><code><span class="keyword">mod</span> <span class="decl">c</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl628"><span class="keyword">fn</span> @initBindLib</a></code></div><div><code><a href="#decl629"><span class="keyword">fn</span> bind_lib</a></code></div><div><code><a href="#decl630"><span class="keyword">fn</span> flag</a></code></div><div><code><a href="#decl631"><span class="keyword">fn</span> from_strz</a></code></div><div><code><a href="#decl632"><span class="keyword">fn</span> include</a></code></div></div><div><div><code><a href="#decl633"><span class="keyword">fn</span> to_strz</a></code></div><div><code><a href="#decl636"><span class="keyword">type</span> c_char =</a></code></div><div><code><a href="#decl639"><span class="keyword">type</span> c_int =</a></code></div><div><code><a href="#decl641"><span class="keyword">type</span> c_long =</a></code></div><div><code><a href="#decl643"><span class="keyword">type</span> c_longlong =</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl637"><span class="keyword">type</span> c_short =</a></code></div><div><code><a href="#decl640"><span class="keyword">type</span> c_uint =</a></code></div><div><code><a href="#decl642"><span class="keyword">type</span> c_ulong =</a></code></div><div><code><a href="#decl644"><span class="keyword">type</span> c_ulonglong =</a></code></div><div><code><a href="#decl638"><span class="keyword">type</span> c_ushort =</a></code></div></div><div><div><div><code><a href="#decl634"><span class="keyword">type</span> size_t =</a></code></div><div><code><a href="#decl635"><span class="keyword">type</span> ssize_t =</a></code></div><div><code><a href="#decl645"><span class="keyword">type</span> variadic</a></code></div></div></div></td></tr></tbody></table><blockquote id="decl628"><code><span class="keyword">fn</span> <span class="decl">@initBindLib</span>() -> <span class="type">void</span></code><br />Invoked by the program's initializer to start binding libs to `extern` declarations.</blockquote><blockquote id="decl629"><code><span class="keyword">fn</span> <span class="decl">bind_lib</span>(path <span class="type">?EvalStr</span>) </code><br />Declares that the extern declarations in the current source file is to be binded at runtime to a dynamic library. When `path == none`, the symbols will be searched from the host exe.</blockquote><blockquote id="decl630"><code><span class="keyword">fn</span> <span class="decl">flag</span>(s <span class="type">EvalStr</span>) -> <span class="type">void</span></code><br /></blockquote><blockquote id="decl631"><code><span class="keyword">fn</span> <span class="decl">from_strz</span>(ptr <span class="type">Ptr[byte]</span>) -> <span class="type">str</span></code><br />Returns a `str` from a null terminated C string.</blockquote><blockquote id="decl632"><code><span class="keyword">fn</span> <span class="decl">include</span>(spec <span class="type">EvalStr</span>) -> <span class="type">void</span></code><br /></blockquote><blockquote id="decl633"><code><span class="keyword">fn</span> <span class="decl">to_strz</span>(s <span class="type">str</span>) -> <span class="type">Ptr[byte]</span></code><br />Returns an allocated null terminated C string.</blockquote><blockquote id="decl636" class="type"><code><span class="keyword">type</span> <span class="decl">c_char</span> = <span class="type">byte</span></code></blockquote><blockquote id="decl639" class="type"><code><span class="keyword">type</span> <span class="decl">c_int</span> = <span class="type">i32</span></code></blockquote><blockquote id="decl641" class="type"><code><span class="keyword">type</span> <span class="decl">c_long</span> = <span class="type">i64</span></code></blockquote><blockquote id="decl643" class="type"><code><span class="keyword">type</span> <span class="decl">c_longlong</span> = <span class="type">i64</span></code></blockquote><blockquote id="decl637" class="type"><code><span class="keyword">type</span> <span class="decl">c_short</span> = <span class="type">i16</span></code></blockquote><blockquote id="decl640" class="type"><code><span class="keyword">type</span> <span class="decl">c_uint</span> = <span class="type">r32</span></code></blockquote><blockquote id="decl642" class="type"><code><span class="keyword">type</span> <span class="decl">c_ulong</span> = <span class="type">r64</span></code></blockquote><blockquote id="decl644" class="type"><code><span class="keyword">type</span> <span class="decl">c_ulonglong</span> = <span class="type">r64</span></code></blockquote><blockquote id="decl638" class="type"><code><span class="keyword">type</span> <span class="decl">c_ushort</span> = <span class="type">r16</span></code></blockquote><blockquote id="decl634" class="type"><code><span class="keyword">type</span> <span class="decl">size_t</span> = <span class="type">r64</span></code></blockquote><blockquote id="decl635" class="type"><code><span class="keyword">type</span> <span class="decl">ssize_t</span> = <span class="type">i64</span></code></blockquote><blockquote id="decl645" class="type"><code><span class="keyword">type</span> <span class="decl">variadic</span> _</code><br/></blockquote><h1 id="cy"><code><span class="keyword">mod</span> <span class="decl">cy</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl648"><span class="keyword">const</span> Await</a></code></div><div><code><a href="#decl649"><span class="keyword">const</span> ErrorCompile</a></code></div><div><code><a href="#decl650"><span class="keyword">const</span> ErrorPanic</a></code></div><div><code><a href="#decl647"><span class="keyword">const</span> Success</a></code></div><div><code><a href="#decl652"><span class="keyword">const</span> TypeBool</a></code></div><div><code><a href="#decl655"><span class="keyword">const</span> TypeF64</a></code></div><div><code><a href="#decl656"><span class="keyword">const</span> TypeFloat</a></code></div><div><code><a href="#decl653"><span class="keyword">const</span> TypeI64</a></code></div><div><code><a href="#decl654"><span class="keyword">const</span> TypeInt</a></code></div><div><code><a href="#decl657"><span class="keyword">const</span> TypeStr</a></code></div><div><code><a href="#decl651"><span class="keyword">const</span> TypeVoid</a></code></div><div><code><a href="#decl743"><span class="keyword">fn</span> _new_parser</a></code></div><div><code><a href="#decl738"><span class="keyword">fn</span> _parser_comments</a></code></div><div><code><a href="#decl744"><span class="keyword">fn</span> destroy_parser</a></code></div><div><code><a href="#decl658"><span class="keyword">fn</span> eval</a></code></div><div><code><a href="#decl729"><span class="keyword">fn</span> from_znode</a></code></div><div><code><a href="#decl731"><span class="keyword">fn</span> from_znode_auto</a></code></div><div><code><a href="#decl728"><span class="keyword">fn</span> from_znodes</a></code></div><div><code><a href="#decl662"><span class="keyword">fn</span> is_adjacent_stmt</a></code></div><div><code><a href="#decl742"><span class="keyword">fn</span> new_parser</a></code></div><div><code><a href="#decl735"><span class="keyword">fn</span> parse</a></code></div><div><code><a href="#decl737"><span class="keyword">fn</span> parser_comments</a></code></div><div><code><a href="#decl745"><span class="keyword">fn</span> repl</a></code></div><div><code><a href="#decl706"><span class="keyword">type</span> AccessExpr</a></code></div><div><code><a href="#decl675"><span class="keyword">type</span> AsExpr</a></code></div></div><div><div><code><a href="#decl679"><span class="keyword">type</span> Attribute</a></code></div><div><code><a href="#decl678"><span class="keyword">type</span> AttributeKind</a></code></div><div><code><a href="#decl746"><span class="keyword">type</span> Backend</a></code></div><div><code><a href="#decl683"><span class="keyword">type</span> BinaryExprOp</a></code></div><div><code><a href="#decl682"><span class="keyword">type</span> BinExpr</a></code></div><div><code><a href="#decl716"><span class="keyword">type</span> BorrowExpr</a></code></div><div><code><a href="#decl676"><span class="keyword">type</span> CallExpr</a></code></div><div><code><a href="#decl670"><span class="keyword">type</span> CaseBodyData</a></code></div><div><code><a href="#decl667"><span class="keyword">type</span> CaseData</a></code></div><div><code><a href="#decl668"><span class="keyword">type</span> CaseDataCase</a></code></div><div><code><a href="#decl669"><span class="keyword">type</span> CaseDataElse</a></code></div><div><code><a href="#decl671"><span class="keyword">type</span> CaseStmt</a></code></div><div><code><a href="#decl736"><span class="keyword">type</span> Comment</a></code></div><div><code><a href="#decl690"><span class="keyword">type</span> ConstDecl</a></code></div><div><code><a href="#decl698"><span class="keyword">type</span> CUnionDecl</a></code></div><div><code><a href="#decl697"><span class="keyword">type</span> CustomTypeDecl</a></code></div><div><code><a href="#decl701"><span class="keyword">type</span> EnumDecl</a></code></div><div><code><a href="#decl700"><span class="keyword">type</span> EnumMember</a></code></div><div><code><a href="#decl747"><span class="keyword">type</span> EvalConfig</a></code></div><div><code><a href="#decl748"><span class="keyword">type</span> EvalResult</a></code></div><div><code><a href="#decl719"><span class="keyword">type</span> ExBorrow</a></code></div><div><code><a href="#decl703"><span class="keyword">type</span> FuncDecl</a></code></div><div><code><a href="#decl704"><span class="keyword">type</span> FuncParam</a></code></div><div><code><a href="#decl677"><span class="keyword">type</span> FuncSigKind</a></code></div><div><code><a href="#decl711"><span class="keyword">type</span> FuncType</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl707"><span class="keyword">type</span> GenericExpand</a></code></div><div><code><a href="#decl712"><span class="keyword">type</span> GenericVectorType</a></code></div><div><code><a href="#decl691"><span class="keyword">type</span> GlobalDecl</a></code></div><div><code><a href="#decl708"><span class="keyword">type</span> Group</a></code></div><div><code><a href="#decl692"><span class="keyword">type</span> Ident</a> (1)</code></div><div><code><a href="#decl705"><span class="keyword">type</span> IfExpr</a></code></div><div><code><a href="#decl680"><span class="keyword">type</span> ImplDecl</a></code></div><div><code><a href="#decl684"><span class="keyword">type</span> ImportStmt</a></code></div><div><code><a href="#decl721"><span class="keyword">type</span> IndexExpr</a></code></div><div><code><a href="#decl722"><span class="keyword">type</span> InitLit</a></code></div><div><code><a href="#decl685"><span class="keyword">type</span> Literal</a> (1)</code></div><div><code><a href="#decl659"><span class="keyword">type</span> Node</a> (4)</code></div><div><code><a href="#decl713"><span class="keyword">type</span> OptionType</a></code></div><div><code><a href="#decl732"><span class="keyword">type</span> ParseResult</a> (2)</code></div><div><code><a href="#decl723"><span class="keyword">type</span> PrefixLit</a></code></div><div><code><a href="#decl717"><span class="keyword">type</span> PtrExpr</a></code></div><div><code><a href="#decl689"><span class="keyword">type</span> Range</a></code></div><div><code><a href="#decl771"><span class="keyword">type</span> ReadLineFn =</a></code></div><div><code><a href="#decl718"><span class="keyword">type</span> RefExpr</a></code></div><div><code><a href="#decl768"><span class="keyword">type</span> REPL</a> (5)</code></div><div><code><a href="#decl720"><span class="keyword">type</span> ReturnExprStmt</a></code></div><div><code><a href="#decl724"><span class="keyword">type</span> Root</a></code></div><div><code><a href="#decl715"><span class="keyword">type</span> SliceType</a></code></div><div><code><a href="#decl714"><span class="keyword">type</span> SpanType</a></code></div><div><code><a href="#decl699"><span class="keyword">type</span> StructDecl</a></code></div></div><div><div><div><code><a href="#decl687"><span class="keyword">type</span> SwitchBlock</a></code></div><div><code><a href="#decl696"><span class="keyword">type</span> TemplateDecl</a></code></div><div><code><a href="#decl757"><span class="keyword">type</span> Thread</a> (1)</code></div><div><code><a href="#decl688"><span class="keyword">type</span> Token</a></code></div><div><code><a href="#decl709"><span class="keyword">type</span> TraitDecl</a></code></div><div><code><a href="#decl695"><span class="keyword">type</span> TypeAliasDecl</a></code></div><div><code><a href="#decl694"><span class="keyword">type</span> TypeConstDecl</a></code></div><div><code><a href="#decl756"><span class="keyword">type</span> TypeValue</a></code></div><div><code><a href="#decl681"><span class="keyword">type</span> Unary</a></code></div><div><code><a href="#decl775"><span class="keyword">type</span> UnaryOp</a></code></div><div><code><a href="#decl749"><span class="keyword">type</span> Value</a> (6)</code></div><div><code><a href="#decl725"><span class="keyword">type</span> VarDecl</a></code></div><div><code><a href="#decl710"><span class="keyword">type</span> VectorType</a></code></div><div><code><a href="#decl759"><span class="keyword">type</span> VM</a> (8)</code></div><div><code><a href="#decl702"><span class="keyword">type</span> With</a></code></div><div><code><a href="#decl673"><span class="keyword">type</span> ZCaseBodyData</a></code></div><div><code><a href="#decl672"><span class="keyword">type</span> ZCaseData</a></code></div><div><code><a href="#decl674"><span class="keyword">type</span> ZCaseStmt</a></code></div><div><code><a href="#decl665"><span class="keyword">type</span> ZNode</a> (1)</code></div><div><code><a href="#decl730"><span class="keyword">type</span> ZNodePayload</a></code></div><div><code><a href="#decl727"><span class="keyword">type</span> ZNodes</a></code></div><div><code><a href="#decl740"><span class="keyword">type</span> ZParser</a> (1)</code></div><div><code><a href="#decl726"><span class="keyword">type</span> ZStr</a></code></div></div></div></td></tr></tbody></table><blockquote id="decl648"><code><span class="keyword">const</span> <span class="decl">Await</span> = 1<br/></code></blockquote><blockquote id="decl649"><code><span class="keyword">const</span> <span class="decl">ErrorCompile</span> = 2<br/></code></blockquote><blockquote id="decl650"><code><span class="keyword">const</span> <span class="decl">ErrorPanic</span> = 3<br/></code></blockquote><blockquote id="decl647"><code><span class="keyword">const</span> <span class="decl">Success</span> = 0<br/></code></blockquote><blockquote id="decl652"><code><span class="keyword">const</span> <span class="decl">TypeBool</span> = 2<br/></code></blockquote><blockquote id="decl655"><code><span class="keyword">const</span> <span class="decl">TypeF64</span> = 13<br/></code></blockquote><blockquote id="decl656"><code><span class="keyword">const</span> <span class="decl">TypeFloat</span> = TypeF64<br/></code></blockquote><blockquote id="decl653"><code><span class="keyword">const</span> <span class="decl">TypeI64</span> = 6<br/></code></blockquote><blockquote id="decl654"><code><span class="keyword">const</span> <span class="decl">TypeInt</span> = TypeI64<br/></code></blockquote><blockquote id="decl657"><code><span class="keyword">const</span> <span class="decl">TypeStr</span> = 23<br/></code></blockquote><blockquote id="decl651"><code><span class="keyword">const</span> <span class="decl">TypeVoid</span> = 0<br/></code></blockquote><blockquote id="decl743"><code><span class="keyword">fn</span> <span class="decl">_new_parser</span>() -> <span class="type">Ptr[void]</span></code><br /></blockquote><blockquote id="decl738"><code><span class="keyword">fn</span> <span class="decl">_parser_comments</span>(parser <span class="type">Ptr[void]</span>, buffer_t <span class="type">int</span>) -> <span class="type">[]Comment</span></code><br /></blockquote><blockquote id="decl744"><code><span class="keyword">fn</span> <span class="decl">destroy_parser</span>(parser <span class="type">Ptr[void]</span>) </code><br /></blockquote><blockquote id="decl658"><code><span class="keyword">fn</span> <span class="decl">eval</span>(src <span class="type">str</span>) -> <span class="type">!Object</span></code><br />Evaluates source code in an isolated VM. If the last statement is an expression, a primitive or a string can be returned.</blockquote><blockquote id="decl729"><code><span class="keyword">fn</span> <span class="decl">from_znode</span>(znode <span class="type">Ptr[ZNode]</span>) -> <span class="type">?^Node</span></code><br /></blockquote><blockquote id="decl731"><code><span class="keyword">fn</span> <span class="decl">from_znode_auto</span>(Tag <span class="type">Node.Tag</span>, znode <span class="type">Ptr[ZNode]</span>) -> <span class="type">^Node</span></code><br /></blockquote><blockquote id="decl728"><code><span class="keyword">fn</span> <span class="decl">from_znodes</span>(znodes <span class="type">ZNodes</span>) -> <span class="type">[]^Node</span></code><br /></blockquote><blockquote id="decl662"><code><span class="keyword">fn</span> <span class="decl">is_adjacent_stmt</span>(src <span class="type">str</span>, a_end <span class="type">int</span>, b_start <span class="type">int</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl742"><code><span class="keyword">fn</span> <span class="decl">new_parser</span>() -> <span class="type">ZParser</span></code><br /></blockquote><blockquote id="decl735"><code><span class="keyword">fn</span> <span class="decl">parse</span>(src <span class="type">str</span>) -> <span class="type">ParseResult</span></code><br />Parses Cyber source.</blockquote><blockquote id="decl737"><code><span class="keyword">fn</span> <span class="decl">parser_comments</span>(parser <span class="type">Ptr[void]</span>) -> <span class="type">[]Comment</span></code><br /></blockquote><blockquote id="decl745"><code><span class="keyword">fn</span> <span class="decl">repl</span>(read_line <span class="type">ReadLineFn</span>) -> <span class="type">void</span></code><br />Starts an isolated REPL session. The callback `read_line(prefix string) string` is responsible for obtaining the input.</blockquote><blockquote id="decl706" class="type"><code><span class="keyword">type</span> <span class="decl">AccessExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl675" class="type"><code><span class="keyword">type</span> <span class="decl">AsExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl679" class="type"><code><span class="keyword">type</span> <span class="decl">Attribute</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl678" class="type"><code><span class="keyword">type</span> <span class="decl">AttributeKind</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> bind</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> extern</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> call</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> generator</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> cond</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unsafe</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> consteval</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> reserve</code><br /></blockquote><blockquote id="decl746" class="type"><code><span class="keyword">type</span> <span class="decl">Backend</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> vm</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> jit</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> tcc</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> cc</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> llvm</code><br /></blockquote><blockquote id="decl683" class="type"><code><span class="keyword">type</span> <span class="decl">BinaryExprOp</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> index</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> plus</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> minus</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> star</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> pow</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> slash</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> percent</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bitwiseAnd</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bitwiseOr</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bitwiseXor</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bitwiseLeftShift</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bitwiseRightShift</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bang_equal</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> less</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> less_equal</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> greater</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> greater_equal</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> equal_equal</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> and_op</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> or_op</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> cast</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> range</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> reverse_range</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dummy</code><br /></blockquote><blockquote id="decl682" class="type"><code><span class="keyword">type</span> <span class="decl">BinExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl716" class="type"><code><span class="keyword">type</span> <span class="decl">BorrowExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl676" class="type"><code><span class="keyword">type</span> <span class="decl">CallExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl670" class="type"><code><span class="keyword">type</span> <span class="decl">CaseBodyData</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> block <span class="type">[]^Node</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> expr <span class="type">^Node</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> fallthrough <span class="type">void</span></code><br /></blockquote><blockquote id="decl667" class="type"><code><span class="keyword">type</span> <span class="decl">CaseData</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> _case <span class="type">CaseDataCase</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> _else <span class="type">CaseDataElse</span></code><br /></blockquote><blockquote id="decl668" class="type"><code><span class="keyword">type</span> <span class="decl">CaseDataCase</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl669" class="type"><code><span class="keyword">type</span> <span class="decl">CaseDataElse</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl671" class="type"><code><span class="keyword">type</span> <span class="decl">CaseStmt</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl736" class="type"><code><span class="keyword">type</span> <span class="decl">Comment</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl690" class="type"><code><span class="keyword">type</span> <span class="decl">ConstDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl698" class="type"><code><span class="keyword">type</span> <span class="decl">CUnionDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl697" class="type"><code><span class="keyword">type</span> <span class="decl">CustomTypeDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl701" class="type"><code><span class="keyword">type</span> <span class="decl">EnumDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl700" class="type"><code><span class="keyword">type</span> <span class="decl">EnumMember</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl747" class="type"><code><span class="keyword">type</span> <span class="decl">EvalConfig</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl748" class="type"><code><span class="keyword">type</span> <span class="decl">EvalResult</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl719" class="type"><code><span class="keyword">type</span> <span class="decl">ExBorrow</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl703" class="type"><code><span class="keyword">type</span> <span class="decl">FuncDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl704" class="type"><code><span class="keyword">type</span> <span class="decl">FuncParam</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl677" class="type"><code><span class="keyword">type</span> <span class="decl">FuncSigKind</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> func</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> infer</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> method</code><br /></blockquote><blockquote id="decl711" class="type"><code><span class="keyword">type</span> <span class="decl">FuncType</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl707" class="type"><code><span class="keyword">type</span> <span class="decl">GenericExpand</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl712" class="type"><code><span class="keyword">type</span> <span class="decl">GenericVectorType</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl691" class="type"><code><span class="keyword">type</span> <span class="decl">GlobalDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl708" class="type"><code><span class="keyword">type</span> <span class="decl">Group</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl692" class="type"><code><span class="keyword">type</span> <span class="decl">Ident</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Ident</span>) <span class="decl">end</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl705" class="type"><code><span class="keyword">type</span> <span class="decl">IfExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl680" class="type"><code><span class="keyword">type</span> <span class="decl">ImplDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl684" class="type"><code><span class="keyword">type</span> <span class="decl">ImportStmt</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl721" class="type"><code><span class="keyword">type</span> <span class="decl">IndexExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl722" class="type"><code><span class="keyword">type</span> <span class="decl">InitLit</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl685" class="type"><code><span class="keyword">type</span> <span class="decl">Literal</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Literal</span>) <span class="decl">end</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl659" class="type"><code><span class="keyword">type</span> <span class="decl">Node</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> null <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> access_expr <span class="type">AccessExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> all <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> as_expr <span class="type">AsExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> assign_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> at_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> attribute <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> begin_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bin_expr <span class="type">BinExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> binLit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> borrow <span class="type">BorrowExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> breakStmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> case_stmt <span class="type">CaseStmt</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> call_expr <span class="type">CallExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> catchStmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> const_decl <span class="type">ConstDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> continueStmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> cstruct_decl <span class="type">StructDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ct_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> cunion_decl <span class="type">CUnionDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> custom_type_decl <span class="type">CustomTypeDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dec_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dec_u <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> deref <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dollar <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dollar_lit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dot <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dot_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> else_block <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> elseif_block <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> enum_decl <span class="type">EnumDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> enum_member <span class="type">EnumMember</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> error_lit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ex_borrow <span class="type">ExBorrow</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> expand_lit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> exprStmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> falseLit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> for_iter_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> for_range_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> float_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> func_decl <span class="type">FuncDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> func_param <span class="type">FuncParam</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> fn_type <span class="type">FuncType</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> fnsym_type <span class="type">FuncType</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> generic_expand <span class="type">GenericExpand</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> generic_vector_type <span class="type">GenericVectorType</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> global_decl <span class="type">GlobalDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> group <span class="type">Group</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> hex_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ident <span class="type">Ident</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> if_expr <span class="type">IfExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> if_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> if_unwrap_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> impl_decl <span class="type">ImplDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> import_stmt <span class="type">ImportStmt</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> index_expr <span class="type">IndexExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> infer_param <span class="type">PrefixLit</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> init_expr <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> init_lit <span class="type">InitLit</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> keyValue <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> label_decl <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> lambda_cont_expr <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> lambda_cont <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> lambda_expr <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> lambda_multi <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> move_expr <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> namedArg <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> noneLit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> octLit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> op_assign_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> option_type <span class="type">OptionType</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> partial_vector_type <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> pass_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ptr <span class="type">PtrExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> range <span class="type">Range</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> raw_string_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> raw_string_multi_lit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ref <span class="type">RefExpr</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> return_expr_stmt <span class="type">ReturnExprStmt</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> return_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> root <span class="type">Root</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> seqDestructure <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> slice_type <span class="type">SliceType</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> span_type <span class="type">SpanType</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> special_string_lit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> sq_string_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> sq_string_multi_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> string_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> string_multi_lit <span class="type">Literal</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> stringt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> stringt_multi <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> stringt_part <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> stringt_expr <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> struct_decl <span class="type">StructDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> struct_field <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> switch_expr <span class="type">SwitchBlock</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> switch_stmt <span class="type">SwitchBlock</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> template <span class="type">TemplateDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> trait_decl <span class="type">TraitDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> true_lit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> tryStmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> type_alias_decl <span class="type">TypeAliasDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> type_const_decl <span class="type">TypeConstDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unary_expr <span class="type">Unary</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> undef_lit <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> union_case <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unwrap <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unwrap_choice <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unwrap_or <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unwrap_or_block <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unwrap_res <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unwrap_res_or <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unwrap_res_or_block <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> use_alias <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> var_decl <span class="type">VarDecl</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> vector_type <span class="type">VectorType</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> void_lit <span class="type">Token</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> whileCondStmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> whileInfStmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> while_unwrap_stmt <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> with <span class="type">With</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> yield_stmt <span class="type">void</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Node</span>) <span class="decl">decl_name</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Node</span>) <span class="decl">end</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Node</span>) <span class="decl">name</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Node</span>) <span class="decl">pos</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl713" class="type"><code><span class="keyword">type</span> <span class="decl">OptionType</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl732" class="type"><code><span class="keyword">type</span> <span class="decl">ParseResult</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ParseResult</span>) <span class="decl">node_text</span>(node <span class="type">^Node</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ParseResult</span>) <span class="decl">stmt_docs</span>(stmt <span class="type">^Node</span>) -> <span class="type">?str</span></code><br /></blockquote><blockquote id="decl723" class="type"><code><span class="keyword">type</span> <span class="decl">PrefixLit</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl717" class="type"><code><span class="keyword">type</span> <span class="decl">PtrExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl689" class="type"><code><span class="keyword">type</span> <span class="decl">Range</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl771" class="type"><code><span class="keyword">type</span> <span class="decl">ReadLineFn</span> = <span class="type">fn(prefix str) -> Future[str]</span></code></blockquote><blockquote id="decl718" class="type"><code><span class="keyword">type</span> <span class="decl">RefExpr</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl768" class="type"><code><span class="keyword">type</span> <span class="decl">REPL</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl769"><code><span class="keyword">fn</span> <span class="type">REPL</span> :: <span class="decl">new</span>() -> <span class="type">REPL</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&REPL</span>) <span class="decl">eval_print</span>(code <span class="type">str</span>) </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&REPL</span>) <span class="decl">prefix</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&REPL</span>) <span class="decl">print_intro</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&REPL</span>) <span class="decl">read</span>(read_line <span class="type">ReadLineFn</span>) -> <span class="type">?str</span></code><br /></blockquote><blockquote id="decl720" class="type"><code><span class="keyword">type</span> <span class="decl">ReturnExprStmt</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl724" class="type"><code><span class="keyword">type</span> <span class="decl">Root</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl715" class="type"><code><span class="keyword">type</span> <span class="decl">SliceType</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl714" class="type"><code><span class="keyword">type</span> <span class="decl">SpanType</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl699" class="type"><code><span class="keyword">type</span> <span class="decl">StructDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl687" class="type"><code><span class="keyword">type</span> <span class="decl">SwitchBlock</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl696" class="type"><code><span class="keyword">type</span> <span class="decl">TemplateDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl757" class="type"><code><span class="keyword">type</span> <span class="decl">Thread</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Thread</span>) <span class="decl">deinit_str</span>(value <span class="type">Value</span>) </code><br /></blockquote><blockquote id="decl688" class="type"><code><span class="keyword">type</span> <span class="decl">Token</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl709" class="type"><code><span class="keyword">type</span> <span class="decl">TraitDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl695" class="type"><code><span class="keyword">type</span> <span class="decl">TypeAliasDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl694" class="type"><code><span class="keyword">type</span> <span class="decl">TypeConstDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl756" class="type"><code><span class="keyword">type</span> <span class="decl">TypeValue</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl681" class="type"><code><span class="keyword">type</span> <span class="decl">Unary</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl775" class="type"><code><span class="keyword">type</span> <span class="decl">UnaryOp</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> minus</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> lnot</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bit_not</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> addr_of</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dummy</code><br /></blockquote><blockquote id="decl749" class="type"><code><span class="keyword">type</span> <span class="decl">Value</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Value</span>) <span class="decl">as_bool</span>() -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Value</span>) <span class="decl">as_float</span>() -> <span class="type">float</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Value</span>) <span class="decl">as_int</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Value</span>) <span class="decl">as_str</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Value</span>) <span class="decl">object_type</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Value</span>) <span class="decl">to_host</span>(val_t <span class="type">int</span>) -> <span class="type">Object</span></code><br /></blockquote><blockquote id="decl725" class="type"><code><span class="keyword">type</span> <span class="decl">VarDecl</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl710" class="type"><code><span class="keyword">type</span> <span class="decl">VectorType</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl759" class="type"><code><span class="keyword">type</span> <span class="decl">VM</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl760"><code><span class="keyword">fn</span> <span class="type">VM</span> :: <span class="decl">@init</span>() -> <span class="type">VM</span></code><br />Create an isolated VM.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&VM</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&VM</span>) <span class="decl">compile_error_summary</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&VM</span>) <span class="decl">eval</span>(code <span class="type">str</span>) -> <span class="type">EvalResult</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&VM</span>) <span class="decl">eval</span>(uri <span class="type">str</span>, code <span class="type">str</span>, config <span class="type">EvalConfig</span>) -> <span class="type">EvalResult</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&VM</span>) <span class="decl">main_thread</span>() -> <span class="type">Thread</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&VM</span>) <span class="decl">panic_summary</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&VM</span>) <span class="decl">value_desc</span>(val_t <span class="type">int</span>, value <span class="type">Value</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl702" class="type"><code><span class="keyword">type</span> <span class="decl">With</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="ZCaseBodyData" class="type"><code><span class="keyword">type</span> <span class="decl">ZCaseBodyData</span> <span class="keyword">cunion</span></code><br/></blockquote><blockquote id="ZCaseData" class="type"><code><span class="keyword">type</span> <span class="decl">ZCaseData</span> <span class="keyword">cunion</span></code><br/></blockquote><blockquote id="decl674" class="type"><code><span class="keyword">type</span> <span class="decl">ZCaseStmt</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl665" class="type"><code><span class="keyword">type</span> <span class="decl">ZNode</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ZNode</span>) <span class="decl">type</span>() -> <span class="type">Node.Tag</span></code><br /></blockquote><blockquote id="decl730" class="type"><code><span class="keyword">type</span> <span class="decl">ZNodePayload</span>[T <span class="type">Any</span>] <span class="keyword">const</span></code></blockquote><blockquote id="decl727" class="type"><code><span class="keyword">type</span> <span class="decl">ZNodes</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl740" class="type"><code><span class="keyword">type</span> <span class="decl">ZParser</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ZParser</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote id="decl726" class="type"><code><span class="keyword">type</span> <span class="decl">ZStr</span> <span class="keyword">struct</span></code><br/></blockquote><h1 id="meta"><code><span class="keyword">mod</span> <span class="decl">meta</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl776"><span class="keyword">fn</span> access</a></code></div><div><code><a href="#decl811"><span class="keyword">fn</span> access_choice_case</a></code></div><div><code><a href="#decl812"><span class="keyword">fn</span> access_option_payload</a></code></div><div><code><a href="#decl814"><span class="keyword">fn</span> access_result_error</a></code></div><div><code><a href="#decl813"><span class="keyword">fn</span> access_result_payload</a></code></div><div><code><a href="#decl777"><span class="keyword">fn</span> build_flag</a></code></div><div><code><a href="#decl778"><span class="keyword">fn</span> build_mode</a></code></div><div><code><a href="#decl779"><span class="keyword">fn</span> build_option</a></code></div><div><code><a href="#decl780"><span class="keyword">fn</span> choice_tag</a></code></div><div><code><a href="#decl781"><span class="keyword">fn</span> cpu</a></code></div><div><code><a href="#decl783"><span class="keyword">fn</span> dump_frame</a></code></div><div><code><a href="#decl784"><span class="keyword">fn</span> endian</a></code></div><div><code><a href="#decl785"><span class="keyword">fn</span> enum_case</a></code></div><div><code><a href="#decl786"><span class="keyword">fn</span> enum_int_values</a></code></div><div><code><a href="#decl788"><span class="keyword">fn</span> enum_name</a></code></div><div><code><a href="#decl787"><span class="keyword">fn</span> enum_name_eval</a></code></div><div><code><a href="#decl789"><span class="keyword">fn</span> enum_values</a></code></div><div><code><a href="#decl790"><span class="keyword">fn</span> error</a></code></div><div><code><a href="#decl791"><span class="keyword">fn</span> eval</a></code></div></div><div><div><code><a href="#decl792"><span class="keyword">fn</span> event</a></code></div><div><code><a href="#decl782"><span class="keyword">fn</span> full_version</a></code></div><div><code><a href="#decl793"><span class="keyword">fn</span> get_closure_data</a></code></div><div><code><a href="#decl794"><span class="keyword">fn</span> has_decl</a></code></div><div><code><a href="#decl795"><span class="keyword">fn</span> init_choice</a></code></div><div><code><a href="#decl796"><span class="keyword">fn</span> init_type</a></code></div><div><code><a href="#decl797"><span class="keyword">fn</span> is_inline_eval</a></code></div><div><code><a href="#decl798"><span class="keyword">fn</span> is_none</a></code></div><div><code><a href="#decl799"><span class="keyword">fn</span> is_result_error</a></code></div><div><code><a href="#decl800"><span class="keyword">fn</span> is_vm_target</a></code></div><div><code><a href="#decl801"><span class="keyword">fn</span> load</a></code></div><div><code><a href="#decl802"><span class="keyword">fn</span> log</a></code></div><div><code><a href="#decl803"><span class="keyword">fn</span> mod_uri</a></code></div><div><code><a href="#decl805"><span class="keyword">fn</span> new_struct</a></code></div><div><code><a href="#decl810"><span class="keyword">fn</span> pointer_width</a></code></div><div><code><a href="#decl806"><span class="keyword">fn</span> reachable</a></code></div><div><code><a href="#decl807"><span class="keyword">fn</span> stack_trace</a></code></div><div><code><a href="#decl808"><span class="keyword">fn</span> system</a></code></div><div><code><a href="#decl809"><span class="keyword">fn</span> trace_enabled</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl816"><span class="keyword">fn</span> trace_releases</a></code></div><div><code><a href="#decl815"><span class="keyword">fn</span> trace_retains</a></code></div><div><code><a href="#decl817"><span class="keyword">fn</span> unsupported</a></code></div><div><code><a href="#decl818"><span class="keyword">type</span> BorrowInfo</a></code></div><div><code><a href="#decl841"><span class="keyword">type</span> BorrowTraitInfo</a></code></div><div><code><a href="#decl819"><span class="keyword">type</span> BuildMode</a></code></div><div><code><a href="#decl820"><span class="keyword">type</span> CasePayload =</a></code></div><div><code><a href="#decl821"><span class="keyword">type</span> ChoiceCase</a></code></div><div><code><a href="#decl822"><span class="keyword">type</span> ChoiceInfo</a></code></div><div><code><a href="#decl823"><span class="keyword">type</span> Code</a></code></div><div><code><a href="#decl824"><span class="keyword">type</span> CStructInfo</a></code></div><div><code><a href="#decl825"><span class="keyword">type</span> CUnionCase</a></code></div><div><code><a href="#decl826"><span class="keyword">type</span> CUnionInfo</a></code></div><div><code><a href="#decl844"><span class="keyword">type</span> DynTraitInfo</a></code></div><div><code><a href="#decl827"><span class="keyword">type</span> EnumCase</a></code></div><div><code><a href="#decl828"><span class="keyword">type</span> EnumInfo</a></code></div><div><code><a href="#decl830"><span class="keyword">type</span> FloatInfo</a></code></div><div><code><a href="#decl866"><span class="keyword">type</span> FnParamsTuple</a></code></div><div><code><a href="#decl831"><span class="keyword">type</span> FuncInfo</a></code></div></div><div><div><div><code><a href="#decl832"><span class="keyword">type</span> FuncKind</a></code></div><div><code><a href="#decl833"><span class="keyword">type</span> FuncParam</a></code></div><div><code><a href="#decl834"><span class="keyword">type</span> IntInfo</a></code></div><div><code><a href="#decl836"><span class="keyword">type</span> OptionInfo</a></code></div><div><code><a href="#decl846"><span class="keyword">type</span> PartialStructLayout</a> (2)</code></div><div><code><a href="#decl837"><span class="keyword">type</span> PointerInfo</a></code></div><div><code><a href="#decl835"><span class="keyword">type</span> RawInfo</a></code></div><div><code><a href="#decl843"><span class="keyword">type</span> RefTraitInfo</a></code></div><div><code><a href="#decl838"><span class="keyword">type</span> ResultInfo</a></code></div><div><code><a href="#decl804"><span class="keyword">type</span> StructConfig</a></code></div><div><code><a href="#decl839"><span class="keyword">type</span> StructField</a></code></div><div><code><a href="#decl840"><span class="keyword">type</span> StructInfo</a></code></div><div><code><a href="#decl842"><span class="keyword">type</span> TraitInfo</a></code></div><div><code><a href="#decl845"><span class="keyword">type</span> type</a> (16)</code></div><div><code><a href="#decl865"><span class="keyword">type</span> TypeInfo</a></code></div><div><code><a href="#decl829"><span class="keyword">type</span> VectorInfo</a></code></div></div></div></td></tr></tbody></table><blockquote id="decl776"><code><span class="keyword">fn</span> <span class="decl">access</span>(rec <span class="type">Code</span>, field <span class="type">EvalStr</span>) -> <span class="type">Any</span></code><br />Access a receiver with a given field as a string.</blockquote><blockquote id="decl811"><code><span class="keyword">fn</span> <span class="decl">access_choice_case</span>(choice <span class="type">%T</span>, Tag <span class="type">T.Tag</span>) -> <span class="type">CasePayload[T, Tag]</span></code><br /></blockquote><blockquote id="decl812"><code><span class="keyword">fn</span> <span class="decl">access_option_payload</span>(opt <span class="type">?%T</span>) -> <span class="type">T</span></code><br />Unwraps an option type without runtime checks.</blockquote><blockquote id="decl814"><code><span class="keyword">fn</span> <span class="decl">access_result_error</span>(res <span class="type">!%T</span>) -> <span class="type">error</span></code><br /></blockquote><blockquote id="decl813"><code><span class="keyword">fn</span> <span class="decl">access_result_payload</span>(res <span class="type">!%T</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl777"><code><span class="keyword">fn</span> <span class="decl">build_flag</span>(name <span class="type">str</span>) -> <span class="type">bool</span></code><br />Returns whether a build flag is set.</blockquote><blockquote id="decl778"><code><span class="keyword">fn</span> <span class="decl">build_mode</span>() -> <span class="type">BuildMode</span></code><br /></blockquote><blockquote id="decl779"><code><span class="keyword">fn</span> <span class="decl">build_option</span>(name <span class="type">str</span>) -> <span class="type">?str</span></code><br />Returns a build option's value.</blockquote><blockquote id="decl780"><code><span class="keyword">fn</span> <span class="decl">choice_tag</span>(choice <span class="type">%T</span>) -> <span class="type">T.Tag</span></code><br />Returns the tag of a choice value.</blockquote><blockquote id="decl781"><code><span class="keyword">fn</span> <span class="decl">cpu</span>() -> <span class="type">EvalStr</span></code><br />The current build's target cpu arch.</blockquote><blockquote id="decl783"><code><span class="keyword">fn</span> <span class="decl">dump_frame</span>() </code><br /></blockquote><blockquote id="decl784"><code><span class="keyword">fn</span> <span class="decl">endian</span>() -> <span class="type">Endian</span></code><br />The current arch's endianness.</blockquote><blockquote id="decl785"><code><span class="keyword">fn</span> <span class="decl">enum_case</span>(enum_value <span class="type">%T</span>) -> <span class="type">EnumCase</span></code><br /></blockquote><blockquote id="decl786"><code><span class="keyword">fn</span> <span class="decl">enum_int_values</span>(T <span class="type">type</span>) -> <span class="type">EvalBuffer[int]</span></code><br /></blockquote><blockquote id="decl788"><code><span class="keyword">fn</span> <span class="decl">enum_name</span>(enum_value <span class="type">%T</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl787"><code><span class="keyword">fn</span> <span class="decl">enum_name_eval</span>(enum_value <span class="type">%T</span>) -> <span class="type">EvalStr</span></code><br /></blockquote><blockquote id="decl789"><code><span class="keyword">fn</span> <span class="decl">enum_values</span>(T <span class="type">type</span>) -> <span class="type">EvalBuffer[T]</span></code><br /></blockquote><blockquote id="decl790"><code><span class="keyword">fn</span> <span class="decl">error</span>(msg <span class="type">EvalStr</span>) -> <span class="type">never</span></code><br />Raise compile-time error.</blockquote><blockquote id="decl791"><code><span class="keyword">fn</span> <span class="decl">eval</span>(code <span class="type">Code</span>) -> <span class="type">Any</span></code><br />Equivalent to the compile-time expression `#{}`.</blockquote><blockquote id="decl792"><code><span class="keyword">fn</span> <span class="decl">event</span>() -> <span class="type">int</span></code><br />For debugging. Returns the current event ID.</blockquote><blockquote id="decl782"><code><span class="keyword">fn</span> <span class="decl">full_version</span>() -> <span class="type">EvalStr</span></code><br />Returns the version of the Cyber compiler.</blockquote><blockquote id="decl793"><code><span class="keyword">fn</span> <span class="decl">get_closure_data</span>(func <span class="type">Ptr[void]</span>) -> <span class="type">?Ptr[ClosureData]</span></code><br /></blockquote><blockquote id="decl794"><code><span class="keyword">fn</span> <span class="decl">has_decl</span>(parent <span class="type">Code</span>, name <span class="type">EvalStr</span>) -> <span class="type">bool</span></code><br />Returns whether a type has a `name` declaration.</blockquote><blockquote id="decl795"><code><span class="keyword">fn</span> <span class="decl">init_choice</span>(T <span class="type">type</span>, Tag <span class="type">T.Tag</span>, payload <span class="type">Code</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl796"><code><span class="keyword">fn</span> <span class="decl">init_type</span>(T <span class="type">type</span>, init <span class="type">Code</span>) -> <span class="type">T</span></code><br />Equivalent to the default T{} initializer. When `$initRecord` is overloaded, this can be used to emit the default initializer.</blockquote><blockquote id="decl797"><code><span class="keyword">fn</span> <span class="decl">is_inline_eval</span>() -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl798"><code><span class="keyword">fn</span> <span class="decl">is_none</span>(option <span class="type">Code</span>) -> <span class="type">bool</span></code><br />Returns whether an option or a reference to an option is `none`.</blockquote><blockquote id="decl799"><code><span class="keyword">fn</span> <span class="decl">is_result_error</span>(result <span class="type">Code</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl800"><code><span class="keyword">fn</span> <span class="decl">is_vm_target</span>() -> <span class="type">bool</span></code><br />Whether source is being compiled for the VM.</blockquote><blockquote id="decl801"><code><span class="keyword">fn</span> <span class="decl">load</span>(path <span class="type">str</span>) -> <span class="type">EvalStr</span></code><br />Load a file relative to the project root (main source file). TODO: This should restrict loading files above the project root.</blockquote><blockquote id="decl802"><code><span class="keyword">fn</span> <span class="decl">log</span>(x <span class="type">%T</span>) </code><br />Log to stderr at compile-time.</blockquote><blockquote id="decl803"><code><span class="keyword">fn</span> <span class="decl">mod_uri</span>() -> <span class="type">EvalStr</span></code><br /></blockquote><blockquote id="decl805"><code><span class="keyword">fn</span> <span class="decl">new_struct</span>(init <span class="type">[%N]StructField</span>, config <span class="type">StructConfig</span>) -> <span class="type">type</span></code><br />Creates a new `struct` type. `StructField.offset` is ignored when computing field offsets.</blockquote><blockquote id="decl810"><code><span class="keyword">fn</span> <span class="decl">pointer_width</span>() -> <span class="type">int</span></code><br />Returns the target arch pointer bit width.</blockquote><blockquote id="decl806"><code><span class="keyword">fn</span> <span class="decl">reachable</span>() -> <span class="type">bool</span></code><br />Returns whether the current statement is reachable.</blockquote><blockquote id="decl807"><code><span class="keyword">fn</span> <span class="decl">stack_trace</span>() -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl808"><code><span class="keyword">fn</span> <span class="decl">system</span>() -> <span class="type">SystemKind</span></code><br />The current build's target operating system.</blockquote><blockquote id="decl809"><code><span class="keyword">fn</span> <span class="decl">trace_enabled</span>() -> <span class="type">bool</span></code><br />Whether the compiler was built with `Trace`.</blockquote><blockquote id="decl816"><code><span class="keyword">fn</span> <span class="decl">trace_releases</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl815"><code><span class="keyword">fn</span> <span class="decl">trace_retains</span>() -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl817"><code><span class="keyword">fn</span> <span class="decl">unsupported</span>() -> <span class="type">never</span></code><br />Raise compile-time error.</blockquote><blockquote id="decl818" class="type"><code><span class="keyword">type</span> <span class="decl">BorrowInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl841" class="type"><code><span class="keyword">type</span> <span class="decl">BorrowTraitInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl819" class="type"><code><span class="keyword">type</span> <span class="decl">BuildMode</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> debug</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> release</code><br /></blockquote><blockquote id="decl820" class="type"><code><span class="keyword">type</span> <span class="decl">CasePayload</span>[ChoiceT <span class="type">Any</span>, Tag <span class="type">ChoiceT.Tag</span>] = <span class="type">_</span></code></blockquote><blockquote id="decl821" class="type"><code><span class="keyword">type</span> <span class="decl">ChoiceCase</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl822" class="type"><code><span class="keyword">type</span> <span class="decl">ChoiceInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl823" class="type"><code><span class="keyword">type</span> <span class="decl">Code</span> _</code><br/></blockquote><blockquote id="decl824" class="type"><code><span class="keyword">type</span> <span class="decl">CStructInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl825" class="type"><code><span class="keyword">type</span> <span class="decl">CUnionCase</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl826" class="type"><code><span class="keyword">type</span> <span class="decl">CUnionInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl844" class="type"><code><span class="keyword">type</span> <span class="decl">DynTraitInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl827" class="type"><code><span class="keyword">type</span> <span class="decl">EnumCase</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl828" class="type"><code><span class="keyword">type</span> <span class="decl">EnumInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl830" class="type"><code><span class="keyword">type</span> <span class="decl">FloatInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl866" class="type"><code><span class="keyword">type</span> <span class="decl">FnParamsTuple</span>[Sig <span class="type">FuncSig</span>] <span class="keyword">const</span></code></blockquote><blockquote id="decl831" class="type"><code><span class="keyword">type</span> <span class="decl">FuncInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl832" class="type"><code><span class="keyword">type</span> <span class="decl">FuncKind</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> ptr</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> union</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> sym</code><br /></blockquote><blockquote id="decl833" class="type"><code><span class="keyword">type</span> <span class="decl">FuncParam</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl834" class="type"><code><span class="keyword">type</span> <span class="decl">IntInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl836" class="type"><code><span class="keyword">type</span> <span class="decl">OptionInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl846" class="type"><code><span class="keyword">type</span> <span class="decl">PartialStructLayout</span> _</code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">PartialStructLayout</span>) <span class="decl">field_layout</span>(state_offset <span class="type">int</span>, state_len <span class="type">int</span>) -> <span class="type">?PartialStructLayout</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">PartialStructLayout</span>) <span class="decl">is_field_active</span>(state_offset <span class="type">int</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl837" class="type"><code><span class="keyword">type</span> <span class="decl">PointerInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl835" class="type"><code><span class="keyword">type</span> <span class="decl">RawInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl843" class="type"><code><span class="keyword">type</span> <span class="decl">RefTraitInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl838" class="type"><code><span class="keyword">type</span> <span class="decl">ResultInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl804" class="type"><code><span class="keyword">type</span> <span class="decl">StructConfig</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl839" class="type"><code><span class="keyword">type</span> <span class="decl">StructField</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl840" class="type"><code><span class="keyword">type</span> <span class="decl">StructInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl842" class="type"><code><span class="keyword">type</span> <span class="decl">TraitInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl845" class="type"><code><span class="keyword">type</span> <span class="decl">type</span> _</code><br/></blockquote><blockquote id="decl849"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">@init</span>(s <span class="type">str</span>) -> <span class="type">type</span></code><br /></blockquote><blockquote id="decl850"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">field</span>(T <span class="type">type</span>, s <span class="type">str</span>) -> <span class="type">StructField</span></code><br /></blockquote><blockquote id="decl851"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">fn_ret</span>(T <span class="type">type</span>) -> <span class="type">type</span></code><br /></blockquote><blockquote id="decl852"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">id</span>(T <span class="type">type</span>) -> <span class="type">int</span></code><br />Returns a unique ID for this type.</blockquote><blockquote id="decl853"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">implements</span>(T <span class="type">type</span>, Trait <span class="type">type</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl854"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">info</span>(T <span class="type">type</span>) -> <span class="type">TypeInfo</span></code><br />Returns info about a type.</blockquote><blockquote id="decl857"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">is_const</span>(T <span class="type">type</span>) -> <span class="type">bool</span></code><br />Returns whether the type is const eligible.</blockquote><blockquote id="decl856"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">is_copyable</span>(T <span class="type">type</span>) -> <span class="type">bool</span></code><br />Returns whether a type is copyable. A type can be copyable if it does not implement `NoCopy` and contains members that are all copyable.</blockquote><blockquote id="decl855"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">is_instance_of</span>(T <span class="type">type</span>, Template <span class="type">Code</span>) -> <span class="type">bool</span></code><br />Returns whether a type is an instance of a template.</blockquote><blockquote id="decl861"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">managed</span>(T <span class="type">type</span>) -> <span class="type">bool</span></code><br />Returns whether the type is managed. Managed types either have a builtin destructor or a custom `T.$deinit`.</blockquote><blockquote id="decl862"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">name</span>(T <span class="type">type</span>) -> <span class="type">EvalStr</span></code><br /></blockquote><blockquote id="decl863"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">name_rt</span>(id <span class="type">int</span>) -> <span class="type">str</span></code><br />Returns the runtime type name. This is only available in trace mode.</blockquote><blockquote id="decl858"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">of</span>(expr <span class="type">Code</span>) -> <span class="type">type</span></code><br />Returns the type of an expression.</blockquote><blockquote id="decl859"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">offset</span>(T <span class="type">type</span>, s <span class="type">str</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl864"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">size</span>(T <span class="type">type</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl860"><code><span class="keyword">fn</span> <span class="type">type</span> :: <span class="decl">struct_state_len</span>(T <span class="type">type</span>) -> <span class="type">int</span></code><br /></blockquote><blockquote id="decl865" class="type"><code><span class="keyword">type</span> <span class="decl">TypeInfo</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> int <span class="type">IntInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> raw <span class="type">RawInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> vector <span class="type">VectorInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> partial_vector <span class="type">VectorInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> bool <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> choice <span class="type">ChoiceInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> enum <span class="type">EnumInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> error <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> float <span class="type">FloatInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> func <span class="type">FuncInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> result <span class="type">ResultInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> option <span class="type">OptionInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ptr <span class="type">PointerInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ref <span class="type">PointerInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> borrow <span class="type">BorrowInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> struct <span class="type">StructInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> cstruct <span class="type">CStructInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> cunion <span class="type">CUnionInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> trait <span class="type">TraitInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> borrow_trait <span class="type">BorrowTraitInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> ref_trait <span class="type">RefTraitInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> dyn_trait <span class="type">DynTraitInfo</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> type <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> void <span class="type">void</span></code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> never <span class="type">void</span></code><br /></blockquote><blockquote id="decl829" class="type"><code><span class="keyword">type</span> <span class="decl">VectorInfo</span> <span class="keyword">struct</span></code><br/></blockquote><h1 id="cli"><code><span class="keyword">mod</span> <span class="decl">cli</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl868"><span class="keyword">fn</span> repl</a></code></div></div><div><div><code><a href="#decl869"><span class="keyword">fn</span> replReadLine</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl870"><span class="keyword">fn</span> replReadLine_</a></code></div></div><div><div></div></div></td></tr></tbody></table><blockquote id="decl868"><code><span class="keyword">fn</span> <span class="decl">repl</span>() -> <span class="type">void</span></code><br />Starts an isolated REPL session. Invokes `cy.repl(replReadLine)`.</blockquote><blockquote id="decl869"><code><span class="keyword">fn</span> <span class="decl">replReadLine</span>(prefix <span class="type">str</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl870"><code><span class="keyword">fn</span> <span class="decl">replReadLine_</span>(prefix <span class="type">str</span>) -> <span class="type">Future[str]</span></code><br /></blockquote><h1 id="libc"><code><span class="keyword">mod</span> <span class="decl">libc</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl909"><span class="keyword">const</span> EACCES</a></code></div><div><code><a href="#decl908"><span class="keyword">const</span> EBADF</a></code></div><div><code><a href="#decl910"><span class="keyword">const</span> EFAULT</a></code></div><div><code><a href="#decl911"><span class="keyword">const</span> EINVAL</a></code></div><div><code><a href="#decl907"><span class="keyword">const</span> ENOENT</a></code></div><div><code><a href="#decl906"><span class="keyword">const</span> EPERM</a></code></div><div><code><a href="#decl898"><span class="keyword">const</span> O_CLOEXEC</a></code></div><div><code><a href="#decl896"><span class="keyword">const</span> O_CREAT</a></code></div><div><code><a href="#decl899"><span class="keyword">const</span> O_DIRECTORY</a></code></div><div><code><a href="#decl895"><span class="keyword">const</span> O_NONBLOCK</a></code></div><div><code><a href="#decl892"><span class="keyword">const</span> O_RDONLY</a></code></div><div><code><a href="#decl894"><span class="keyword">const</span> O_RDWR</a></code></div><div><code><a href="#decl897"><span class="keyword">const</span> O_TRUNC</a></code></div><div><code><a href="#decl893"><span class="keyword">const</span> O_WRONLY</a></code></div><div><code><a href="#decl901"><span class="keyword">const</span> PATH_MAX</a></code></div><div><code><a href="#decl913"><span class="keyword">const</span> SEEK_CUR</a></code></div></div><div><div><code><a href="#decl914"><span class="keyword">const</span> SEEK_END</a></code></div><div><code><a href="#decl912"><span class="keyword">const</span> SEEK_SET</a></code></div><div><code><a href="#decl905"><span class="keyword">global</span> errno</a></code></div><div><code><a href="#decl915"><span class="keyword">fn</span> access</a></code></div><div><code><a href="#decl916"><span class="keyword">fn</span> chdir</a></code></div><div><code><a href="#decl917"><span class="keyword">fn</span> clock_gettime</a></code></div><div><code><a href="#decl918"><span class="keyword">fn</span> close</a></code></div><div><code><a href="#decl919"><span class="keyword">fn</span> exit</a></code></div><div><code><a href="#decl920"><span class="keyword">fn</span> fclose</a></code></div><div><code><a href="#decl921"><span class="keyword">fn</span> fcntl</a></code></div><div><code><a href="#decl922"><span class="keyword">fn</span> feof</a></code></div><div><code><a href="#decl923"><span class="keyword">fn</span> ferror</a></code></div><div><code><a href="#decl924"><span class="keyword">fn</span> fopen</a></code></div><div><code><a href="#decl925"><span class="keyword">fn</span> fread</a></code></div><div><code><a href="#decl926"><span class="keyword">fn</span> free</a></code></div><div><code><a href="#decl927"><span class="keyword">fn</span> fstat</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl928"><span class="keyword">fn</span> fwrite</a></code></div><div><code><a href="#decl929"><span class="keyword">fn</span> getcwd</a></code></div><div><code><a href="#decl930"><span class="keyword">fn</span> getenv</a></code></div><div><code><a href="#decl931"><span class="keyword">fn</span> lseek</a></code></div><div><code><a href="#decl932"><span class="keyword">fn</span> malloc</a></code></div><div><code><a href="#decl933"><span class="keyword">fn</span> mkdir</a></code></div><div><code><a href="#decl934"><span class="keyword">fn</span> nanosleep</a></code></div><div><code><a href="#decl935"><span class="keyword">fn</span> open</a></code></div><div><code><a href="#decl936"><span class="keyword">fn</span> printf</a></code></div><div><code><a href="#decl937"><span class="keyword">fn</span> read</a></code></div><div><code><a href="#decl938"><span class="keyword">fn</span> readlink</a></code></div><div><code><a href="#decl939"><span class="keyword">fn</span> rmdir</a></code></div><div><code><a href="#decl940"><span class="keyword">fn</span> setenv</a></code></div><div><code><a href="#decl941"><span class="keyword">fn</span> stat</a></code></div><div><code><a href="#decl942"><span class="keyword">fn</span> unlink</a></code></div><div><code><a href="#decl943"><span class="keyword">fn</span> unsetenv</a></code></div></div><div><div><div><code><a href="#decl944"><span class="keyword">fn</span> write</a></code></div><div><code><a href="#decl882"><span class="keyword">type</span> c_int =</a></code></div><div><code><a href="#decl886"><span class="keyword">type</span> clockid_t =</a></code></div><div><code><a href="#decl889"><span class="keyword">type</span> cpu_set_t =</a></code></div><div><code><a href="#decl887"><span class="keyword">type</span> fd_t =</a></code></div><div><code><a href="#decl883"><span class="keyword">type</span> FILE =</a></code></div><div><code><a href="#decl890"><span class="keyword">type</span> mode_t =</a></code></div><div><code><a href="#decl891"><span class="keyword">type</span> O =</a></code></div><div><code><a href="#decl900"><span class="keyword">type</span> off_t =</a></code></div><div><code><a href="#decl888"><span class="keyword">type</span> pid_t =</a></code></div><div><code><a href="#decl880"><span class="keyword">type</span> size_t =</a></code></div><div><code><a href="#decl881"><span class="keyword">type</span> ssize_t =</a></code></div><div><code><a href="#decl902"><span class="keyword">type</span> Stat =</a></code></div><div><code><a href="#decl904"><span class="keyword">type</span> timespec =</a></code></div></div></div></td></tr></tbody></table><blockquote id="decl909"><code><span class="keyword">const</span> <span class="decl">EACCES</span> = c_int(13)<br/></code></blockquote><blockquote id="decl908"><code><span class="keyword">const</span> <span class="decl">EBADF</span> = c_int(9)<br/></code></blockquote><blockquote id="decl910"><code><span class="keyword">const</span> <span class="decl">EFAULT</span> = c_int(14)<br/></code></blockquote><blockquote id="decl911"><code><span class="keyword">const</span> <span class="decl">EINVAL</span> = c_int(22)<br/></code></blockquote><blockquote id="decl907"><code><span class="keyword">const</span> <span class="decl">ENOENT</span> = c_int(2)<br/></code></blockquote><blockquote id="decl906"><code><span class="keyword">const</span> <span class="decl">EPERM</span> = c_int(1)<br/></code></blockquote><blockquote id="decl898"><code><span class="keyword">const</span> <span class="decl">O_CLOEXEC</span> <span class="type">O</span> = switch meta.system():
    case .macos => 0x1000000
    case .linux => 0x80000
    else => 0<br/></code></blockquote><blockquote id="decl896"><code><span class="keyword">const</span> <span class="decl">O_CREAT</span> <span class="type">O</span> = switch meta.system():
    case .macos => 0x0200
    case .linux => 0x0040
    else => 0<br/></code></blockquote><blockquote id="decl899"><code><span class="keyword">const</span> <span class="decl">O_DIRECTORY</span> <span class="type">O</span> = switch meta.system():
    case .macos => 0x100000
    case .linux => 0x10000
    else => 0<br/></code></blockquote><blockquote id="decl895"><code><span class="keyword">const</span> <span class="decl">O_NONBLOCK</span> <span class="type">O</span> = switch meta.system():
    case .macos => 0x0004
    case .linux => 0x0800
    else => 0<br/></code></blockquote><blockquote id="decl892"><code><span class="keyword">const</span> <span class="decl">O_RDONLY</span> <span class="type">O</span> = switch meta.system():
    case .macos => 0x0000
    case .linux => 0x0000
    else => 0<br/></code></blockquote><blockquote id="decl894"><code><span class="keyword">const</span> <span class="decl">O_RDWR</span> <span class="type">O</span> = switch meta.system():
    case .macos => 0x0002
    case .linux => 0x0002
    else => 0<br/></code></blockquote><blockquote id="decl897"><code><span class="keyword">const</span> <span class="decl">O_TRUNC</span> <span class="type">O</span> = switch meta.system():
    case .macos => 0x0400
    case .linux => 0x0200
    else => 0<br/></code></blockquote><blockquote id="decl893"><code><span class="keyword">const</span> <span class="decl">O_WRONLY</span> <span class="type">O</span> = switch meta.system():
    case .macos => 0x0001
    case .linux => 0x0001
    else => 0<br/></code></blockquote><blockquote id="decl901"><code><span class="keyword">const</span> <span class="decl">PATH_MAX</span> = switch meta.system():
    case .macos => 1024
    case .linux => 4096
    else => 0<br/></code></blockquote><blockquote id="decl913"><code><span class="keyword">const</span> <span class="decl">SEEK_CUR</span> = c_int(1)<br/></code></blockquote><blockquote id="decl914"><code><span class="keyword">const</span> <span class="decl">SEEK_END</span> = c_int(2)<br/></code></blockquote><blockquote id="decl912"><code><span class="keyword">const</span> <span class="decl">SEEK_SET</span> = c_int(0)<br/></code></blockquote><blockquote id="decl905"><code><span class="keyword">global</span> <span class="decl">errno</span> <span class="type">c_int</span><br/></code></blockquote><blockquote id="decl915"><code><span class="keyword">fn</span> <span class="decl">access</span>(pathname <span class="type">Ptr[byte]</span>, mode <span class="type">c_int</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl916"><code><span class="keyword">fn</span> <span class="decl">chdir</span>(path <span class="type">Ptr[byte]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl917"><code><span class="keyword">fn</span> <span class="decl">clock_gettime</span>(clockid <span class="type">clockid_t</span>, tp <span class="type">Ptr[timespec]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl918"><code><span class="keyword">fn</span> <span class="decl">close</span>(fd <span class="type">fd_t</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl919"><code><span class="keyword">fn</span> <span class="decl">exit</span>(status <span class="type">c_int</span>) -> <span class="type">never</span></code><br /></blockquote><blockquote id="decl920"><code><span class="keyword">fn</span> <span class="decl">fclose</span>(stream <span class="type">Ptr[FILE]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl921"><code><span class="keyword">fn</span> <span class="decl">fcntl</span>(fd <span class="type">fd_t</span>, op <span class="type">c_int</span>, arg <span class="type">c.variadic</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl922"><code><span class="keyword">fn</span> <span class="decl">feof</span>(stream <span class="type">Ptr[FILE]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl923"><code><span class="keyword">fn</span> <span class="decl">ferror</span>(stream <span class="type">Ptr[FILE]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl924"><code><span class="keyword">fn</span> <span class="decl">fopen</span>(path <span class="type">Ptr[byte]</span>, mode <span class="type">Ptr[byte]</span>) -> <span class="type">Ptr[FILE]</span></code><br /></blockquote><blockquote id="decl925"><code><span class="keyword">fn</span> <span class="decl">fread</span>(ptr <span class="type">Ptr[void]</span>, size <span class="type">size_t</span>, n <span class="type">size_t</span>, stream <span class="type">Ptr[FILE]</span>) -> <span class="type">size_t</span></code><br /></blockquote><blockquote id="decl926"><code><span class="keyword">fn</span> <span class="decl">free</span>(ptr <span class="type">Ptr[void]</span>) -> <span class="type">void</span></code><br /></blockquote><blockquote id="decl927"><code><span class="keyword">fn</span> <span class="decl">fstat</span>(fd <span class="type">fd_t</span>, statbuf <span class="type">Ptr[void]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl928"><code><span class="keyword">fn</span> <span class="decl">fwrite</span>(ptr <span class="type">Ptr[void]</span>, size <span class="type">size_t</span>, n <span class="type">size_t</span>, stream <span class="type">Ptr[FILE]</span>) -> <span class="type">size_t</span></code><br /></blockquote><blockquote id="decl929"><code><span class="keyword">fn</span> <span class="decl">getcwd</span>(buf <span class="type">Ptr[byte]</span>, size <span class="type">size_t</span>) -> <span class="type">Ptr[byte]</span></code><br /></blockquote><blockquote id="decl930"><code><span class="keyword">fn</span> <span class="decl">getenv</span>(name <span class="type">Ptr[byte]</span>) -> <span class="type">Ptr[byte]</span></code><br /></blockquote><blockquote id="decl931"><code><span class="keyword">fn</span> <span class="decl">lseek</span>(fd <span class="type">fd_t</span>, offset <span class="type">off_t</span>, whence <span class="type">c_int</span>) -> <span class="type">off_t</span></code><br /></blockquote><blockquote id="decl932"><code><span class="keyword">fn</span> <span class="decl">malloc</span>(size <span class="type">size_t</span>) -> <span class="type">Ptr[void]</span></code><br /></blockquote><blockquote id="decl933"><code><span class="keyword">fn</span> <span class="decl">mkdir</span>(pathname <span class="type">Ptr[byte]</span>, mode <span class="type">mode_t</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl934"><code><span class="keyword">fn</span> <span class="decl">nanosleep</span>(duration <span class="type">Ptr[timespec]</span>, rem <span class="type">Ptr[timespec]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl935"><code><span class="keyword">fn</span> <span class="decl">open</span>(pathname <span class="type">Ptr[byte]</span>, flags <span class="type">O</span>, mode <span class="type">c.variadic</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl936"><code><span class="keyword">fn</span> <span class="decl">printf</span>(format <span class="type">Ptr[byte]</span>, args <span class="type">c.variadic</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl937"><code><span class="keyword">fn</span> <span class="decl">read</span>(fd <span class="type">fd_t</span>, buf <span class="type">Ptr[void]</span>, count <span class="type">size_t</span>) -> <span class="type">ssize_t</span></code><br /></blockquote><blockquote id="decl938"><code><span class="keyword">fn</span> <span class="decl">readlink</span>(path <span class="type">Ptr[byte]</span>, buf <span class="type">Ptr[byte]</span>, bufsiz <span class="type">size_t</span>) -> <span class="type">ssize_t</span></code><br /></blockquote><blockquote id="decl939"><code><span class="keyword">fn</span> <span class="decl">rmdir</span>(pathname <span class="type">Ptr[byte]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl940"><code><span class="keyword">fn</span> <span class="decl">setenv</span>(name <span class="type">Ptr[byte]</span>, value <span class="type">Ptr[byte]</span>, overwrite <span class="type">c_int</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl941"><code><span class="keyword">fn</span> <span class="decl">stat</span>(pathname <span class="type">Ptr[byte]</span>, statbuf <span class="type">Ptr[Stat]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl942"><code><span class="keyword">fn</span> <span class="decl">unlink</span>(pathname <span class="type">Ptr[byte]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl943"><code><span class="keyword">fn</span> <span class="decl">unsetenv</span>(name <span class="type">Ptr[byte]</span>) -> <span class="type">c_int</span></code><br /></blockquote><blockquote id="decl944"><code><span class="keyword">fn</span> <span class="decl">write</span>(fd <span class="type">fd_t</span>, buf <span class="type">Ptr[void]</span>, count <span class="type">size_t</span>) -> <span class="type">ssize_t</span></code><br /></blockquote><blockquote id="decl882" class="type"><code><span class="keyword">type</span> <span class="decl">c_int</span> = <span class="type">c.c_int</span></code></blockquote><blockquote id="decl886" class="type"><code><span class="keyword">type</span> <span class="decl">clockid_t</span> = <span class="type">switch meta.system():
    case .macos => i32
    case .linux => r32
    else => void</span></code></blockquote><blockquote id="decl889" class="type"><code><span class="keyword">type</span> <span class="decl">cpu_set_t</span> = <span class="type">switch meta.system():
    case .linux => linux.cpu_set_t
    else => void</span></code></blockquote><blockquote id="decl887" class="type"><code><span class="keyword">type</span> <span class="decl">fd_t</span> = <span class="type">switch meta.system():
    case .macos => i32
    case .linux => i32
    case .wasi => i32
    else => void</span></code></blockquote><blockquote id="decl883" class="type"><code><span class="keyword">type</span> <span class="decl">FILE</span> = <span class="type">void</span></code></blockquote><blockquote id="decl890" class="type"><code><span class="keyword">type</span> <span class="decl">mode_t</span> = <span class="type">switch meta.system():
    case .macos => i16
    case .linux => r32
    case .wasi => r32
    else => void</span></code></blockquote><blockquote id="decl891" class="type"><code><span class="keyword">type</span> <span class="decl">O</span> = <span class="type">switch meta.system():
    case .macos => i32
    case .linux => r32
    case .wasi => r32
    else => void</span></code></blockquote><blockquote id="decl900" class="type"><code><span class="keyword">type</span> <span class="decl">off_t</span> = <span class="type">switch meta.system():
    case .macos => i64
    case .linux => i64
    else => i64</span></code></blockquote><blockquote id="decl888" class="type"><code><span class="keyword">type</span> <span class="decl">pid_t</span> = <span class="type">switch meta.system():
    case .macos => i32
    case .linux => i32
    else => void</span></code></blockquote><blockquote id="decl880" class="type"><code><span class="keyword">type</span> <span class="decl">size_t</span> = <span class="type">c.size_t</span></code></blockquote><blockquote id="decl881" class="type"><code><span class="keyword">type</span> <span class="decl">ssize_t</span> = <span class="type">c.ssize_t</span></code></blockquote><blockquote id="decl902" class="type"><code><span class="keyword">type</span> <span class="decl">Stat</span> = <span class="type">switch meta.system():
    case .macos => macos.Stat
    case .linux => linux.Stat
    else => void</span></code></blockquote><blockquote id="decl904" class="type"><code><span class="keyword">type</span> <span class="decl">timespec</span> = <span class="type">switch meta.system():
    case .macos => macos.timespec
    case .linux => linux.timespec
    case .wasi => wasi_timespec
    else => void</span></code></blockquote><h1 id="io"><code><span class="keyword">mod</span> <span class="decl">io</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl945"><span class="keyword">fn</span> indexOfNewLine</a></code></div><div><code><a href="#decl954"><span class="keyword">type</span> NextRange</a></code></div></div><div><div><code><a href="#decl946"><span class="keyword">type</span> Reader</a> (1)</code></div><div><code><a href="#decl948"><span class="keyword">type</span> Scanner</a> (6)</code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl953"><span class="keyword">type</span> ScannerNextFn =</a></code></div><div><code><a href="#decl958"><span class="keyword">type</span> SpanReader</a></code></div></div><div><div><div><code><a href="#decl959"><span class="keyword">type</span> StrReader</a> (1)</code></div><div><code><a href="#decl957"><span class="keyword">type</span> Writer</a></code></div></div></div></td></tr></tbody></table><blockquote id="decl945"><code><span class="keyword">fn</span> <span class="decl">indexOfNewLine</span>(buf <span class="type">[&]byte</span>) -> <span class="type">?int</span></code><br />SIMD accelerated.</blockquote><blockquote id="decl954" class="type"><code><span class="keyword">type</span> <span class="decl">NextRange</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl946" class="type"><code><span class="keyword">type</span> <span class="decl">Reader</span> <span class="keyword">trait</span></code><br/></blockquote><blockquote id=""><code><span class="keyword">fn</span> <span class="decl">read</span>(bytes <span class="type">[&]byte</span>) -> <span class="type">!int</span></code><br /></blockquote><blockquote id="decl947"><code><span class="keyword">fn</span> <span class="type">Reader</span> :: <span class="decl">@init</span>(s <span class="type">str</span>) -> <span class="type">StrReader</span></code><br /></blockquote><blockquote id="decl948" class="type"><code><span class="keyword">type</span> <span class="decl">Scanner</span>[T <span class="type">Reader</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl950"><code><span class="keyword">fn</span> <span class="type">Scanner</span> :: <span class="decl">@init</span>(<span class="keyword">scope</span> reader <span class="type">&%T</span>) -> <span class="keyword">scope</span> <span class="type">Scanner[T]</span></code><br /></blockquote><blockquote id="decl951"><code><span class="keyword">fn</span> <span class="type">Scanner</span> :: <span class="decl">@init</span>(<span class="keyword">scope</span> reader <span class="type">&%T</span>, buf_size <span class="type">int</span>) -> <span class="keyword">scope</span> <span class="type">Scanner[T]</span></code><br /></blockquote><blockquote id="decl949"><code><span class="keyword">const</span> <span class="type">Scanner</span> :: <span class="decl">DefaultBufferSize</span> = 8192<br/></code></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Scanner[]</span>) <span class="decl">next</span>(next_fn <span class="type">ScannerNextFn</span>) -> <span class="type">!?[]byte</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Scanner[]</span>) <span class="decl">next_line</span>() -> <span class="type">!?[]byte</span></code><br />Returns the next line that ends with `\n`, `\r`, `\r\n`, or until the EOF. The line returned does not include the new line character(s).</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Scanner[]</span>) <span class="decl">read_full</span>() -> <span class="type">!void</span></code><br /></blockquote><blockquote id="decl953" class="type"><code><span class="keyword">type</span> <span class="decl">ScannerNextFn</span> = <span class="type">fn([&]byte) -> !?NextRange</span></code></blockquote><blockquote id="decl958" class="type"><code><span class="keyword">type</span> <span class="decl">SpanReader</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl959" class="type"><code><span class="keyword">type</span> <span class="decl">StrReader</span> <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">Reader</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&StrReader</span>) <span class="decl">read</span>(buf <span class="type">[&]byte</span>) -> <span class="type">!int</span></code><br /></blockquote><blockquote id="decl957" class="type"><code><span class="keyword">type</span> <span class="decl">Writer</span> <span class="keyword">trait</span></code><br/></blockquote><blockquote id=""><code><span class="keyword">fn</span> <span class="decl">write</span>(bytes <span class="type">[&]byte</span>) -> <span class="type">!int</span></code><br /></blockquote><h1 id="math"><code><span class="keyword">mod</span> <span class="decl">math</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl989"><span class="keyword">const</span> e</a></code></div><div><code><a href="#decl990"><span class="keyword">const</span> inf</a></code></div><div><code><a href="#decl993"><span class="keyword">const</span> ln10</a></code></div><div><code><a href="#decl994"><span class="keyword">const</span> ln2</a></code></div><div><code><a href="#decl991"><span class="keyword">const</span> log10e</a></code></div><div><code><a href="#decl992"><span class="keyword">const</span> log2e</a></code></div><div><code><a href="#decl995"><span class="keyword">const</span> maxSafeInt</a></code></div><div><code><a href="#decl996"><span class="keyword">const</span> minSafeInt</a></code></div><div><code><a href="#decl997"><span class="keyword">const</span> nan</a></code></div><div><code><a href="#decl998"><span class="keyword">const</span> neginf</a></code></div><div><code><a href="#decl999"><span class="keyword">const</span> pi</a></code></div><div><code><a href="#decl1000"><span class="keyword">const</span> pi2</a></code></div><div><code><a href="#decl1001"><span class="keyword">const</span> piHalf</a></code></div><div><code><a href="#decl1002"><span class="keyword">const</span> sqrt1_2</a></code></div><div><code><a href="#decl1003"><span class="keyword">const</span> sqrt2</a></code></div><div><code><a href="#decl1004"><span class="keyword">fn</span> abs</a></code></div><div><code><a href="#decl1005"><span class="keyword">fn</span> acos</a></code></div><div><code><a href="#decl1006"><span class="keyword">fn</span> acosh</a></code></div></div><div><div><code><a href="#decl1007"><span class="keyword">fn</span> asin</a></code></div><div><code><a href="#decl1008"><span class="keyword">fn</span> asinh</a></code></div><div><code><a href="#decl1009"><span class="keyword">fn</span> atan</a></code></div><div><code><a href="#decl1010"><span class="keyword">fn</span> atan2</a></code></div><div><code><a href="#decl1011"><span class="keyword">fn</span> atanh</a></code></div><div><code><a href="#decl1012"><span class="keyword">fn</span> cbrt</a></code></div><div><code><a href="#decl1013"><span class="keyword">fn</span> ceil</a></code></div><div><code><a href="#decl1014"><span class="keyword">fn</span> clz32</a></code></div><div><code><a href="#decl1015"><span class="keyword">fn</span> copysign</a></code></div><div><code><a href="#decl1016"><span class="keyword">fn</span> cos</a></code></div><div><code><a href="#decl1017"><span class="keyword">fn</span> cos</a></code></div><div><code><a href="#decl1018"><span class="keyword">fn</span> cosh</a></code></div><div><code><a href="#decl1019"><span class="keyword">fn</span> degToRad</a></code></div><div><code><a href="#decl1020"><span class="keyword">fn</span> exp</a></code></div><div><code><a href="#decl1021"><span class="keyword">fn</span> expm1</a></code></div><div><code><a href="#decl1022"><span class="keyword">fn</span> floor</a></code></div><div><code><a href="#decl1023"><span class="keyword">fn</span> frac</a></code></div><div><code><a href="#decl1024"><span class="keyword">fn</span> hypot</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl1025"><span class="keyword">fn</span> isInf</a></code></div><div><code><a href="#decl1026"><span class="keyword">fn</span> isInt</a></code></div><div><code><a href="#decl1027"><span class="keyword">fn</span> isNaN</a></code></div><div><code><a href="#decl1028"><span class="keyword">fn</span> ln</a></code></div><div><code><a href="#decl1029"><span class="keyword">fn</span> log</a></code></div><div><code><a href="#decl1030"><span class="keyword">fn</span> log10</a></code></div><div><code><a href="#decl1031"><span class="keyword">fn</span> log1p</a></code></div><div><code><a href="#decl1032"><span class="keyword">fn</span> log2</a></code></div><div><code><a href="#decl1033"><span class="keyword">fn</span> max</a></code></div><div><code><a href="#decl1034"><span class="keyword">fn</span> max_f64</a></code></div><div><code><a href="#decl1035"><span class="keyword">fn</span> min</a></code></div><div><code><a href="#decl1036"><span class="keyword">fn</span> min_f64</a></code></div><div><code><a href="#decl1037"><span class="keyword">fn</span> mul32</a></code></div><div><code><a href="#decl1038"><span class="keyword">fn</span> pow</a></code></div><div><code><a href="#decl1039"><span class="keyword">fn</span> random</a></code></div><div><code><a href="#decl1040"><span class="keyword">fn</span> round</a></code></div><div><code><a href="#decl1041"><span class="keyword">fn</span> sign</a></code></div><div><code><a href="#decl1042"><span class="keyword">fn</span> sin</a></code></div></div><div><div><div><code><a href="#decl1043"><span class="keyword">fn</span> sin</a></code></div><div><code><a href="#decl1044"><span class="keyword">fn</span> sinh</a></code></div><div><code><a href="#decl1045"><span class="keyword">fn</span> sqrt</a></code></div><div><code><a href="#decl1046"><span class="keyword">fn</span> tan</a></code></div><div><code><a href="#decl1047"><span class="keyword">fn</span> tan</a></code></div><div><code><a href="#decl1048"><span class="keyword">fn</span> tanh</a></code></div><div><code><a href="#decl1049"><span class="keyword">fn</span> trunc</a></code></div><div><code><a href="#decl1050"><span class="keyword">type</span> Mat1x3</a> (1)</code></div><div><code><a href="#decl1055"><span class="keyword">type</span> Mat1x4</a> (1)</code></div><div><code><a href="#decl1053"><span class="keyword">type</span> Mat3</a> (1)</code></div><div><code><a href="#decl1051"><span class="keyword">type</span> Mat3x1</a></code></div><div><code><a href="#decl1058"><span class="keyword">type</span> Mat4</a> (4)</code></div><div><code><a href="#decl1056"><span class="keyword">type</span> Mat4x1</a></code></div><div><code><a href="#decl1063"><span class="keyword">type</span> Transform3D</a> (16)</code></div><div><code><a href="#decl1080"><span class="keyword">type</span> Vec2</a> (15)</code></div><div><code><a href="#decl1096"><span class="keyword">type</span> Vec3</a> (14)</code></div><div><code><a href="#decl1111"><span class="keyword">type</span> Vec4</a> (6)</code></div></div></div></td></tr></tbody></table><blockquote id="decl989"><code><span class="keyword">const</span> <span class="decl">e</span> = 2.71828182845904523536028747135266249775724709369995<br/>Euler's number and the base of natural logarithms; approximately 2.718.</code></blockquote><blockquote id="decl990"><code><span class="keyword">const</span> <span class="decl">inf</span> = as[float] 0x7ff0000000000000<br/>Infinity.</code></blockquote><blockquote id="decl993"><code><span class="keyword">const</span> <span class="decl">ln10</span> = 2.302585092994045684017991454684364208<br/>Natural logarithm of 10; approximately 2.303.</code></blockquote><blockquote id="decl994"><code><span class="keyword">const</span> <span class="decl">ln2</span> = 0.693147180559945309417232121458176568<br/>Natural logarithm of 2; approximately 0.693.</code></blockquote><blockquote id="decl991"><code><span class="keyword">const</span> <span class="decl">log10e</span> = 0.434294481903251827651128918916605082<br/>Base-10 logarithm of E; approximately 0.434.</code></blockquote><blockquote id="decl992"><code><span class="keyword">const</span> <span class="decl">log2e</span> = 1.442695040888963407359924681001892137<br/>Base-2 logarithm of E; approximately 1.443.</code></blockquote><blockquote id="decl995"><code><span class="keyword">const</span> <span class="decl">maxSafeInt</span> = 9007199254740991.0<br/>The maximum integer value that can be safely represented as a float. 2^53-1 or 9007199254740991.</code></blockquote><blockquote id="decl996"><code><span class="keyword">const</span> <span class="decl">minSafeInt</span> = -9007199254740991.0<br/>The minumum integer value that can be safely represented as a float. -(2^53-1) or -9007199254740991.</code></blockquote><blockquote id="decl997"><code><span class="keyword">const</span> <span class="decl">nan</span> = as[float] 0x7ff8000000000000<br/>Not a number. Note that nan == nan. However, if a nan came from an arithmetic operation, the comparison is undefined. Use `isNaN` instead.</code></blockquote><blockquote id="decl998"><code><span class="keyword">const</span> <span class="decl">neginf</span> = as[float] 0xfff0000000000000<br/>Negative infinity.</code></blockquote><blockquote id="decl999"><code><span class="keyword">const</span> <span class="decl">pi</span> = 3.14159265358979323846264338327950288419716939937510<br/>Ratio of a circle's circumference to its diameter; approximately 3.14159.</code></blockquote><blockquote id="decl1000"><code><span class="keyword">const</span> <span class="decl">pi2</span> = pi * 2<br/></code></blockquote><blockquote id="decl1001"><code><span class="keyword">const</span> <span class="decl">piHalf</span> = pi * 0.5<br/></code></blockquote><blockquote id="decl1002"><code><span class="keyword">const</span> <span class="decl">sqrt1_2</span> = 0.707106781186547524400844362104849039<br/>Square root of ; approximately 0.707.</code></blockquote><blockquote id="decl1003"><code><span class="keyword">const</span> <span class="decl">sqrt2</span> = 1.414213562373095048801688724209698079<br/>Square root of 2; approximately 1.414.</code></blockquote><blockquote id="decl1004"><code><span class="keyword">fn</span> <span class="decl">abs</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the absolute value of x.</blockquote><blockquote id="decl1005"><code><span class="keyword">fn</span> <span class="decl">acos</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the arccosine of x.</blockquote><blockquote id="decl1006"><code><span class="keyword">fn</span> <span class="decl">acosh</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the hyperbolic arccosine of x.</blockquote><blockquote id="decl1007"><code><span class="keyword">fn</span> <span class="decl">asin</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the arcsine of x.</blockquote><blockquote id="decl1008"><code><span class="keyword">fn</span> <span class="decl">asinh</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the hyperbolic arcsine of a number.</blockquote><blockquote id="decl1009"><code><span class="keyword">fn</span> <span class="decl">atan</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the arctangent of x.</blockquote><blockquote id="decl1010"><code><span class="keyword">fn</span> <span class="decl">atan2</span>(y <span class="type">float</span>, x <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the arctangent of the quotient of its arguments.</blockquote><blockquote id="decl1011"><code><span class="keyword">fn</span> <span class="decl">atanh</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the hyperbolic arctangent of x.</blockquote><blockquote id="decl1012"><code><span class="keyword">fn</span> <span class="decl">cbrt</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the cube root of x.</blockquote><blockquote id="decl1013"><code><span class="keyword">fn</span> <span class="decl">ceil</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the smallest integer greater than or equal to x.</blockquote><blockquote id="decl1014"><code><span class="keyword">fn</span> <span class="decl">clz32</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the number of leading zero bits of the 32-bit integer x.</blockquote><blockquote id="decl1015"><code><span class="keyword">fn</span> <span class="decl">copysign</span>(mag <span class="type">float</span>, sign <span class="type">float</span>) -> <span class="type">float</span></code><br /></blockquote><blockquote id="decl1016"><code><span class="keyword">fn</span> <span class="decl">cos</span>(x <span class="type">int</span>) -> <span class="type">float</span></code><br />Returns the cosine of x.</blockquote><blockquote id="decl1017"><code><span class="keyword">fn</span> <span class="decl">cos</span>(x <span class="type">%T</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl1018"><code><span class="keyword">fn</span> <span class="decl">cosh</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the hyperbolic cosine of x.</blockquote><blockquote id="decl1019"><code><span class="keyword">fn</span> <span class="decl">degToRad</span>(deg <span class="type">f32</span>) -> <span class="type">f32</span></code><br /></blockquote><blockquote id="decl1020"><code><span class="keyword">fn</span> <span class="decl">exp</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns e^x, where x is the argument, and e is Euler's number (2.718, the base of the natural logarithm).</blockquote><blockquote id="decl1021"><code><span class="keyword">fn</span> <span class="decl">expm1</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns subtracting 1 from exp(x).</blockquote><blockquote id="decl1022"><code><span class="keyword">fn</span> <span class="decl">floor</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the largest integer less than or equal to x.</blockquote><blockquote id="decl1023"><code><span class="keyword">fn</span> <span class="decl">frac</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the fractional or decimal part of a float value.</blockquote><blockquote id="decl1024"><code><span class="keyword">fn</span> <span class="decl">hypot</span>(a <span class="type">float</span>, b <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the square root of the sum of squares of its arguments.</blockquote><blockquote id="decl1025"><code><span class="keyword">fn</span> <span class="decl">isInf</span>(a <span class="type">float</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote id="decl1026"><code><span class="keyword">fn</span> <span class="decl">isInt</span>(a <span class="type">float</span>) -> <span class="type">bool</span></code><br />Returns true if the float has no fractional part, otherwise false.</blockquote><blockquote id="decl1027"><code><span class="keyword">fn</span> <span class="decl">isNaN</span>(a <span class="type">float</span>) -> <span class="type">bool</span></code><br />Returns whether x is not a number.</blockquote><blockquote id="decl1028"><code><span class="keyword">fn</span> <span class="decl">ln</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the natural logarithm (e; also, ) of x.</blockquote><blockquote id="decl1029"><code><span class="keyword">fn</span> <span class="decl">log</span>(x <span class="type">float</span>, y <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the logarithm of y with base x.</blockquote><blockquote id="decl1030"><code><span class="keyword">fn</span> <span class="decl">log10</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the base-10 logarithm of x.</blockquote><blockquote id="decl1031"><code><span class="keyword">fn</span> <span class="decl">log1p</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the natural logarithm (e; also ) of 1 + x for the number x.</blockquote><blockquote id="decl1032"><code><span class="keyword">fn</span> <span class="decl">log2</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the base-2 logarithm of x.</blockquote><blockquote id="decl1033"><code><span class="keyword">fn</span> <span class="decl">max</span>(a <span class="type">%T</span>, b <span class="type">T</span>) -> <span class="type">T</span></code><br />Returns the largest of two numbers.</blockquote><blockquote id="decl1034"><code><span class="keyword">fn</span> <span class="decl">max_f64</span>(a <span class="type">float</span>, b <span class="type">float</span>) -> <span class="type">float</span></code><br /></blockquote><blockquote id="decl1035"><code><span class="keyword">fn</span> <span class="decl">min</span>(a <span class="type">%T</span>, b <span class="type">T</span>) -> <span class="type">T</span></code><br />Returns the smallest of two numbers.</blockquote><blockquote id="decl1036"><code><span class="keyword">fn</span> <span class="decl">min_f64</span>(a <span class="type">float</span>, b <span class="type">float</span>) -> <span class="type">float</span></code><br /></blockquote><blockquote id="decl1037"><code><span class="keyword">fn</span> <span class="decl">mul32</span>(a <span class="type">float</span>, b <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the result of the 32-bit integer multiplication of x and y. Integer overflow is allowed.</blockquote><blockquote id="decl1038"><code><span class="keyword">fn</span> <span class="decl">pow</span>(a <span class="type">float</span>, b <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns base x to the exponent power y (that is, x^y).</blockquote><blockquote id="decl1039"><code><span class="keyword">fn</span> <span class="decl">random</span>() -> <span class="type">float</span></code><br />Returns a pseudo-random number between 0 and 1.</blockquote><blockquote id="decl1040"><code><span class="keyword">fn</span> <span class="decl">round</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the value of the number x rounded to the nearest integer.</blockquote><blockquote id="decl1041"><code><span class="keyword">fn</span> <span class="decl">sign</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the sign of the x, indicating whether x is positive, negative, or zero.</blockquote><blockquote id="decl1042"><code><span class="keyword">fn</span> <span class="decl">sin</span>(x <span class="type">int</span>) -> <span class="type">float</span></code><br />Returns the sine of x.</blockquote><blockquote id="decl1043"><code><span class="keyword">fn</span> <span class="decl">sin</span>(x <span class="type">%T</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl1044"><code><span class="keyword">fn</span> <span class="decl">sinh</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the hyperbolic sine of x.</blockquote><blockquote id="decl1045"><code><span class="keyword">fn</span> <span class="decl">sqrt</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the positive square root of x.</blockquote><blockquote id="decl1046"><code><span class="keyword">fn</span> <span class="decl">tan</span>(x <span class="type">int</span>) -> <span class="type">float</span></code><br />Returns the tangent of x.</blockquote><blockquote id="decl1047"><code><span class="keyword">fn</span> <span class="decl">tan</span>(x <span class="type">%T</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote id="decl1048"><code><span class="keyword">fn</span> <span class="decl">tanh</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the hyperbolic tangent of x.</blockquote><blockquote id="decl1049"><code><span class="keyword">fn</span> <span class="decl">trunc</span>(a <span class="type">float</span>) -> <span class="type">float</span></code><br />Returns the integer portion of x, removing any fractional digits.</blockquote><blockquote id="decl1050" class="type"><code><span class="keyword">type</span> <span class="decl">Mat1x3</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Mat1x3[]</span>) <span class="decl">`*`</span>(m <span class="type">Mat3x3</span>) -> <span class="type">Mat3x1</span></code><br /></blockquote><blockquote id="decl1055" class="type"><code><span class="keyword">type</span> <span class="decl">Mat1x4</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Mat1x4[]</span>) <span class="decl">`*`</span>(m <span class="type">Mat4[T]</span>) -> <span class="type">Mat4x1[T]</span></code><br /></blockquote><blockquote id="decl1053" class="type"><code><span class="keyword">type</span> <span class="decl">Mat3</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Mat3[]</span>) <span class="decl">`*`</span>(m <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1051" class="type"><code><span class="keyword">type</span> <span class="decl">Mat3x1</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1058" class="type"><code><span class="keyword">type</span> <span class="decl">Mat4</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1059"><code><span class="keyword">fn</span> <span class="type">Mat4[]</span> :: <span class="decl">@init</span>(inner <span class="type">[16]T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1060"><code><span class="keyword">fn</span> <span class="type">Mat4[]</span> :: <span class="decl">identity</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1061"><code><span class="keyword">fn</span> <span class="type">Mat4[]</span> :: <span class="decl">zero</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Mat4[]</span>) <span class="decl">`*`</span>(m <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1056" class="type"><code><span class="keyword">type</span> <span class="decl">Mat4x1</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1063" class="type"><code><span class="keyword">type</span> <span class="decl">Transform3D</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1064"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">@init</span>(mat <span class="type">[16]T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1065"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">@init</span>(mat <span class="type">Mat4[T]</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1066"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">identity</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1070"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">rotation</span>(x, y, z <span class="type">Vec3[T]</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1071"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">rotationX</span>(rad <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1072"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">rotationY</span>(rad <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1073"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">rotationZ</span>(rad <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1074"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">scaling</span>(x, y <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1075"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">scaling</span>(x, y, z <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1068"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">translation</span>(x, y <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1069"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">translation</span>(x, y, z <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1067"><code><span class="keyword">fn</span> <span class="type">Transform3D[]</span> :: <span class="decl">zero</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Transform3D[]</span>) <span class="decl">`*`</span>(x <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Transform3D[]</span>) <span class="decl">scale</span>(x <span class="type">f32</span>, y <span class="type">f32</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Transform3D[]</span>) <span class="decl">scale</span>(x <span class="type">f32</span>, y <span class="type">f32</span>, z <span class="type">f32</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Transform3D[]</span>) <span class="decl">translate</span>(x <span class="type">f32</span>, y <span class="type">f32</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1080" class="type"><code><span class="keyword">type</span> <span class="decl">Vec2</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1083"><code><span class="keyword">fn</span> <span class="type">Vec2[]</span> :: <span class="decl">@init</span>(x, y <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1081"><code><span class="keyword">const</span> <span class="type">Vec2[]</span> :: <span class="decl">unit_x</span> = Self(1, 0)<br/></code></blockquote><blockquote id="decl1082"><code><span class="keyword">const</span> <span class="type">Vec2[]</span> :: <span class="decl">unit_y</span> = Self(0, 1)<br/></code></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">`*`</span>(scale <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">`*`</span>(v <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">`+`</span>(v <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">`-`</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">`-`</span>(v <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">`/`</span>(scale <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">cross</span>(v <span class="type">Self</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">dot</span>(v <span class="type">Self</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">len</span>() -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">lenSq</span>() -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">normalize</span>() -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec2[]</span>) <span class="decl">scaleTo</span>(len <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1096" class="type"><code><span class="keyword">type</span> <span class="decl">Vec3</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1100"><code><span class="keyword">fn</span> <span class="type">Vec3[]</span> :: <span class="decl">@init</span>(x, y, z <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1097"><code><span class="keyword">const</span> <span class="type">Vec3[]</span> :: <span class="decl">unit_x</span> = Self(1, 0, 0)<br/></code></blockquote><blockquote id="decl1098"><code><span class="keyword">const</span> <span class="type">Vec3[]</span> :: <span class="decl">unit_y</span> = Self(0, 1, 0)<br/></code></blockquote><blockquote id="decl1099"><code><span class="keyword">const</span> <span class="type">Vec3[]</span> :: <span class="decl">unit_z</span> = Self(0, 0, 1)<br/></code></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">`*`</span>(s <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">`+`</span>(v <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">`+`</span>(v <span class="type">Self</span>, x, y, z <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">cross</span>(v <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">dot</span>(v <span class="type">Self</span>) -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">len</span>() -> <span class="type">T</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">lerp</span>(v <span class="type">Self</span>, tt <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">normalize</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">rotateAxis</span>(axis <span class="type">Self</span>, rad <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec3[]</span>) <span class="decl">rotateY</span>(rad <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote id="decl1111" class="type"><code><span class="keyword">type</span> <span class="decl">Vec4</span>[T <span class="type">Any</span>] <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1112"><code><span class="keyword">fn</span> <span class="type">Vec4[]</span> :: <span class="decl">@init</span>(x, y, z, w <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec4[]</span>) <span class="decl">`*`</span>(s <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec4[]</span>) <span class="decl">`+`</span>(v <span class="type">Self</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec4[]</span>) <span class="decl">`/`</span>(s <span class="type">T</span>) -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec4[]</span>) <span class="decl">divW</span>() -> <span class="type">Self</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">Vec4[]</span>) <span class="decl">dot</span>(v <span class="type">Self</span>) -> <span class="type">T</span></code><br /></blockquote><h1 id="os"><code><span class="keyword">mod</span> <span class="decl">os</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl1135"><span class="keyword">const</span> AccessExecute</a></code></div><div><code><a href="#decl1132"><span class="keyword">const</span> AccessExists</a></code></div><div><code><a href="#decl1133"><span class="keyword">const</span> AccessRead</a></code></div><div><code><a href="#decl1134"><span class="keyword">const</span> AccessWrite</a></code></div><div><code><a href="#decl1137"><span class="keyword">const</span> DefaultDirMode</a></code></div><div><code><a href="#decl1138"><span class="keyword">const</span> DefaultFileMode</a></code></div><div><code><a href="#decl1140"><span class="keyword">const</span> ns_per_ms</a></code></div><div><code><a href="#decl1141"><span class="keyword">const</span> ns_per_s</a></code></div><div><code><a href="#decl1139"><span class="keyword">const</span> ns_per_us</a></code></div><div><code><a href="#decl1128"><span class="keyword">global</span> vecBitSize</a></code></div><div><code><a href="#decl1144"><span class="keyword">fn</span> _args</a></code></div><div><code><a href="#decl1142"><span class="keyword">fn</span> accessFile</a></code></div><div><code><a href="#decl1143"><span class="keyword">fn</span> args</a></code></div><div><code><a href="#decl1145"><span class="keyword">fn</span> baseName</a></code></div><div><code><a href="#decl1146"><span class="keyword">fn</span> cacheUrl</a></code></div><div><code><a href="#decl1152"><span class="keyword">fn</span> chdir</a></code></div><div><code><a href="#decl1147"><span class="keyword">fn</span> copy_file</a></code></div><div><code><a href="#decl1148"><span class="keyword">fn</span> createDir</a></code></div></div><div><div><code><a href="#decl1149"><span class="keyword">fn</span> createFile</a></code></div><div><code><a href="#decl1150"><span class="keyword">fn</span> createFile</a></code></div><div><code><a href="#decl1151"><span class="keyword">fn</span> cwd</a></code></div><div><code><a href="#decl1153"><span class="keyword">fn</span> dirname</a></code></div><div><code><a href="#decl1154"><span class="keyword">fn</span> exec</a></code></div><div><code><a href="#decl1156"><span class="keyword">fn</span> exit</a></code></div><div><code><a href="#decl1157"><span class="keyword">fn</span> fetchUrl</a></code></div><div><code><a href="#decl1158"><span class="keyword">fn</span> fileExists</a></code></div><div><code><a href="#decl1159"><span class="keyword">fn</span> fileInfo</a></code></div><div><code><a href="#decl1160"><span class="keyword">fn</span> fileInfo</a></code></div><div><code><a href="#decl1161"><span class="keyword">fn</span> free</a></code></div><div><code><a href="#decl1162"><span class="keyword">fn</span> fromErrno</a></code></div><div><code><a href="#decl1163"><span class="keyword">fn</span> get_env</a></code></div><div><code><a href="#decl1164"><span class="keyword">fn</span> getEnvAll</a></code></div><div><code><a href="#decl1165"><span class="keyword">fn</span> malloc</a></code></div><div><code><a href="#decl1169"><span class="keyword">fn</span> nanoTime</a></code></div><div><code><a href="#decl1170"><span class="keyword">fn</span> now</a></code></div><div><code><a href="#decl1166"><span class="keyword">fn</span> num_cpus</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl1167"><span class="keyword">fn</span> open_dir</a></code></div><div><code><a href="#decl1168"><span class="keyword">fn</span> open_dir</a></code></div><div><code><a href="#decl1171"><span class="keyword">fn</span> open_file</a></code></div><div><code><a href="#decl1172"><span class="keyword">fn</span> open_file</a></code></div><div><code><a href="#decl1220"><span class="keyword">fn</span> openLib</a></code></div><div><code><a href="#decl1173"><span class="keyword">fn</span> parseArgs</a></code></div><div><code><a href="#decl1174"><span class="keyword">fn</span> read_file</a></code></div><div><code><a href="#decl1175"><span class="keyword">fn</span> read_file_str</a></code></div><div><code><a href="#decl1176"><span class="keyword">fn</span> removeDir</a></code></div><div><code><a href="#decl1177"><span class="keyword">fn</span> removeFile</a></code></div><div><code><a href="#decl1178"><span class="keyword">fn</span> resolve_exe_path</a></code></div><div><code><a href="#decl1179"><span class="keyword">fn</span> resolve_path</a></code></div><div><code><a href="#decl1180"><span class="keyword">fn</span> set_env</a></code></div><div><code><a href="#decl1181"><span class="keyword">fn</span> sleep</a></code></div><div><code><a href="#decl1129"><span class="keyword">fn</span> stderr</a></code></div><div><code><a href="#decl1130"><span class="keyword">fn</span> stdin</a></code></div><div><code><a href="#decl1131"><span class="keyword">fn</span> stdout</a></code></div><div><code><a href="#decl1182"><span class="keyword">fn</span> unset_env</a></code></div></div><div><div><div><code><a href="#decl1183"><span class="keyword">fn</span> write_file</a></code></div><div><code><a href="#decl1184"><span class="keyword">fn</span> write_file</a></code></div><div><code><a href="#decl1136"><span class="keyword">type</span> AccessMode =</a></code></div><div><code><a href="#decl1185"><span class="keyword">type</span> ArgOption</a></code></div><div><code><a href="#decl1186"><span class="keyword">type</span> ArgsResult</a> (4)</code></div><div><code><a href="#decl1126"><span class="keyword">type</span> c_int =</a></code></div><div><code><a href="#decl1207"><span class="keyword">type</span> Dir</a> (5)</code></div><div><code><a href="#decl1218"><span class="keyword">type</span> DirEntry</a></code></div><div><code><a href="#decl1213"><span class="keyword">type</span> DirIterator</a> (1)</code></div><div><code><a href="#decl1217"><span class="keyword">type</span> DirIteratorImpl =</a></code></div><div><code><a href="#decl1215"><span class="keyword">type</span> DirIteratorStub</a> (1)</code></div><div><code><a href="#decl1219"><span class="keyword">type</span> DynLib</a></code></div><div><code><a href="#decl1155"><span class="keyword">type</span> ExecResult</a></code></div><div><code><a href="#decl1191"><span class="keyword">type</span> File</a> (15)</code></div><div><code><a href="#decl1127"><span class="keyword">type</span> FileHandle =</a></code></div><div><code><a href="#decl1221"><span class="keyword">type</span> FileInfo</a></code></div><div><code><a href="#decl1222"><span class="keyword">type</span> FileKind</a></code></div><div><code><a href="#decl1223"><span class="keyword">type</span> OpenMode</a></code></div></div></div></td></tr></tbody></table><blockquote id="decl1135"><code><span class="keyword">const</span> <span class="decl">AccessExecute</span> = c_int(1)<br/></code></blockquote><blockquote id="decl1132"><code><span class="keyword">const</span> <span class="decl">AccessExists</span> = c_int(0)<br/></code></blockquote><blockquote id="decl1133"><code><span class="keyword">const</span> <span class="decl">AccessRead</span> = c_int(4)<br/></code></blockquote><blockquote id="decl1134"><code><span class="keyword">const</span> <span class="decl">AccessWrite</span> = c_int(2)<br/></code></blockquote><blockquote id="decl1137"><code><span class="keyword">const</span> <span class="decl">DefaultDirMode</span> <span class="type">lc.mode_t</span> = switch meta.system():
    case .macos => 0o755
    case .linux => 0o755
    else => 0<br/>Default mode when creating a directory.</code></blockquote><blockquote id="decl1138"><code><span class="keyword">const</span> <span class="decl">DefaultFileMode</span> = switch meta.system():
    case .macos => lc.mode_t(0o666)
    case .linux => lc.mode_t(0o666)
    else => 0<br/>Default mode when creating a file.</code></blockquote><blockquote id="decl1140"><code><span class="keyword">const</span> <span class="decl">ns_per_ms</span> = 1000 * ns_per_us<br/></code></blockquote><blockquote id="decl1141"><code><span class="keyword">const</span> <span class="decl">ns_per_s</span> = 1000 * ns_per_ms<br/></code></blockquote><blockquote id="decl1139"><code><span class="keyword">const</span> <span class="decl">ns_per_us</span> = 1000<br/></code></blockquote><blockquote id="decl1128"><code><span class="keyword">global</span> <span class="decl">vecBitSize</span> <span class="type">int</span><br/>Default SIMD vector bit size.</code></blockquote><blockquote id="decl1144"><code><span class="keyword">fn</span> <span class="decl">_args</span>(buffer_t <span class="type">int</span>) -> <span class="type">[]str</span></code><br /></blockquote><blockquote id="decl1142"><code><span class="keyword">fn</span> <span class="decl">accessFile</span>(path <span class="type">str</span>, mode <span class="type">AccessMode</span>) -> <span class="type">!void</span></code><br />Attempts to access a file at the given `path` with `mode`.</blockquote><blockquote id="decl1143"><code><span class="keyword">fn</span> <span class="decl">args</span>() -> <span class="type">[]str</span></code><br />Returns the command line arguments.</blockquote><blockquote id="decl1145"><code><span class="keyword">fn</span> <span class="decl">baseName</span>(path <span class="type">str</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote id="decl1146"><code><span class="keyword">fn</span> <span class="decl">cacheUrl</span>(url <span class="type">str</span>) -> <span class="type">str</span></code><br />Returns the path of a locally cached file of `url`. If no such file exists locally, it's fetched from `url`.</blockquote><blockquote id="decl1152"><code><span class="keyword">fn</span> <span class="decl">chdir</span>(path <span class="type">str</span>) -> <span class="type">!void</span></code><br />Change the current working directory.</blockquote><blockquote id="decl1147"><code><span class="keyword">fn</span> <span class="decl">copy_file</span>(src_path <span class="type">str</span>, dst_path <span class="type">str</span>) -> <span class="type">!void</span></code><br />Copies a file to a destination path.</blockquote><blockquote id="decl1148"><code><span class="keyword">fn</span> <span class="decl">createDir</span>(path <span class="type">str</span>) -> <span class="type">!void</span></code><br />Creates the directory at `path`.</blockquote><blockquote id="decl1149"><code><span class="keyword">fn</span> <span class="decl">createFile</span>(path <span class="type">str</span>) -> <span class="type">!File</span></code><br /></blockquote><blockquote id="decl1150"><code><span class="keyword">fn</span> <span class="decl">createFile</span>(path <span class="type">str</span>, truncate <span class="type">bool</span>) -> <span class="type">!File</span></code><br />Creates and opens the file at `path`. If `truncate` is true, an existing file will be truncated.</blockquote><blockquote id="decl1151"><code><span class="keyword">fn</span> <span class="decl">cwd</span>() -> <span class="type">!str</span></code><br />Returns the current working directory.</blockquote><blockquote id="decl1153"><code><span class="keyword">fn</span> <span class="decl">dirname</span>(path <span class="type">str</span>) -> <span class="type">?str</span></code><br />Returns the given path with its last component removed.</blockquote><blockquote id="decl1154"><code><span class="keyword">fn</span> <span class="decl">exec</span>(args <span class="type">[]str</span>) -> <span class="type">ExecResult</span></code><br />Runs a shell command and returns the stdout/stderr.</blockquote><blockquote id="decl1156"><code><span class="keyword">fn</span> <span class="decl">exit</span>(status <span class="type">int</span>) -> <span class="type">never</span></code><br />Exits the program with a status code.</blockquote><blockquote id="decl1157"><code><span class="keyword">fn</span> <span class="decl">fetchUrl</span>(url <span class="type">str</span>) -> <span class="type">str</span></code><br />Fetches the contents at `url` using the HTTP GET request method.</blockquote><blockquote id="decl1158"><code><span class="keyword">fn</span> <span class="decl">fileExists</span>(path <span class="type">str</span>) -> <span class="type">bool</span></code><br />Checks whether the file at the given `path` exists.</blockquote><blockquote id="decl1159"><code><span class="keyword">fn</span> <span class="decl">fileInfo</span>(path <span class="type">str</span>) -> <span class="type">!FileInfo</span></code><br /></blockquote><blockquote id="decl1160"><code><span class="keyword">fn</span> <span class="decl">fileInfo</span>(stat <span class="type">Ptr[lc.Stat]</span>) -> <span class="type">FileInfo</span></code><br /></blockquote><blockquote id="decl1161"><code><span class="keyword">fn</span> <span class="decl">free</span>(ptr <span class="type">Ptr[void]</span>) </code><br />Frees the memory located at `ptr`.</blockquote><blockquote id="decl1162"><code><span class="keyword">fn</span> <span class="decl">fromErrno</span>() -> <span class="type">error</span></code><br /></blockquote><blockquote id="decl1163"><code><span class="keyword">fn</span> <span class="decl">get_env</span>(key <span class="type">str</span>) -> <span class="type">?str</span></code><br />Returns an environment variable by key.</blockquote><blockquote id="decl1164"><code><span class="keyword">fn</span> <span class="decl">getEnvAll</span>() -> <span class="type">^Map[str, str]</span></code><br />Returns all environment variables as a map.</blockquote><blockquote id="decl1165"><code><span class="keyword">fn</span> <span class="decl">malloc</span>(size <span class="type">int</span>) -> <span class="type">!Ptr[void]</span></code><br />Allocates `size` bytes of memory and returns a pointer.</blockquote><blockquote id="decl1169"><code><span class="keyword">fn</span> <span class="decl">nanoTime</span>() -> <span class="type">!int</span></code><br />Returns the current time in nanoseconds since the Epoch.</blockquote><blockquote id="decl1170"><code><span class="keyword">fn</span> <span class="decl">now</span>() -> <span class="type">!int</span></code><br />High resolution timestamp. Returns a relative up-time in nanoseconds.</blockquote><blockquote id="decl1166"><code><span class="keyword">fn</span> <span class="decl">num_cpus</span>() -> <span class="type">int</span></code><br />Returns the number of CPU cores on the current machine.</blockquote><blockquote id="decl1167"><code><span class="keyword">fn</span> <span class="decl">open_dir</span>(path <span class="type">str</span>) -> <span class="type">!Dir</span></code><br /></blockquote><blockquote id="decl1168"><code><span class="keyword">fn</span> <span class="decl">open_dir</span>(path <span class="type">str</span>, iterable <span class="type">bool</span>) -> <span class="type">!Dir</span></code><br />Opens a directory at the given `path`. `iterable` indicates that the directory's entries can be iterated.</blockquote><blockquote id="decl1171"><code><span class="keyword">fn</span> <span class="decl">open_file</span>(path <span class="type">str</span>) -> <span class="type">!File</span></code><br /></blockquote><blockquote id="decl1172"><code><span class="keyword">fn</span> <span class="decl">open_file</span>(path <span class="type">str</span>, mode <span class="type">OpenMode</span>) -> <span class="type">!File</span></code><br />Opens a file at the given `path` with an `OpenMode`.</blockquote><blockquote id="decl1220"><code><span class="keyword">fn</span> <span class="decl">openLib</span>(path <span class="type">?str</span>) -> <span class="type">DynLib</span></code><br />Creates a handle to a dynamic library.</blockquote><blockquote id="decl1173"><code><span class="keyword">fn</span> <span class="decl">parseArgs</span>(opts <span class="type">[]str</span>) -> <span class="type">ArgsResult</span></code><br />Returns a result that can be used to query args. `opts`: The name of options to match excluding the hyphen prefix. eg. `-path`</blockquote><blockquote id="decl1174"><code><span class="keyword">fn</span> <span class="decl">read_file</span>(path <span class="type">str</span>) -> <span class="type">![]byte</span></code><br />Reads the file contents from `path`.</blockquote><blockquote id="decl1175"><code><span class="keyword">fn</span> <span class="decl">read_file_str</span>(path <span class="type">str</span>) -> <span class="type">!str</span></code><br /></blockquote><blockquote id="decl1176"><code><span class="keyword">fn</span> <span class="decl">removeDir</span>(path <span class="type">str</span>) -> <span class="type">!void</span></code><br />Removes an empty directory at `path`.</blockquote><blockquote id="decl1177"><code><span class="keyword">fn</span> <span class="decl">removeFile</span>(path <span class="type">str</span>) -> <span class="type">!void</span></code><br />Removes the file at `path`.</blockquote><blockquote id="decl1178"><code><span class="keyword">fn</span> <span class="decl">resolve_exe_path</span>() -> <span class="type">!str</span></code><br />Returns the current executable's path.</blockquote><blockquote id="decl1179"><code><span class="keyword">fn</span> <span class="decl">resolve_path</span>(path <span class="type">str</span>) -> <span class="type">!str</span></code><br />Returns the absolute path of the given path.</blockquote><blockquote id="decl1180"><code><span class="keyword">fn</span> <span class="decl">set_env</span>(key <span class="type">str</span>, val <span class="type">str</span>) -> <span class="type">!void</span></code><br />Sets an environment variable by key.</blockquote><blockquote id="decl1181"><code><span class="keyword">fn</span> <span class="decl">sleep</span>(nsecs <span class="type">int</span>) -> <span class="type">!void</span></code><br />Pauses the current thread for `nsecs` nanoseconds.</blockquote><blockquote id="decl1129"><code><span class="keyword">fn</span> <span class="decl">stderr</span>() -> <span class="type">File</span></code><br />Returns the standard error handle.</blockquote><blockquote id="decl1130"><code><span class="keyword">fn</span> <span class="decl">stdin</span>() -> <span class="type">File</span></code><br />Returns the standard input handle.</blockquote><blockquote id="decl1131"><code><span class="keyword">fn</span> <span class="decl">stdout</span>() -> <span class="type">File</span></code><br />Returns the standard output handle.</blockquote><blockquote id="decl1182"><code><span class="keyword">fn</span> <span class="decl">unset_env</span>(key <span class="type">str</span>) -> <span class="type">!void</span></code><br />Removes an environment variable by key.</blockquote><blockquote id="decl1183"><code><span class="keyword">fn</span> <span class="decl">write_file</span>(path <span class="type">str</span>, contents <span class="type">str</span>) -> <span class="type">!void</span></code><br />Writes `contents` as a string or bytes to a file.</blockquote><blockquote id="decl1184"><code><span class="keyword">fn</span> <span class="decl">write_file</span>(path <span class="type">str</span>, contents <span class="type">[]byte</span>) -> <span class="type">!void</span></code><br /></blockquote><blockquote id="decl1136" class="type"><code><span class="keyword">type</span> <span class="decl">AccessMode</span> = <span class="type">c_int</span></code></blockquote><blockquote id="decl1185" class="type"><code><span class="keyword">type</span> <span class="decl">ArgOption</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1186" class="type"><code><span class="keyword">type</span> <span class="decl">ArgsResult</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArgsResult</span>) <span class="decl">at</span>(name <span class="type">str</span>) -> <span class="type">str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArgsResult</span>) <span class="decl">contains</span>(name <span class="type">str</span>) -> <span class="type">bool</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArgsResult</span>) <span class="decl">get</span>(name <span class="type">str</span>) -> <span class="type">?str</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&ArgsResult</span>) <span class="decl">getAll</span>(name <span class="type">str</span>) -> <span class="type">[]str</span></code><br /></blockquote><blockquote id="decl1126" class="type"><code><span class="keyword">type</span> <span class="decl">c_int</span> = <span class="type">c.c_int</span></code></blockquote><blockquote id="decl1207" class="type"><code><span class="keyword">type</span> <span class="decl">Dir</span> <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">NoCopy</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Dir</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Dir</span>) <span class="decl">close</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Dir</span>) <span class="decl">info</span>() -> <span class="type">!FileInfo</span></code><br />Returns info about the directory.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Dir</span>) <span class="decl">iterator</span>() -> <span class="type">DirIterator</span></code><br />Returns a new iterator over the directory entries. If this directory was not opened with the iterable flag, `error.NotAllowed` is returned instead.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&Dir</span>) <span class="decl">walk</span>() -> <span class="type">DirIterator</span></code><br />Returns a new iterator over the directory recursive entries. If this directory was not opened with the iterable flag, `error.NotAllowed` is returned instead.</blockquote><blockquote id="decl1218" class="type"><code><span class="keyword">type</span> <span class="decl">DirEntry</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1213" class="type"><code><span class="keyword">type</span> <span class="decl">DirIterator</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&DirIterator</span>) <span class="decl">next</span>(dir <span class="type">&Dir</span>) -> <span class="type">!?DirEntry</span></code><br />Returns the next directory entry.</blockquote><blockquote id="decl1217" class="type"><code><span class="keyword">type</span> <span class="decl">DirIteratorImpl</span> = <span class="type">switch meta.system():
    case .macos => macos.DirIteratorImpl
    case .linux => linux.DirIteratorImpl
    case .windows => windows.DirIteratorImpl
    else => DirIteratorStub</span></code></blockquote><blockquote id="decl1215" class="type"><code><span class="keyword">type</span> <span class="decl">DirIteratorStub</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&DirIteratorStub</span>) <span class="decl">next</span>(dir <span class="type">&Dir</span>) -> <span class="type">!?DirEntry</span></code><br /></blockquote><blockquote id="decl1219" class="type"><code><span class="keyword">type</span> <span class="decl">DynLib</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1155" class="type"><code><span class="keyword">type</span> <span class="decl">ExecResult</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1191" class="type"><code><span class="keyword">type</span> <span class="decl">File</span> <span class="keyword">struct</span></code><br /><code>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span> <span class="decl">io.Reader</span>, <span class="decl">io.Writer</span>, <span class="decl">NoCopy</span></code><br/></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">@deinit</span>() </code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">close</span>() -> <span class="type">void</span></code><br />Closes the file handle. File ops invoked afterwards will return `error.Closed`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">info</span>() -> <span class="type">!FileInfo</span></code><br />Returns info about the file.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">read</span>(buf <span class="type">[&]byte</span>) -> <span class="type">!int</span></code><br />Returns number of bytes read. If 0 is returned, then the file has reached the end.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">read</span>(bytes <span class="type">int</span>) -> <span class="type">![]byte</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">read_all</span>() -> <span class="type">![]byte</span></code><br />Reads to the end of the file.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">read_fill</span>(as_buf <span class="type">AsSpan[byte]</span>) -> <span class="type">!int</span></code><br />Returns number of bytes read to the buffer `to`. If read bytes is less than `to.len()`, the end of file was reached.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">readLine</span>() -> <span class="type">!str</span></code><br />Reads until a new line as a `str`. For bulk line reading, consider using `Scanner.nextLine`.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">seek</span>(n <span class="type">int</span>) -> <span class="type">!void</span></code><br />Seeks the read/write position by `pos` bytes from the current position.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">seekFromEnd</span>(n <span class="type">int</span>) -> <span class="type">!void</span></code><br />Seeks the read/write position by `pos` bytes from the end. Positive `pos` is invalid.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">seekFromStart</span>(n <span class="type">int</span>) -> <span class="type">!void</span></code><br />Seeks the read/write position to `pos` bytes from the start. Negative `pos` is invalid.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">write</span>(val <span class="type">str</span>) -> <span class="type">!int</span></code><br />Writes a string to the current file position.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">write</span>(buf <span class="type">[]byte</span>) -> <span class="type">!int</span></code><br />Writes `buf` to the file and returns the number of bytes written.</blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">write_all</span>(val <span class="type">str</span>) -> <span class="type">!void</span></code><br /></blockquote><blockquote><code><span class="keyword">fn</span> (<span class="type">&File</span>) <span class="decl">write_all</span>(as_val <span class="type">AsSpan[byte]</span>) -> <span class="type">!void</span></code><br /></blockquote><blockquote id="decl1127" class="type"><code><span class="keyword">type</span> <span class="decl">FileHandle</span> = <span class="type">switch meta.system():
    case .windows => Ptr[void]
    else => lc.fd_t</span></code></blockquote><blockquote id="decl1221" class="type"><code><span class="keyword">type</span> <span class="decl">FileInfo</span> <span class="keyword">struct</span></code><br/></blockquote><blockquote id="decl1222" class="type"><code><span class="keyword">type</span> <span class="decl">FileKind</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> block_device</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> character_device</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> directory</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> named_pipe</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> sym_link</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> file</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unix_domain_socket</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> whiteout</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> door</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> event_port</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> unknown</code><br /></blockquote><blockquote id="decl1223" class="type"><code><span class="keyword">type</span> <span class="decl">OpenMode</span> <span class="keyword">enum:</span></code><br/><code>&nbsp;&nbsp;<span class="keyword">case</span> read</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> write</code><br /><code>&nbsp;&nbsp;<span class="keyword">case</span> read_write</code><br /></blockquote><h1 id="test"><code><span class="keyword">mod</span> <span class="decl">test</span></code></h1><table class="index-table"><tbody><tr><td><div class="double"><div><div><code><a href="#decl1225"><span class="keyword">fn</span> assert</a></code></div><div><code><a href="#decl1226"><span class="keyword">fn</span> eq</a></code></div><div><code><a href="#decl1228"><span class="keyword">fn</span> eq_slice</a></code></div></div><div><div><code><a href="#decl1229"><span class="keyword">fn</span> eq_span</a></code></div><div><code><a href="#decl1230"><span class="keyword">fn</span> eqNear</a></code></div><div><code><a href="#decl1231"><span class="keyword">fn</span> eqNear</a></code></div></div></div></td><td><div class="double"><div><div><code><a href="#decl1227"><span class="keyword">fn</span> eqType</a></code></div><div><code><a href="#decl1232"><span class="keyword">fn</span> fail</a></code></div><div><code><a href="#decl1233"><span class="keyword">fn</span> fail</a></code></div></div><div><div></div></div></td></tr></tbody></table><blockquote id="decl1225"><code><span class="keyword">fn</span> <span class="decl">assert</span>(pred <span class="type">bool</span>) </code><br />Panics if `pred` is `false`.</blockquote><blockquote id="decl1226"><code><span class="keyword">fn</span> <span class="decl">eq</span>(exp <span class="type">%T</span>, act <span class="type">T</span>) </code><br />Returns whether two values are equal. Panics with `error.AssertError` if types or values do not match up.</blockquote><blockquote id="decl1228"><code><span class="keyword">fn</span> <span class="decl">eq_slice</span>(exp <span class="type">[]%T</span>, act <span class="type">[]T</span>) </code><br />This will be deprecated once `eq_span` can accept `AsSpan[%T]`.</blockquote><blockquote id="decl1229"><code><span class="keyword">fn</span> <span class="decl">eq_span</span>(exp <span class="type">[&]%T</span>, act <span class="type">[&]T</span>) </code><br />Returns `true` if two spans have the same size and the elements are equal as if `eq` was called on those corresponding elements.</blockquote><blockquote id="decl1230"><code><span class="keyword">fn</span> <span class="decl">eqNear</span>(exp <span class="type">float</span>, act <span class="type">float</span>) </code><br /></blockquote><blockquote id="decl1231"><code><span class="keyword">fn</span> <span class="decl">eqNear</span>(exp <span class="type">float</span>, act <span class="type">float</span>, epsilon <span class="type">float</span>) </code><br /></blockquote><blockquote id="decl1227"><code><span class="keyword">fn</span> <span class="decl">eqType</span>(exp <span class="type">type</span>, act <span class="type">type</span>) </code><br /></blockquote><blockquote id="decl1232"><code><span class="keyword">fn</span> <span class="decl">fail</span>() </code><br /></blockquote><blockquote id="decl1233"><code><span class="keyword">fn</span> <span class="decl">fail</span>(msg <span class="type">str</span>) </code><br /></blockquote>
</main>
</body>
</html>
