<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Docs</title>
    <style>/* Global variables. */
:root {
  /* Set sans-serif & mono fonts */
  --sans-font: -apple-system, BlinkMacSystemFont, "Avenir Next", Avenir,
    "Nimbus Sans L", Roboto, "Noto Sans", "Segoe UI", Arial, Helvetica,
    "Helvetica Neue", sans-serif;
  --mono-font: Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace;

  /* Default (light) theme */
  --bg: #fff;
  --accent-bg: #f5f7ff;
  --text: #212121;
  --text-light: #585858;
  --border: #898EA4;
  --accent: #0d47a1;
  --code: #d81b60;
  --preformatted: #444;
  --marked: #ffdd33;
  --disabled: #efefef;
}

/* Dark theme */
@media (prefers-color-scheme: dark) {
  :root {
    color-scheme: dark;
    --bg: #212121;
    --accent-bg: #2b2b2b;
    --text: #dcdcdc;
    --text-light: #ababab;
    --accent: #ffb300;
    --code: #f06292;
    --preformatted: #ccc;
    --disabled: #111;
  }
  /* Add a bit of transparency so light media isn't so glaring in dark mode */
  img,
  video {
    opacity: 0.8;
  }
}

/* Reset box-sizing */
*, *::before, *::after {
  box-sizing: border-box;
}

/* Reset default appearance */
textarea,
select,
input,
progress {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

html {
  /* Set the font globally */
  font-family: var(--sans-font);
  scroll-behavior: smooth;
}

/* Make the body a nice central block */
body {
  color: var(--text);
  background-color: var(--bg);
  font-size: 1.15rem;
  line-height: 1.5;
  display: grid;
  grid-template-columns: 1fr min(45rem, 90%) 1fr;
  margin: 0;
}
body > * {
  grid-column: 2;
}

/* Make the header bg full width, but the content inline with body */
body > header {
  background-color: var(--accent-bg);
  border-bottom: 1px solid var(--border);
  text-align: center;
  padding: 0 0.5rem 2rem 0.5rem;
  grid-column: 1 / -1;
}

body > header h1 {
  max-width: 1200px;
  margin: 1rem auto;
}

body > header p {
  max-width: 40rem;
  margin: 1rem auto;
}

/* Add a little padding to ensure spacing is correct between content and header > nav */
main {
  padding-top: 1.5rem;
}

body > footer {
  margin-top: 4rem;
  padding: 2rem 1rem 1.5rem 1rem;
  color: var(--text-light);
  font-size: 0.9rem;
  text-align: center;
  border-top: 1px solid var(--border);
}

/* Format headers */
h1 {
  font-size: 3rem;
}

h2 {
  font-size: 2.6rem;
  margin-top: 3rem;
}

h3 {
  font-size: 2rem;
  margin-top: 3rem;
}

h4 {
  font-size: 1.44rem;
}

h5 {
  font-size: 1.15rem;
}

h6 {
  font-size: 0.96rem;
}

/* Prevent long strings from overflowing container */
p, h1, h2, h3, h4, h5, h6 {
  overflow-wrap: break-word;
}

/* Fix line height when title wraps */
h1,
h2,
h3 {
  line-height: 1.1;
}

/* Reduce header size on mobile */
@media only screen and (max-width: 720px) {
  h1 {
    font-size: 2.5rem;
  }

  h2 {
    font-size: 2.1rem;
  }

  h3 {
    font-size: 1.75rem;
  }

  h4 {
    font-size: 1.25rem;
  }
}

/* Format links & buttons */
a,
a:visited {
  color: var(--accent);
}

a:hover {
  text-decoration: none;
}

button,
[role="button"],
input[type="submit"],
input[type="reset"],
input[type="button"],
label[type="button"] {
  border: none;
  border-radius: 5px;
  background-color: var(--accent);
  font-size: 1rem;
  color: var(--bg);
  padding: 0.7rem 0.9rem;
  margin: 0.5rem 0;
}

button[disabled],
[role="button"][aria-disabled="true"],
input[type="submit"][disabled],
input[type="reset"][disabled],
input[type="button"][disabled],
input[type="checkbox"][disabled],
input[type="radio"][disabled],
select[disabled] {
  opacity: 0.5;
  cursor: not-allowed;
}

input:disabled,
textarea:disabled,
select:disabled {
  cursor: not-allowed;
  background-color: var(--disabled);
}

input[type="range"] {
  padding: 0;
}

/* Set the cursor to '?' on an abbreviation and style the abbreviation to show that there is more information underneath */
abbr[title] {
  cursor: help;
  text-decoration-line: underline;
  text-decoration-style: dotted;
}

button:focus,
button:enabled:hover,
[role="button"]:focus,
[role="button"]:not([aria-disabled="true"]):hover,
input[type="submit"]:focus,
input[type="submit"]:enabled:hover,
input[type="reset"]:focus,
input[type="reset"]:enabled:hover,
input[type="button"]:focus,
input[type="button"]:enabled:hover,
label[type="button"]:focus,
label[type="button"]:hover {
  filter: brightness(1.4);
  cursor: pointer;
}

/* Format navigation */
header > nav {
  font-size: 1rem;
  line-height: 2;
  padding: 1rem 0 0 0;
}

/* Use flexbox to allow items to wrap, as needed */
header > nav ul,
header > nav ol {
  align-content: space-around;
  align-items: center;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  list-style-type: none;
  margin: 0;
  padding: 0;
}

/* List items are inline elements, make them behave more like blocks */
header > nav ul li,
header > nav ol li {
  display: inline-block;
}

header > nav a,
header > nav a:visited {
  margin: 0 0.5rem 1rem 0.5rem;
  border: 1px solid var(--border);
  border-radius: 5px;
  color: var(--text);
  display: inline-block;
  padding: 0.1rem 1rem;
  text-decoration: none;
}

header > nav a:hover {
  border-color: var(--accent);
  color: var(--accent);
  cursor: pointer;
}

/* Reduce nav side on mobile */
@media only screen and (max-width: 720px) {
  header > nav a {
    border: none;
    padding: 0;
    text-decoration: underline;
    line-height: 1;
  }
}

/* Consolidate box styling */
aside, details, pre, progress {
  background-color: var(--accent-bg);
  border: 1px solid var(--border);
  border-radius: 5px;
  margin-bottom: 1rem;
}

aside {
  font-size: 1rem;
  width: 30%;
  padding: 0 15px;
  margin-left: 15px;
  float: right;
}

/* Make aside full-width on mobile */
@media only screen and (max-width: 720px) {
  aside {
    width: 100%;
    float: none;
    margin-left: 0;
  }
}

article, fieldset {
  border: 1px solid var(--border);
  padding: 1rem;
  border-radius: 5px;
  margin-bottom: 1rem;
}

article h2:first-child,
section h2:first-child {
  margin-top: 1rem;
}

section {
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 2rem 1rem;
  margin: 3rem 0;
}

/* Don't double separators when chaining sections */
section + section,
section:first-child {
  border-top: 0;
  padding-top: 0;
}

section:last-child {
  border-bottom: 0;
  padding-bottom: 0;
}

details {
  padding: 0.7rem 1rem;
}

summary {
  cursor: pointer;
  font-weight: bold;
  padding: 0.7rem 1rem;
  margin: -0.7rem -1rem;
  word-break: break-all;
}

details[open] > summary + * {
  margin-top: 0;
}

details[open] > summary {
  margin-bottom: 0.5rem;
}

details[open] > :last-child {
  margin-bottom: 0;
}

/* Format tables */
table {
  border-collapse: collapse;
  display: block;
  margin: 1.5rem 0;
  overflow: auto;
  width: 100%;
}

td,
th {
  border: 1px solid var(--border);
  text-align: left;
  padding: 0.5rem;
}

th {
  background-color: var(--accent-bg);
  font-weight: bold;
}

tr:nth-child(even) {
  /* Set every other cell slightly darker. Improves readability. */
  background-color: var(--accent-bg);
}

table caption {
  font-weight: bold;
  margin-bottom: 0.5rem;
}

/* Format forms */
textarea,
select,
input {
  font-size: inherit;
  font-family: inherit;
  padding: 0.5rem;
  margin-bottom: 0.5rem;
  color: var(--text);
  background-color: var(--bg);
  border: 1px solid var(--border);
  border-radius: 5px;
  box-shadow: none;
  max-width: 100%;
  display: inline-block;
}
label {
  display: block;
}
textarea:not([cols]) {
  width: 100%;
}

/* Add arrow to drop-down */
select:not([multiple]) {
  background-image: linear-gradient(45deg, transparent 49%, var(--text) 51%),
    linear-gradient(135deg, var(--text) 51%, transparent 49%);
  background-position: calc(100% - 15px), calc(100% - 10px);
  background-size: 5px 5px, 5px 5px;
  background-repeat: no-repeat;
  padding-right: 25px;
}

/* checkbox and radio button style */
input[type="checkbox"],
input[type="radio"] {
  vertical-align: middle;
  position: relative;
  width: min-content;
}

input[type="checkbox"] + label,
input[type="radio"] + label {
  display: inline-block;
}

input[type="radio"] {
  border-radius: 100%;
}

input[type="checkbox"]:checked,
input[type="radio"]:checked {
  background-color: var(--accent);
}

input[type="checkbox"]:checked::after {
  /* Creates a rectangle with colored right and bottom borders which is rotated to look like a check mark */
  content: " ";
  width: 0.18em;
  height: 0.32em;
  border-radius: 0;
  position: absolute;
  top: 0.05em;
  left: 0.17em;
  background-color: transparent;
  border-right: solid var(--bg) 0.08em;
  border-bottom: solid var(--bg) 0.08em;
  font-size: 1.8em;
  transform: rotate(45deg);
}
input[type="radio"]:checked::after {
  /* creates a colored circle for the checked radio button  */
  content: " ";
  width: 0.25em;
  height: 0.25em;
  border-radius: 100%;
  position: absolute;
  top: 0.125em;
  background-color: var(--bg);
  left: 0.125em;
  font-size: 32px;
}

/* Makes input fields wider on smaller screens */
@media only screen and (max-width: 720px) {
  textarea,
  select,
  input {
    width: 100%;
  }
}

/* Set a height for color input */
input[type="color"] {
  height: 2.5rem;
  padding:  0.2rem;
}

/* do not show border around file selector button */
input[type="file"] {
  border: 0;
}

/* Misc body elements */
hr {
  border: none;
  height: 1px;
  background: var(--border);
  margin: 1rem auto;
}

mark {
  padding: 2px 5px;
  border-radius: 4px;
  background-color: var(--marked);
}

img,
video {
  max-width: 100%;
  height: auto;
  border-radius: 5px;
}

figure {
  margin: 0;
  text-align: center;
}

figcaption {
  font-size: 0.9rem;
  color: var(--text-light);
  margin-bottom: 1rem;
}

blockquote {
  margin: 2rem 0 2rem 2rem;
  padding: 0.4rem 0.8rem;
  border-left: 0.35rem solid var(--accent);
  color: var(--text-light);
  font-style: italic;
}

cite {
  font-size: 0.9rem;
  color: var(--text-light);
  font-style: normal;
}

dt {
    color: var(--text-light);
}

/* Use mono font for code elements */
code,
pre,
pre span,
kbd,
samp {
  font-family: var(--mono-font);
  color: var(--code);
}

kbd {
  color: var(--preformatted);
  border: 1px solid var(--preformatted);
  border-bottom: 3px solid var(--preformatted);
  border-radius: 5px;
  padding: 0.1rem 0.4rem;
}

pre {
  padding: 1rem 1.4rem;
  max-width: 100%;
  overflow: auto;
  color: var(--preformatted);
}

/* Fix embedded code within pre */
pre code {
  color: var(--preformatted);
  background: none;
  margin: 0;
  padding: 0;
}

/* Progress bars */
/* Declarations are repeated because you */
/* cannot combine vendor-specific selectors */
progress {
  width: 100%;
}

progress:indeterminate {
  background-color: var(--accent-bg);
}

progress::-webkit-progress-bar {
  border-radius: 5px;
  background-color: var(--accent-bg);
}

progress::-webkit-progress-value {
  border-radius: 5px;
  background-color: var(--accent);
}

progress::-moz-progress-bar {
  border-radius: 5px;
  background-color: var(--accent);
  transition-property: width;
  transition-duration: 0.3s;
}

progress:indeterminate::-moz-progress-bar {
  background-color: var(--accent-bg);
}
</style>
    <style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable{color:#79c0ff}.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-code,.hljs-comment,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-pseudo,.hljs-selector-tag{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}</style>
    <style>:root {
    --bg: #0c0c0c;
    --accent-bg: #0d0707;
    --border: #614721;
/*    --text: #d2d2d2;*/
    --text: #fff;
    --text-light: #888888;
    --accent-light: #ffc57b;
/*    --header: #c4beb9;*/
    --header: #b5aea8;
    /* --accent-light: #fab760; */
    --accent: #ffa430;
    --marked: #ffa430;
    --mono-font: Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
    --keyword: #ff7d67;
    --declaration: #ffc57b;
    --type: #ffabab;

    --header-line: #333;

    --nav-width: 15em;
}

html {
    scroll-behavior: auto;
}

h1 {
    font-size: 2em;
    font-weight: normal;
    margin-top: 1.5em;
}

h2 {
    font-size: 1.5em;
    font-weight: normal;
}

h3 {
    font-weight: normal;
}

h4 {
    font-weight: normal;
}

h5 {
    font-weight: normal;
}

h6 {
    font-weight: normal;
}

h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
    opacity: 0;
    text-decoration: none
}

h1:hover a, h2:hover a, h3:hover a, h4:hover a, h5:hover a, h6:hover a {
    opacity: initial
}

h1.title {
    color: var(--accent);
    margin-bottom: 10px;
}

html, body {
    font-size: 18px;

    /* Reset to defaults */ 
    letter-spacing: normal;
    -webkit-font-smoothing: auto;
    -moz-osx-font-smoothing: auto;
    background-color: var(--bg);
    color: var(--text);
}

header ul {
    list-style-type: none;
    padding-left: 0px;
}

header a {
    white-space: nowrap;
}

body > header {
    height: 100%;
    width: var(--nav-width);
    padding-left: 40px;
    text-align: left;
    position: fixed;
    top: 0;
    left: 0;
    overflow-y: auto;
    background-color: var(--bg);
}

header ul li {
    display: list-item;
    margin-right: 0px;
}

body {
    display: block;
}

main {
    padding-top: 0px;
    padding-left: calc(var(--nav-width) + 20px);
    padding-right: 40px;
}

em {
    font-style: normal;
    color: #fb6767;
}

div.desc ul li {
    padding-bottom: 15px;
}

/* mobile */
@media screen and (max-width: 720px) {
    body {
        display: grid;
    }

    /* Make 2 column navs fit */
    table ul {
        padding-left: 20px;
    }
    table ul ul {
        padding-left: 0px;
    }
    table td {
        padding: 0.5rem 0 0.5rem 0;
    }

    body > header {
        position: static;
        padding-left: 0px;
        height: initial;
        width: initial;
        top: initial;
        left: initial;
        text-align: center;
        overflow-y: visible;
        background-color: var(--accent-bg);
    }

    main {
        padding-left: 0px;
        padding-right: 0px;
    }

    header ul {
        margin-top: 0px;
        margin-bottom: 0px;
    }

    header ul li {
        display: inline;
        margin-right: 5px;
    }
}

a.current {
    text-decoration: none;
}

h1 {
/*    color: var(--accent);*/
/*    font-weight: bold;*/
}

.markdown h2 {
    color: var(--header);
    font-weight: bold; 
    margin-top: 60px;
}

h3 {
    color: var(--header);
/*    font-weight: bold; */
    font-size: 1.2em;
    margin-top: 2.2em;

    padding: 0.5rem 1rem 0.7rem 0.75rem;
    border-bottom: 0.15rem solid var(--header-line);
    border-radius: 0rem;
}

main h2 > code {
    color: var(--header);
    font-size: 0.9em;
    background-color: transparent;
}

main h3 > code {
    color: var(--header);
    font-size: 0.9em;
    background-color: transparent;
}

.markdown table tr th {
    text-align: left;
    color: var(--text-light);
    font-weight: normal;
}

.markdown table tr th, .markdown table tr td {
    border: 3px solid #222;
}

.markdown table tr td:first-child code {
    font-size: 15px;
}

.book-search input {
    background-color: var(--bg);
    border: 3px solid #222;
}

.book-menu .book-brand a {
    color: var(--accent);
    font-weight: bold;
}

.book-menu a {
    color: var(--accent-light);
}
.book-menu a:hover {
    opacity: 1;
    color: var(--accent-light);
    text-decoration: underline;
}

.book-menu a.active {
    color: var(--accent);
    font-weight: bold;
    text-decoration: underline;
}

ul a {
    color: var(--accent-light);
}

a {
    color: var(--accent);
}

.markdown a:visited {
    color: var(--accent);
    text-decoration: underline;
}
.markdown a {
    color: var(--accent);
    text-decoration: underline;
}

:focus {
    outline-style: none;
}

/* inline code */
main code {
    font-size: 17px;
    background: none;
    color: var(--accent-light);
    padding: 2px 6px;
}

main.api code {
    color: var(--text);
}

main.api code .type {
    color: var(--type);
}
main.api code .keyword {
    color: var(--keyword);
}
main.api code .op {
    color: var(--keyword);
}
main.api code .decl {
    color: var(--declaration);
}
main.api h1 code {
    font-size: 24px;
}
main.api blockquote.type {
    border-left: 3px solid var(--type);
}

main.api table.index-table {
    table-layout: fixed;
    width: 100%;
}

main.api table.index-table td {
    vertical-align: top;
}

main.api table.index-table td div.double {
    display: flex;
    flex-direction: row;
}

main.api table.index-table td div.double div {
    flex: 1;
}

@media screen and (max-width: 1199px) {
    main.api table.index-table td div.double {
        flex-direction: column;
    }
}

main.api table.index-table code {
    font-size: 15px;
}

main.api table.index-table a {
    color: var(--declaration);
}

/* block code */
main pre code {
    font-size: 15px;
    color: var(--text);
    font-weight: normal;
    font-family: var(--mono-font);
}

pre {
/*    padding: 10px;*/
    font-size: 15px;
    border: 0px solid var(--border);
    background-color: #171717;
}

pre code.hljs {
    padding: 0px;
    white-space: pre-wrap;
}

.hljs {
/*    background-color: var(--accent-bg);*/
    background-color: transparent;
}

.hljs-params {
    color: #c9d1d9;
}

blockquote {
    margin: 20px 0 20px 0;
    font-style: normal;
    border-left: 3px solid var(--header-line);
    padding: 3px 0px 3px 15px;
    color: var(--text);
}

blockquote p:nth-child(2) {
    margin-top: 5px;
}

blockquote p {
    margin: 0px;
    padding: 0px;
}

p {
    margin-block-start: 1.3em;
    margin-block-end: 1.3em;
}

blockquote em {
    color: #fb6767;
}

table {
    font-size: 18px;
    width: auto;
    line-height: 1.5em;
    display: table;
    margin: 0 0;
}

table thead {
    border-bottom: 0.15rem solid var(--header-line);
    width: auto;
}

table th {
    border: 0px solid var(--border);
    width: auto;
    background-color: transparent;
}

table td {
    border: 0px solid var(--border);
    width: auto;
}

table tbody tr:nth-child(even) {
    background-color: #111;
}

strong {
    color: var(--accent);
}</style>
</head>
<body id="table-of-contents">
<header>
    <h1 class="title">Cyber Docs</h1>
    <div class="sub-title">v0.4-dev 497-043ea72</div>
    <ul>
        <li><a href="https://cyberscript.dev" target="_blank" rel="noopener">Homepage</a></li>
        <li><a href="api.html">API Docs</a></li>
        <li><a href="https://cyberscript.dev/play.html" target="_blank" rel="noopener">Playground</a></li>
        <li><a href="https://github.com/fubark/cyber/edit/master/docs/docs.md" target="_blank" rel="noopener">Edit Page</a></li>
    </ul>
    <div class="sub-title">Table of Contents</div>
    <ul>
        <li><a href="#introduction">Introduction.</a></li>
<li><a href="#syntax">Syntax.</a></li>
<li><a href="#basic-types">Basic types.</a></li>
<li><a href="#custom-types">Custom types.</a></li>
<li><a href="#control-flow">Control flow.</a></li>
<li><a href="#functions">Functions.</a></li>
<li><a href="#memory">Memory.</a></li>
<li><a href="#error-handling">Error handling.</a></li>
<li><a href="#concurrency">Concurrency.</a></li>
<li><a href="#metaprogramming">Metaprogramming.</a></li>
<li><a href="#modules">Modules.</a></li>
<li><a href="#ffi">FFI.</a></li>
<li><a href="#libcyber">libcyber.</a></li>
<li><a href="#cli">CLI.</a></li>
    </ul>
</header>
<main>
    <!--This does not contain module docs. Use docs.md from releases instead or generate it by using docs/gen-docs.cy -->
<h1 id="introduction">Introduction. <a href="#introduction">#</a></h1>
<p>Cyber is a safe, fast, and concurrent programming language.</p>
<p>The areas of focus for the language include:</p>
<ul>
<li>Static typing with primitives, references, structs, options, enums, choices, traits, and generic types.</li>
<li>Memory safety. Favors structured and flat memory use through borrowing and reference counting. (No garbage collector.)</li>
<li>Value ownership and deinitializers.</li>
<li>Metaprogramming with templates, inline evaluation, and compiler hooks.</li>
<li>Concurrency. Channels, futures, and <code>await</code> to synchronize green threads. Fibers and generators for cooperative coroutines.</li>
<li>Compilation ahead-of-time to C or interpeted from its virtual machine.</li>
<li>Sandbox mode that restricts the language to only safe constructs.</li>
<li>Introspection. Much of the internals such as the builtin types and runtime is written in Cyber and can be inspected from the source code or the <a href="api.html" title="">API docs</a>.</li>
</ul>
<p>These docs provide a reference manual for the language. It can be read in order or browsed from the navigation. Features that are marked <code>Incomplete</code>, <code>Planned</code>, or <code>TBD</code> have not been completed at the time of writing.</p>
<h2 id="hello-world">Hello World. <a href="#hello-world">#</a></h2>
<p>Here is a simple example that offers a sneak peek into the language:</p>
<pre><code class="language-cy">use math

nouns := []str{'World', '‰∏ñÁïå', '‡§¶‡•Å‡§®‡§ø‡§Ø‡§æ', 'mundo'}
nouns += math.random().fmt()
for nouns |n|:
    print('Hello, %{n}!')
</code></pre>
<a href="#introduction">^topic</a>
<h1 id="syntax">Syntax. <a href="#syntax">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#statements" title="">Statements.</a></li>
<li><a href="#comments" title="">Comments.</a></li>
<li><a href="#blocks" title="">Blocks.</a></li>
<li><a href="#variables" title="">Variables.</a><ul>
<li><a href="#local-variables" title="">Local variables.</a></li>
<li><a href="#var-declaration" title=""><code>var</code> declaration.</a></li>
<li><a href="#variable-scopes" title="">Variable scopes.</a></li>
<li><a href="#global-variables" title=""><code>global</code> variables.</a></li>
</ul>
</li>
<li><a href="#constants" title="">Constants.</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#reserved-identifiers" title="">Reserved identifiers.</a><ul>
<li><a href="#keywords" title="">Keywords.</a></li>
<li><a href="#contextual-keywords" title="">Contextual keywords.</a></li>
<li><a href="#literals" title="">Literals.</a></li>
</ul>
</li>
<li><a href="#operators" title="">Operators.</a><ul>
<li><a href="#arithmetic-operators" title="">Arithmetic operators.</a></li>
<li><a href="#comparison-operators" title="">Comparison operators.</a></li>
<li><a href="#logic-operators" title="">Logic operators.</a></li>
<li><a href="#bitwise-operators" title="">Bitwise operators.</a></li>
<li><a href="#operator-overloading" title="">Operator overloading.</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="statements">Statements. <a href="#statements">#</a></h2>
<p>A statement ends with the new line character:</p>
<pre><code class="language-cy">a := 123
</code></pre>
<p>Any token inside delimited parentheses, brackets, or braces, can be wrapped to the next line:</p>
<pre><code class="language-cy">sum := add(1, 2, 3, 4,
    100, 200, 300, 400)

colors := {'red', 'blue', 'green',
    'purple', 'orange', 'yellow'}
</code></pre>
<p>A statement can wrap to the next line if the last token before the new line is an operator or keyword.</p>
<pre><code class="language-cy">gameover := health <= 0 or
    player.collides_with(spikes)

if year > 2020 and year <= 2030 and
    month > 0 and month <= 11:
    print('Valid')
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="comments">Comments. <a href="#comments">#</a></h2>
<p>A single line comment starts with two hyphens and ends at the end of the line.</p>
<pre><code class="language-cy">-- This is a comment.

a := 123   -- This is a comment on the same line as a statement.
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="blocks">Blocks. <a href="#blocks">#</a></h2>
<p>Some statements can start a new block with a colon.
The first statement in a new block must be indented further.
Indentation can be spaces or tabs but not both.</p>
<pre><code class="language-cy">-- This `if` statement begins a new block.
if true:
    a := 234
</code></pre>
<p>Subsequent statements in the block must follow the same indentation.
The block ends when a statement recedes from this indentation:</p>
<pre><code class="language-cy">items := {10, 20, 30}
for items |it|:
    if it == 20:
        print(it)

    -- This is the first statement outside of the `if` block.
    print(it)
</code></pre>
<p>A block with a single statement can be written in a single line:</p>
<pre><code class="language-cy">-- A single line block.
if true: print(123)

if true: print(123)
    -- Indentation error. The `if` block already ended.
    print(234)
</code></pre>
<p>Since blocks require at least one statement, <code>pass</code> can be used as a placeholder statement:</p>
<pre><code class="language-cy">fn foo():
    pass
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="variables">Variables. <a href="#variables">#</a></h2>
<p>Variables allow values to be stored as named locations in memory.</p>
<a href="#syntax">^topic</a>
<h3 id="local-variables">Local variables. <a href="#local-variables">#</a></h3>
<p><code>:=</code> declares a variable with the type inferred from the initializer.</p>
<pre><code class="language-cy">a := 123
</code></pre>
<p>Variables can be assigned afterwards using the <code>=</code> operator:</p>
<pre><code class="language-cy">a = 234
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="var-declaration"><code>var</code> declaration. <a href="#var-declaration">#</a></h3>
<p>When a local variable is declared with <code>var</code>, a type specifier is required.
The initializer must satisfy the type constraint:</p>
<pre><code class="language-cy">-- Correct.
var a float = 123.0

-- CompileError. Expected `float`, got `str`.
var b float = 'hello'
</code></pre>
<p>Sometimes, the <code>var</code> declaration can be simpler and more readable than an equivalent <code>:=</code> declaration:</p>
<pre><code class="language-cy">var action ?str = switch color:
    case .green => 'go'
    case .red => 'stop'
    else => none
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="variable-scopes">Variable scopes. <a href="#variable-scopes">#</a></h3>
<p>Local variables exist until the end of their scope. Each block has their own variable scope.</p>
<p>Variables declared in the current scope will take precedence over any parent variables with the same name. This is also known as variable shadowing:</p>
<pre><code class="language-cy">fn foo():
    a := 234

    if true:
        -- New `a` declared.
        a := 345

        print(a) 
        --> 345

    print(a)
    --> 234
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="global-variables"><code>global</code> variables. <a href="#global-variables">#</a></h3>
<p>Global variables live until the end of the program and can be accessed from any context (unless they have a private modifier). Globals are considered <em>unsafe</em> and are forbidden in sandbox mode.</p>
<p>Global variables are declared with <code>global</code> and require a type specifier:</p>
<pre><code class="language-cy">global a int = 123

fn foo():
    print(a)    --> 123
</code></pre>
<p>The initializer of a global variable cannot reference other global variables:</p>
<pre><code class="language-cy">global a int = 123

global b int = a
--> error: Initializer can not reference a global variable.
</code></pre>
<p>However, they can be reassigned afterwards to any runtime expression:</p>
<pre><code class="language-cy">global b int = 0

b = a
</code></pre>
<p>Global variable initializers have a natural order based on when it was encountered by the compiler.
The following would invoke <code>load_a</code> before <code>load_b</code>:</p>
<pre><code class="language-cy">global a int = load_a()
global b int = load_b()
</code></pre>
<p>Circular references are not possible because a global initializer cannot reference another global variable:</p>
<pre><code class="language-cy">global a = b
--> error: Initializer can not reference a global variable.

global b = a     
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="constants">Constants. <a href="#constants">#</a></h2>
<p>Constants are declared with a const evaluated expression:</p>
<pre><code class="language-cy">const pi float = 3.14159265358979323846264338327950288419716939937510
</code></pre>
<p>The type specifier is optional and can be inferred from the expression:</p>
<pre><code class="language-cy">const empty = ''

const lib = switch meta.system():
    case .linux => 'mylib.so'
    case .windows => 'mylib.dll'
    case .macos => 'mylib.dylib'
    else => meta.unsupported()
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="reserved-identifiers">Reserved identifiers. <a href="#reserved-identifiers">#</a></h2>
<a href="#syntax">^topic</a>
<h3 id="keywords">Keywords. <a href="#keywords">#</a></h3>
<p>There are <code>23</code> general keywords. This list categorizes them:</p>
<ul>
<li><a href="#control-flow" title="">Control flow</a>: <a href="#if-statement" title=""><code>if</code></a> <a href="#if-statement" title=""><code>else</code></a> <a href="#switch-matching" title=""><code>switch</code></a> <a href="#switch-matching" title=""><code>case</code></a> <a href="#conditional-while" title=""><code>while</code></a> <a href="#for-range" title=""><code>for</code></a> <a href="#break-statement" title=""><code>break</code></a> <a href="#continue-statement" title=""><code>continue</code></a> <code>pass</code> <a href="#or-expression" title=""><code>or</code></a> <a href="#and-expression" title=""><code>and</code></a></li>
<li><a href="#operators" title="">Operators</a>: <code>not</code></li>
<li><a href="#variables" title="">Variables</a>: <a href="#local-variables" title=""><code>var</code></a> <a href="#global-variables" title=""><code>global</code></a></li>
<li><a href="#functions" title="">Functions</a>: <code>fn</code> <code>return</code></li>
<li><a href="#value-ownership" title="">Ownership</a>: <a href="#moving" title=""><code>move</code></a></li>
<li><a href="#concurrency" title="">Concurrency</a>: <a href="#generators" title=""><code>yield</code></a></li>
<li><a href="#custom-types" title="">Types</a>: <code>type</code> <code>with</code></li>
<li><a href="#error-handling" title="">Error handling</a>: <a href="#unwrap-block" title=""><code>try</code></a></li>
<li><a href="#modules" title="">Modules</a>: <code>use</code></li>
</ul>
<a href="#syntax">^topic</a>
<h3 id="contextual-keywords">Contextual keywords. <a href="#contextual-keywords">#</a></h3>
<p>These keywords only have meaning in a certain context.</p>
<ul>
<li><a href="#methods" title="">Methods</a>: <code>self</code> <code>Self</code></li>
<li><a href="#custom-types" title="">Types</a>: <a href="#structs" title=""><code>struct</code></a> <a href="#c-structs" title=""><code>cstruct</code></a> <a href="#enums" title=""><code>enum</code></a> <a href="#c-unions" title=""><code>cunion</code></a> <a href="#traits" title=""><code>trait</code></a></li>
<li><a href="#value-ownership" title="">Ownership</a>: <a href="#scope-parameter" title=""><code>scope</code></a> <a href="#sink-parameter" title=""><code>sink</code></a></li>
<li><a href="#functions" title="">Functions</a>: <code>void</code></li>
</ul>
<a href="#syntax">^topic</a>
<h3 id="literals">Literals. <a href="#literals">#</a></h3>
<ul>
<li><a href="#booleans" title="">Boolean literal</a>: <code>true</code> <code>false</code></li>
<li><a href="#error-value" title="">Error literal</a>: <code>error</code></li>
<li>None: <code>none</code></li>
<li>Undefined: <code>undef</code></li>
</ul>
<a href="#syntax">^topic</a>
<h2 id="operators">Operators. <a href="#operators">#</a></h2>
<p>The following operators are supported.
They are ordered from highest to lowest precedence.
All infix operators have left-to-right associativity and all prefix operators have the same precedence and right-to-left associativity.</p>
<table><thead><tr><th>Operator</th><th>Kind</th><th>Description</th></tr></thead><tbody><tr><td><code>()</code></td><td>special</td><td>Grouping.</td></tr><tr><td><code>.</code></td><td>infix</td><td>Accessor.</td></tr><tr><td><code>[]</code></td><td>special</td><td>Indexing.</td></tr><tr><td><code>as</code></td><td>prefix</td><td>Type casting.</td></tr><tr><td><code>!</code></td><td>prefix</td><td>Logic not.</td></tr><tr><td><code>~</code></td><td>prefix</td><td>Bitwise not.</td></tr><tr><td><code>^</code></td><td>prefix</td><td>Lift.</td></tr><tr><td><code>&</code></td><td>prefix</td><td>Borrow.</td></tr><tr><td><code>*</code></td><td>prefix</td><td>Address of.</td></tr><tr><td><code><<</code> <code>>></code></td><td>infix</td><td>Bitwise left shift, right shift.</td></tr><tr><td><code>&&</code></td><td>infix</td><td>Bitwise and.</td></tr><tr><td><code>||</code> <code>~</code></td><td>infix</td><td>Bitwise or, exclusive or.</td></tr><tr><td><code>**</code></td><td>infix</td><td>Power or repeat.</td></tr><tr><td><code>/</code> <code>%</code> <code>*</code></td><td>infix</td><td>Division, modulus, multiplication.</td></tr><tr><td><code>+</code> <code>-</code></td><td>infix</td><td>Addition, subtraction.</td></tr><tr><td><code>></code> <code>>=</code><br/><code><</code> <code><=</code></br><code>!=</code> <code>==</code></td><td>infix</td><td>Greater, greater or equal, less, less or equal, not equals, equals.</td></tr><tr><td><code>and</code></td><td>infix</td><td>Logical and.</td></tr><tr><td><code>or</code></td><td>infix</td><td>Logical or.</td></tr><tr><td><code>..</code></td><td>infix</td><td>Range.</td></tr></tbody></table><a href="#syntax">^topic</a>
<h3 id="arithmetic-operators">Arithmetic operators. <a href="#arithmetic-operators">#</a></h3>
<p>The following arithmetic operators are supported for <a href="#numbers" title="">numeric data types</a>.
Some types such as <code>math.Vec</code> and <code>math.Mat</code> also overload these operators.</p>
<pre><code class="language-cy">1 + 2     --> 3   (Addition)
100 - 10  --> 90  (Subtraction)
3 * 4     --> 12  (Multiplication)
20 / 5    --> 4   (Division)
2 ** 4    --> 16  (Power)
12 % 5    --> 2   (Modulus remainder)
-(10)     --> -10 (Negative)
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="comparison-operators">Comparison operators. <a href="#comparison-operators">#</a></h3>
<p>The following comparison operators are supported and evaluate to a <a href="#booleans" title="">Boolean</a> value.</p>
<p>The <code>==</code> equals operator returns true if the two values are equal.
Primitive values compare with their underlying bytes.
The comparison recurses for composite types.
For the <code>str</code> type, the underlying bytes are compared for equality.
For references types, the comparison checks that the two references point to the same value.</p>
<pre><code class="language-cy">1 == 1          --> true
1 == 2          --> false
1 == true       --> false

a := 'abc'
a == 'abc'      --> true

la := {1, 2, 3}
lb := la
la == lb        --> true
la == {1, 2, 3} --> false
</code></pre>
<p>The not equals operator returns true if the two values are not equal.</p>
<pre><code class="language-cy">1 != 1          --> false
1 != 2          --> true
</code></pre>
<p>Number types have additional comparison operators.</p>
<pre><code class="language-cy">a > b           --> `true` if a is greater than b
a >= b          --> `true` if a is greater than or equal to b
a < b           --> `true` if a is less than b
a <= b          --> `true` if a is less than or equal to b
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="logic-operators">Logic operators. <a href="#logic-operators">#</a></h3>
<p>The logical operators <a href="#and-expression" title=""><code>and</code></a>, <a href="#or-expression" title=""><code>or</code></a>, and <code>not</code> are supported.</p>
<p>The unary operators <code>not</code> and <code>!</code> perform negation on the boolean value:</p>
<pre><code class="language-cy">not false     --> true
not true      --> false
!false        --> true
!true         --> false
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="bitwise-operators">Bitwise operators. <a href="#bitwise-operators">#</a></h3>
<p>The following bitwise operators are supported for <code>Int</code> and <code>Raw</code> number values.</p>
<pre><code class="language-cy">-- and: any underlying bits that are set in both integers are set in the new integer.
a && b

-- or: any underlying bits that are set in either integer a or integer b are set in the new integer.
a || b

-- exclusive or: any underlying bits that are set in either integer a or integer b but not both are set in the new integer.
a ~ b

-- logical right shift: a's bits are shifted b bits to the least significant end. 
a >> b

-- logical left shift: a's bits are shifted b bits to the most significant end. This does not perform sign-extension on the 32-bit integer.
a << b

-- not: a's integer bits are flipped.
~a
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="operator-overloading">Operator overloading. <a href="#operator-overloading">#</a></h3>
<p>See <a href="#operator-methods" title="">Custom types -> Operator methods</a>.</p>
<a href="#syntax">^topic</a>
<h1 id="basic-types">Basic types. <a href="#basic-types">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#booleans" title="">Booleans.</a></li>
<li><a href="#numbers" title="">Numbers.</a><ul>
<li><a href="#integers" title="">Integers.</a></li>
<li><a href="#floats" title="">Floats.</a></li>
</ul>
</li>
<li><a href="#strings" title="">Strings.</a><ul>
<li><a href="#raw-string-literal" title="">Raw string literal.</a></li>
<li><a href="#string-literal" title="">String literal.</a></li>
<li><a href="#escape-sequences" title="">Escape sequences.</a></li>
<li><a href="#string-indexing" title="">String indexing.</a></li>
<li><a href="#string-concatenation" title="">String concatenation.</a></li>
<li><a href="#string-interpolation" title="">String interpolation.</a></li>
<li><a href="#string-formatting" title="">String formatting.</a></li>
<li><a href="#line-join-literal" title="">Line-join literal.</a></li>
<li><a href="#mutable-strings" title="">Mutable strings.</a></li>
</ul>
</li>
<li><a href="#symbols" title="">Symbols.</a></li>
<li><a href="#references" title="">References.</a></li>
</ul>
</td>
<td valign="top">
<ul>
<li><a href="#optionals" title="">Optionals.</a><ul>
<li><a href="#wrap-value" title="">Wrap value.</a></li>
<li><a href="#wrap-none" title="">Wrap <code>none</code>.</a></li>
<li><a href="#unwrap-or-panic" title="">Unwrap or panic.</a></li>
<li><a href="#unwrap-or-default" title="">Unwrap or default.</a></li>
<li><a href="#optional-chaining" title="">Optional chaining.</a></li>
<li><a href="#if-unwrap" title=""><code>if</code> unwrap.</a></li>
<li><a href="#while-unwrap" title=""><code>while</code> unwrap.</a></li>
</ul>
</li>
<li><a href="#vectors" title="">Vectors.</a><ul>
<li><a href="#partial-vectors" title="">Partial vectors.</a></li>
</ul>
</li>
<li><a href="#slices" title="">Slices.</a><ul>
<li><a href="#sub-slices" title="">Sub-slices.</a></li>
<li><a href="#slice-operations" title="">Slice operations.</a></li>
</ul>
</li>
<li><a href="#maps" title="">Maps.</a><ul>
<li><a href="#map-operations" title="">Map operations.</a></li>
</ul>
</li>
<li><a href="#implicit-casts" title="">Implicit casts.</a></li>
<li><a href="#type-casts" title="">Type casts.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>This chapter is an overview of commonly used builtin types.</p>
<h2 id="booleans">Booleans. <a href="#booleans">#</a></h2>
<p>A <code>bool</code> type can be <code>true</code> or <code>false</code>.</p>
<pre><code class="language-cy">a := true
if true:
    print('a is true')
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="numbers">Numbers. <a href="#numbers">#</a></h2>
<a href="#basic-types">^topic</a>
<h3 id="integers">Integers. <a href="#integers">#</a></h3>
<p><code>int</code> (an alias for <code>i64</code>) is the default integer type.
It's encoded as 64-bit two's complement and represents integers in the range -(2<sup>63</sup>) to 2<sup>63</sup>-1.</p>
<p>Integer types are named according to how many bits they occupy: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code></p>
<p>Raw integer types do not encode a sign bit. They include: <code>r8</code> (<code>byte</code>, <code>r16</code>, <code>r32</code>, <code>r64</code>. <code>byte</code> is an alias for <code>r8</code>.</p>
<p>While integer types are typically used for counting, raw integer types are intended to represent masks and raw memory.</p>
<p>Without a target type, a numeric literal will default to the <code>int</code> type:</p>
<pre><code class="language-cy">a := 123
</code></pre>
<p>Other integer notations include:</p>
<pre><code class="language-cy">a := 0xFF     -- Hexidecimal.
a = 0o17      -- Octal.
a = 0b1010    -- Binary.
</code></pre>
<p>String literals evaluate as their UTF-8 codepoint if the target integer type is big enough:</p>
<pre><code class="language-cy">-- Success.
var a int = 'üê∂'

-- error: Expected `byte`, found `str`.
var b byte = 'üê∂'

-- Success.
var b byte = 'a'
</code></pre>
<p>Strings and other values can be converted to a <code>int</code> using the type as a function:</p>
<pre><code class="language-cy">a := '123'
b := int(a) 
</code></pre>
<p>Integer types can perform <a href="#arithmetic-operators" title="">arithmetic</a>, <a href="#bitwise-operators" title="">bitwise</a>, and <a href="#comparison-operators" title="">comparison</a> operations.</p>
<a href="#basic-types">^topic</a>
<h3 id="floats">Floats. <a href="#floats">#</a></h3>
<p><code>float</code> (an alias for <code>f64</code>) is the default floating point type. It's encoded as 64-bit IEEE 754.</p>
<p>Floating point types include: <code>f32</code>, <code>f64</code></p>
<p>A <code>float</code> can represent integers between -(2<sup>53</sup>-1) and (2<sup>53</sup>-1). However, integers outside this range are not guaranteed to have a unique representation.</p>
<p>Decimal and scientific notations always produce a <code>float</code> value:</p>
<pre><code class="language-cy">a := 2.34567
b := 123.0e4
</code></pre>
<p>An integer literal can evaluate to a target float type:</p>
<pre><code class="language-cy">var a float = 123
</code></pre>
<p>Strings and other values can be converted to a <code>float</code> using the type as a function:</p>
<pre><code class="language-cy">a := '12.3'
b := float(a) 
</code></pre>
<p>Float types can perform <a href="#arithmetic-operators" title="">arithmetic</a> and <a href="#comparison-operators" title="">comparison</a> operations.</p>
<a href="#basic-types">^topic</a>
<h2 id="strings">Strings. <a href="#strings">#</a></h2>
<p>The <code>str</code> type represents a sequence of UTF-8 code points. Each code point is stored internally as 1-4 bytes.</p>
<p>Strings are not validated by default. When indexing for code points, an invalid codepoint will be returned as the replacement character (0xFFFD).</p>
<p>Strings are <strong>immutable</strong>, so an operation on a string returns a new string.</p>
<p>Some string operations are SIMD accelerated.</p>
<a href="#basic-types">^topic</a>
<h3 id="raw-string-literal">Raw string literal. <a href="#raw-string-literal">#</a></h3>
<p>A raw string doesn't allow any escape sequences or string interpolation.</p>
<p>Backticks are used to delimit a single line literal:</p>
<pre><code class="language-cy">fruit := `apple`
s := `abcü¶äxyzüê∂`
</code></pre>
<p>Since raw strings interprets the sequence of characters as is, the backtick character can not be escaped:</p>
<pre><code class="language-cy">-- ParseError.
s := `abc`xyz`
</code></pre>
<p>Triple backticks are used to delimit a multi-line literal. It also allows single backticks:</p>
<pre><code class="language-cy">s := ```abc`xyz```
greet := ```Hello
World```
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="string-literal">String literal. <a href="#string-literal">#</a></h3>
<p>A string literal allows escape sequences and string interpolation.</p>
<p>Single or double quotes are used to delimit a single line literal:</p>
<pre><code class="language-cy">fruit := 'apple'
fruit = 'Miso\'s apple'
fruit = "Miso's apple"
sentence := '%{fruit} is tasty.'
</code></pre>
<p>Triple single or double quotes are used to delimit a multi-line literal:</p>
<pre><code class="language-cy">title := 'last'
doc := '''A single quote ' doesn't need to be escaped.'''
s := """line a
line "b"
line %{title}
"""
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="escape-sequences">Escape sequences. <a href="#escape-sequences">#</a></h3>
<p>The following escape sequences are supported in string literals:</p>
<table><thead><tr><th>Sequence</th><th>Code</th><th>Character</th></tr></thead><tbody><tr><td><code>\0</code></td><td>0x00</td><td>Null</td></tr><tr><td><code>\a</code></td><td>0x07</td><td>Terminal bell</td></tr><tr><td><code>\b</code></td><td>0x08</td><td>Backspace</td></tr><tr><td><code>\e</code></td><td>0x1b</td><td>Escape</td></tr><tr><td><code>\n</code></td><td>0x0a</td><td>Line feed</td></tr><tr><td><code>\r</code></td><td>0x0d</td><td>Carriage return</td></tr><tr><td><code>\t</code></td><td>0x09</td><td>Horizontal tab</td></tr><tr><td><code>\"</code></td><td>0x22</td><td>Double quote</td></tr><tr><td><code>\\</code></td><td>0x5c</td><td>Backslash</td></tr><tr><td><code>\x??</code></td><td>--</td><td>Hexidecimal number</td></tr></tbody></table><p>Example:</p>
<pre><code class="language-cy">print('\xF0\x9F\x90\xB6')    --> üê∂
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="string-indexing">String indexing. <a href="#string-indexing">#</a></h3>
<p>The index operator returns the <code>byte</code> from a given index:</p>
<pre><code class="language-cy">a := 'abcxyz'
print(a[1])         --> 0x62
print(a[1] == 'b')  --> true
</code></pre>
<p>Since indexing operates at the byte level, it should not be relied upon for iterating runes or rune indexing.
However, if the string is known to only contain ASCII runes (each rune occupies one byte), indexing will return the expected rune.</p>
<p><code>str.rune_at</code> returns the rune from a given byte index:</p>
<pre><code class="language-cy">a := 'üê∂abcxyz'
print(a.rune_at(0)) --> 0x1f436
</code></pre>
<p>If the index does not begin a sequence of valid UTF-8 bytes, the replacement character (0xFFFD, 65533) is returned:</p>
<pre><code class="language-cy">a := 'üê∂abcxyz'
print(a.rune_at(1)) --> 0xfffd
</code></pre>
<p><code>str.seek</code> will return the n'th rune:</p>
<pre><code class="language-cy">a := 'üê∂abcxyz'
print(a.seek(2))    --> 0x62 ('b')
</code></pre>
<p>Slicing also operates on byte indexes and returns a view of the string at the given start and end (exclusive) indexes:</p>
<pre><code class="language-cy">a := 'abcxyz'
b := a[0..3]
print(a[0..3])  --> abc
print(a[1..])   --> bcxyz
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="string-concatenation">String concatenation. <a href="#string-concatenation">#</a></h3>
<p>Concatenate two strings together with the <code>+</code> operator or <code>str.concat</code>.</p>
<pre><code class="language-cy">res := 'abc' + 'xyz'
res = res.concat('end')
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="string-interpolation">String interpolation. <a href="#string-interpolation">#</a></h3>
<p>String templates wrap expressions in <code>%{}</code> which converts them to strings using the builtin <code>to_print_string</code>:</p>
<pre><code class="language-cy">name := 'Rex'
points := 123
title := 'Scoreboard: %{name} %{points}'
</code></pre>
<p>String templates can not contain nested string templates.</p>
<a href="#basic-types">^topic</a>
<h3 id="string-formatting">String formatting. <a href="#string-formatting">#</a></h3>
<p>Formatting replaces <code>{}</code> placeholders with values converted to strings:</p>
<pre><code class="language-cy">print('First: {}, Last: {}'.fmt({'John', 'Doe'}))
</code></pre>
<p>Alternatively, a custom placeholder can be specified:</p>
<pre><code class="language-cy">print('if (%PH) {\n\t%PH}'.fmt('%PH', {cond, body}))
</code></pre>
<p><em>Named placeholders will be supported.</em></p>
<p>Values that can be formatted into a string typically have a <code>fmt</code> method:</p>
<pre><code class="language-cy">x := 123
print(x.fmt(.hex))  --> 7b
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="line-join-literal">Line-join literal. <a href="#line-join-literal">#</a></h3>
<p>The line-join literal joins string literals with the new line character <code>\n</code>. <em>Planned Feature</em></p>
<p>This has several properties:</p>
<ul>
<li>Ensures the use of a consistent line separator: <code>\n</code></li>
<li>Allows lines to have a mix of raw string or string literals.</li>
<li>Single quotes and double quotes do not need to be escaped.</li>
<li>Allows each line to be indented along with the surrounding syntax.</li>
<li>Allows comments in between adjacent lines.</li>
<li>The starting whitespace for each line is made explicit.</li>
</ul>
<pre><code class="language-cy">paragraph := {
    \`raw string literal
    \hello\nworld
    \hello %{name}
    -- This is a comment.
    \last line
    \
}
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="mutable-strings">Mutable strings. <a href="#mutable-strings">#</a></h3>
<p><code>Str</code> is a mutable string type. <em>Planned Feature</em></p>
<a href="#basic-types">^topic</a>
<h2 id="symbols">Symbols. <a href="#symbols">#</a></h2>
<p>Symbol literals begin with <code>@</code>, followed by an identifier.
Each symbol has a global unique ID.</p>
<pre><code class="language-cy">currency := @usd
print(currency == @usd)   --> true
print(int(currency))      --> <unique ID>
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="references">References. <a href="#references">#</a></h2>
<p>A reference type is denoted as <code>^T</code> where <code>T</code> is the type of the value that the reference points to.
References are safe to use because the memory that they point to are <a href="#automatic-memory" title="">automatically managed</a>.</p>
<p>Separating values and references provides more control over how data is laid out in memory. For example, some types may benefit from compacted members to leverage cache locality and reduce object indirection.</p>
<p>The lift operator <code>^</code> lifts a value onto the heap and returns a reference to the new value:</p>
<pre><code class="language-cy">i := 123
ref := ^i
</code></pre>
<p>The <code>.*</code> operator dereferences a <code>^T</code> and returns the value that it points to:</p>
<pre><code class="language-cy">print(ref.*)      --> 123
</code></pre>
<p>If a value was intended to be initialized on the heap, it's usually constructed with the lift operator <code>^</code>. This avoids a copy of the underlying value:</p>
<pre><code class="language-cy">pos := ^Vec2{x=4, y=5}
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="optionals">Optionals. <a href="#optionals">#</a></h2>
<p>An <code>Option</code> is a value type that provides <strong>null safety</strong> by forcing the inner value to be unwrapped before it can be used.</p>
<p>Option types either hold a <code>none</code> value or wraps <code>some</code> value.</p>
<p>A type prefixed with <code>?</code> is the idiomatic way to declare an option type. The following <code>str</code> optional types are equivalent:</p>
<pre><code class="language-cy">Option[str]
?str
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="wrap-value">Wrap value. <a href="#wrap-value">#</a></h3>
<p>A value is automatically wrapped into the inferred optional's <code>some</code> case:</p>
<pre><code class="language-cy">var a ?str = 'abc'
print(a)    --> abc
</code></pre>
<p>The option type's constructor can also wrap a value:</p>
<pre><code class="language-cy">a := ?str('abc')
print(a)    --> abc
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="wrap-none">Wrap <code>none</code>. <a href="#wrap-none">#</a></h3>
<p><code>none</code> is automatically initialized to the inferred optional's <code>none</code> case:</p>
<pre><code class="language-cy">var a ?str = none
print(a)    --> none
</code></pre>
<p>The option type's constructor can also wrap <code>none</code>:</p>
<pre><code class="language-cy">a := ?str(none)
print(a)    --> none
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="unwrap-or-panic">Unwrap or panic. <a href="#unwrap-or-panic">#</a></h3>
<p>The <code>.?</code> operator unwraps an optional. The current thread panics if the expression evaluates to the <code>none</code> case at runtime:</p>
<pre><code class="language-cy">var opt ?int = 123

-- Success.
v := opt.?

opt = none

-- panic: Option is empty.
v = opt.?
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="unwrap-or-default">Unwrap or default. <a href="#unwrap-or-default">#</a></h3>
<p>The <code>?else</code> operator either returns the unwrapped value or a default value when the optional is <code>none</code>:</p>
<pre><code class="language-cy">var opt ?int = none
var v = opt ?else 123
print(v)     --> 123
</code></pre>
<p>An <code>?else</code> block executes a block of statements for the <code>none</code> case:</p>
<pre><code class="language-cy">value := opt ?else:
    return error.Missing
</code></pre>
<p>A value can be returned with <code>break</code>: <em>Planned Feature</em></p>
<pre><code class="language-cy">value := opt ?else:
    break 'empty'
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="optional-chaining">Optional chaining. <a href="#optional-chaining">#</a></h3>
<p>Given the last member's type <code>T</code> in a chain of <code>?.</code> operators, the expression will evaluate to <code>?T(none)</code> upon the first encounter of <code>none</code> or the value of the last member as <code>?T</code>: <em>Planned Feature</em></p>
<pre><code class="language-cy">last := root?.a?.b?.c?.last
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="if-unwrap"><code>if</code> unwrap. <a href="#if-unwrap">#</a></h3>
<p>The <code>if</code> statement can be amended to unwrap an optional value with the capture <code>|_|</code> clause:</p>
<pre><code class="language-cy">var opt ?str = 'abc'
if opt |value|:
    print(value)    --> abc
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="while-unwrap"><code>while</code> unwrap. <a href="#while-unwrap">#</a></h3>
<p>The <code>while</code> statement can be amended to unwrap an optional value using the capture <code>|_|</code> clause.
The loop exits when <code>none</code> is encountered:</p>
<pre><code class="language-cy">iter := dir.walk()
while iter.next() |entry|:
    print(entry.name)
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="vectors">Vectors. <a href="#vectors">#</a></h2>
<p>A vector type is a static data structure that holds contiguous elements of the same type.
It's denoted as <code>[N]T</code> where <code>N</code> is the size of the vector and <code>T</code> is the element type.</p>
<p>Vectors are constructed with the initializer expression:</p>
<pre><code class="language-cy">a := [3]int{1, 2, 3}
</code></pre>
<p>The number of elements can be inferred with the generic type <code>[_]T</code>:</p>
<pre><code class="language-cy">a := [_]int{1, 2, 3}
</code></pre>
<p>An initializer literal can infer the target vector type:</p>
<pre><code class="language-cy">var a [3]int = {1, 2, 3}
</code></pre>
<p>Vectors can be indexed:</p>
<pre><code class="language-cy">a[2] = 300
print(a[2])    --> 300
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="partial-vectors">Partial vectors. <a href="#partial-vectors">#</a></h3>
<p>Sometimes a vector prefers to be incrementally initialized where the uninitialized elements are unowned. The partial vector type denoted as <code>[..N]T</code> keeps track of how many elements in the vector are initialized at runtime so that it can be properly deinitialized:</p>
<pre><code class="language-cy">elems := [..4]Stateful{}
print(elems.len())   --> 0

-- No `Stateful` element is deinitialized.
</code></pre>
<p>Elements must be incrementally appended to the <code>PartialVector</code>. Indexing an element that hasn't been initialized results in a thread panic:</p>
<pre><code class="language-cy">elems << Stateful()
elems << Stateful()

elems[3] = Stateful()
--> panic: Out of bounds.
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="slices">Slices. <a href="#slices">#</a></h2>
<p>A <code>Slice</code> type is a dynamic data structure that holds contiguous elements of the same type.
It's denoted as <code>[]T</code> where <code>T</code> is the element type.
Slices grow or shrink when inserting or removing elements.</p>
<p>Slices are constructed with the initializer expression:</p>
<pre><code class="language-cy">arr := []int{1, 2, 3}
</code></pre>
<p>The intializer literal can infer the target slice type:</p>
<pre><code class="language-cy">var a []int = {1, 2, 3}
</code></pre>
<p>The first element of the slice starts at index 0.</p>
<pre><code class="language-cy">print(arr[0])    --> 1
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="sub-slices">Sub-slices. <a href="#sub-slices">#</a></h3>
<p>Slices can be sliced into smaller sub-slices. Sub-slices share the same underlying element buffer as the original slice which enables read/write access to the same elements:</p>
<pre><code class="language-cy">arr := []int{1, 2, 3, 4, 5}
print(arr[0..0])    --> {}
print(arr[0..3])    --> {1, 2, 3}
print(arr[3..])     --> {4, 5}
</code></pre>
<p>A sub-slice will clone the underlying buffer upon any resize operation such as <code>append</code>, <code>insert</code>, <code>remove</code>, etc.
Once cloned, the slice will no longer point to the same elements as the original slice:</p>
<pre><code class="language-cy">arr := []int{1, 2, 3}
slice := arr[0..1]
slice[0] = 100
print('%{arr[0]} %{slice[0]')   --> 100 100

slice += 4
slice[0] = 101
print('%{arr[0]} %{slice[0]')   --> 100 101
</code></pre>
<p>The <code>+..</code> invokes the slice operator with an end position that is an increment from the start: <em>Planned Feature</em></p>
<pre><code class="language-cy">arr := []int{1, 2, 3, 4, 5}
print(arr[2+..2])   --> {3, 4}
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="slice-operations">Slice operations. <a href="#slice-operations">#</a></h3>
<p>Here are some common slice operations:</p>
<pre><code class="language-cy">arr := []int{234}

-- Append a value.
arr += 123

-- Alternative way to append.
arr = arr.append(123)

-- Inserting a value at an index.
arr = arr.insert(1, 345)

-- Get the length.
print(arr.len())  --> 2

-- Sort the slice in place.
arr.sort(|a, b| a < b)

-- Iterating a slice.
for arr |it|:
    print(it)

-- Remove an element at a specific index.
arr = arr.remove(1)
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="maps">Maps. <a href="#maps">#</a></h2>
<p>A <code>Map</code> type is a dynamic data structure that stores key value pairs in a lookup table governed by hashing functions (key hash and equality functions).
<code>Map</code> provides default hashing functions while <code>HashMap</code> requires custom hash functions.</p>
<p>Maps are constructed with the initializer expression:</p>
<pre><code class="language-cy">map := Map[str, int]{a=123, b=234}
</code></pre>
<p>The initializer literal can infer the target map type:</p>
<pre><code class="language-cy">var map Map[str, int] = {a=123, b=234}
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="map-operations">Map operations. <a href="#map-operations">#</a></h3>
<p>Here are some common map operations:</p>
<pre><code class="language-cy">map := Map[int, int]{}

-- Set a key value pair.
map[123] = 234

-- Lookup value by key.
print(map[123])     --> 234

-- Get the size of the map.
print(map.size())   --> 1

-- Remove an entry by key.
map.remove(123)

-- Iterating a map.
for map |entry|:
    print('%{entry.key} -> %{entry.value}')
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="implicit-casts">Implicit casts. <a href="#implicit-casts">#</a></h2>
<p>Closely related types are implicitly casted to fit the target type:</p>
<pre><code class="language-cy">var f float = 1.23
var i int = 123

-- Implicit cast from `int` to `float`.
f = i
</code></pre>
<p>Implicit casts avoid lossy conversions (with the exception of int to float)
and they never produce runtime errors.
The following implicit casts are supported:</p>
<table><thead><tr><th>Source</th><th>Target</th><th>Behavior</th></tr></thead><tbody><tr><td><code>Int[W]</code></td><td><code>Raw[W]</code></td><td>reinterpret</td></tr><tr><td><code>Int[X]</code></td><td><code>Raw[W] where X < W</code></td><td>zero extension</td></tr><tr><td><code>Raw[X]</code></td><td><code>Raw[W] where X < W</code></td><td>zero extension</td></tr><tr><td><code>Raw[W]</code></td><td><code>Int[W]</code></td><td>reinterpret</td></tr><tr><td><code>Raw[X]</code></td><td><code>Int[W] where X < W</code></td><td>zero extension</td></tr><tr><td><code>Int[X]</code></td><td><code>Int[W] where X < W</code></td><td>sign extension</td></tr><tr><td><code>Int[X]</code></td><td><code>Float[W]</code></td><td>conversion</td></tr><tr><td><code>Raw[X]</code></td><td><code>Float[W]</code></td><td>conversion</td></tr><tr><td><code>f32</code></td><td><code>f64</code></td><td>conversion</td></tr><tr><td><code>T</code></td><td><code>?T</code></td><td>wrap</td></tr><tr><td><code>T</code></td><td><code>!T</code></td><td>wrap</td></tr><tr><td><code>error</code></td><td><code>!T</code></td><td>wrap</td></tr><tr><td><code>T</code></td><td><code>!?T</code></td><td>wrap</td></tr><tr><td><code>^T</code></td><td><code>&T</code></td><td>reinterpret</td></tr><tr><td><code>^T</code></td><td><code>Object</code></td><td>reinterpret</td></tr><tr><td><code>FuncPtr[Sig]</code></td><td><code>Func[Sig]</code></td><td>wrap</td></tr><tr><td><code>&S</code></td><td><code>&Dyn[T] where S implements T</code></td><td>wrap</td></tr><tr><td><code>^S</code></td><td><code>^Dyn[T] where S implements T</code></td><td>wrap</td></tr><tr><td><code>Ptr[T]</code></td><td><code>Ptr[void]</code></td><td>reinterpret</td></tr><tr><td><code>&T</code></td><td><code>Ptr[void]</code></td><td>reinterpret</td></tr><tr><td><code>Ptr[void]</code></td><td><code>Ptr[T]</code></td><td>reinterpret</td></tr><tr><td><code>&[N]T</code></td><td><code>Ptr[T]</code></td><td>reinterpret</td></tr><tr><td><code>&[..N]T</code></td><td><code>Ptr[T]</code></td><td>reinterpret</td></tr><tr><td><code>Ptr[Int[W]]</code></td><td><code>Ptr[Raw[W]]</code></td><td>reinterpret</td></tr><tr><td><code>Ptr[Raw[W]]</code></td><td><code>Ptr[Int[W]]</code></td><td>reinterpret</td></tr><tr><td><code>&T</code></td><td><code>Ptr[T]</code></td><td>reinterpret</td></tr><tr><td><code>&Int[W]</code></td><td><code>Ptr[Raw[W]]</code></td><td>reinterpret</td></tr><tr><td><code>&Raw[W]</code></td><td><code>Ptr[Int[W]]</code></td><td>reinterpret</td></tr></tbody></table><a href="#basic-types">^topic</a>
<h2 id="type-casts">Type casts. <a href="#type-casts">#</a></h2>
<p>The <code>as</code> operator casts a value to a supported target type:</p>
<pre><code class="language-cy">var i int = 127
var small i8 = 0

-- Success.
small = as[i8] i
</code></pre>
<p>Some casts can fail at runtime. For example, a bigger integer can only be casted to a smaller integer if its value fits the bounds of the smaller integer:</p>
<pre><code class="language-cy">var i int = 10000
var small i8 = 0

-- panic: Lossy conversion.
small = as[i8] i
</code></pre>
<p>When the target type can be inferred, it can be omitted from the <code>as</code> operator:</p>
<pre><code class="language-cy">small = as i
</code></pre>
<p>Type casting supports all <a href="#implicit-casts" title="">implicit casts</a> in addition to the following:</p>
<table><thead><tr><th>Source</th><th>Target</th><th>Behavior</th></tr></thead><tbody><tr><td><code>Ptr[S]</code></td><td><code>Ptr[T]</code></td><td>reinterpret</td></tr><tr><td><code>i64</code>, <code>r64</code></td><td><code>Ptr[T]</code></td><td>reinterpret</td></tr><tr><td><code>Int[W]</code>, <code>Raw[W]</code></td><td><code>Ptr[T] where W < 64</code></td><td>zero extension</td></tr><tr><td><code>Ptr[T]</code></td><td><code>&T</code></td><td>reinterpret</td></tr><tr><td><code>Ptr[T]</code></td><td><code>^T</code></td><td>reinterpret</td></tr><tr><td><code>FuncPtr[Sig2]</code></td><td><code>FuncPtr[Sig] where #[extern] Sig, Sig2</code></td><td>reinterpret</td></tr><tr><td><code>Ptr[T]</code></td><td><code>i64</code></td><td>reinterpret</td></tr><tr><td><code>^T</code></td><td><code>i64</code></td><td>reinterpret</td></tr><tr><td><code>T</code></td><td><code>i64 where T is enum</code></td><td>reinterpret</td></tr><tr><td><code>Int[X]</code></td><td><code>Int[W] where X > W</code></td><td>runtime check, convert</td></tr><tr><td><code>Float[X]</code></td><td><code>Int[W]</code></td><td>runtime check, convert</td></tr><tr><td><code>Ptr[T]</code></td><td><code>r64</code></td><td>reinterpret</td></tr><tr><td><code>^T</code></td><td><code>r64</code></td><td>reinterpret</td></tr><tr><td><code>T</code></td><td><code>r64 where T is enum</code></td><td>reinterpret</td></tr><tr><td><code>Int[X]</code></td><td><code>Raw[W] where X > W</code></td><td>runtime check, convert</td></tr><tr><td><code>f64</code></td><td><code>f32</code></td><td>convert</td></tr><tr><td><code>^Dyn[S]</code></td><td><code>^T where T implements S</code></td><td>runtime check, unwrap</td></tr></tbody></table><a href="#basic-types">^topic</a>
<h1 id="custom-types">Custom types. <a href="#custom-types">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#structs" title="">Structs.</a><ul>
<li><a href="#initialize-struct" title="">Initialize struct.</a></li>
<li><a href="#default-field-values" title="">Default field values.</a></li>
<li><a href="#field-visibility" title="">Field visibility.</a></li>
<li><a href="#circular-references" title="">Circular references.</a></li>
<li><a href="#type-embedding" title="">Type embedding.</a></li>
</ul>
</li>
<li><a href="#@init" title=""><code>@init</code>.</a></li>
<li><a href="#@init_sequence" title=""><code>@init_sequence</code>.</a></li>
<li><a href="#@init_record" title=""><code>@init_record</code>.</a></li>
<li><a href="#methods" title="">Methods.</a><ul>
<li><a href="#operator-methods" title="">Operator methods.</a></li>
<li><a href="#special-methods" title="">Special methods.</a></li>
</ul>
</li>
<li><a href="#tuples" title="">Tuples.</a></li>
<li><a href="#type-namespace" title="">Type namespace.</a></li>
<li><a href="#type-aliases" title="">Type aliases.</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#enums" title="">Enums.</a><ul>
<li><a href="#enum-switch" title="">Enum <code>switch</code>.</a></li>
</ul>
</li>
<li><a href="#choices" title="">Choices.</a><ul>
<li><a href="#initialize-choice" title="">Initialize choice.</a></li>
<li><a href="#choice-switch" title="">Choice <code>switch</code>.</a></li>
<li><a href="#unwrap-choice" title="">Unwrap choice.</a></li>
</ul>
</li>
<li><a href="#traits" title="">Traits.</a><ul>
<li><a href="#dynamic-dispatch" title="">Dynamic dispatch.</a></li>
</ul>
</li>
<li><a href="#type-evaluation" title="">Type evaluation.</a></li>
<li><a href="#type-templates" title="">Type templates.</a><ul>
<li><a href="#const-template-parameter" title=""><code>const</code> template parameter.</a></li>
<li><a href="#template-specialization" title="">Template specialization.</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="structs">Structs. <a href="#structs">#</a></h2>
<p>A struct type contains typed fields.</p>
<p>Struct types are declared with <code>type</code> followed by an optional <code>struct</code> keyword,
The following two declarations are equivalent:</p>
<pre><code class="language-cy">type Vec2 struct:
    x float
    y float

type Vec2:
    x float
    y float
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="initialize-struct">Initialize struct. <a href="#initialize-struct">#</a></h3>
<p>Structs are constructed from an initializer expression:</p>
<pre><code class="language-cy">v := Vec2{x=30, y=40}
print(v.x)      --> 30
</code></pre>
<p>An initializer literal can infer the target struct type:</p>
<pre><code class="language-cy">var v Vec2 = {x=30, y=40}
</code></pre>
<p>Structs by default are copyable (unless a child member is not):</p>
<pre><code class="language-cy">v := Vec2{x=30, y=40}
w := v
v.x = 100
print(w.x)     --> 30
print(v.x)     --> 100
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="default-field-values">Default field values. <a href="#default-field-values">#</a></h3>
<p>Struct initialization requires all fields to be specified, unless a default value was declared. Default field values must be <strong>const expressions</strong> :</p>
<pre><code class="language-cy">type Vec2:
    x float = 0
    y float = 0

v := Vec2{}
print(v.x)       --> 0
print(v.y)       --> 0
</code></pre>
<p>Unlike a <code>struct</code>, a <code>cstruct</code> can default to their <a href="#zero-values" title="">zero values</a>.</p>
<a href="#custom-types">^topic</a>
<h3 id="field-visibility">Field visibility. <a href="#field-visibility">#</a></h3>
<p>Fields have public visibility by default. However, when a field is declared with a <code>-</code> prefix, the field can only be accessed within the same module (although metaprogramming can get around this constraint):</p>
<pre><code class="language-cy">type Info:
    a       int
    -b      int
    -secret str
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="circular-references">Circular references. <a href="#circular-references">#</a></h3>
<p>Field declarations may have circular type references if the struct can be initialized:</p>
<pre><code class="language-cy">type Node:
    val  int
    next ?^Node

n := Node{val=123, next=none}
</code></pre>
<p>In the above example, <code>next</code> has an optional <code>?^Node</code> reference type so it can be initialized to <code>none</code> when creating a new <code>Node</code> instance.</p>
<p>The following <code>Node</code> type reports an error because it can not be initialized:</p>
<pre><code class="language-cy">type Node:
    val  int
    next Node     --> CompileError. Circular reference.
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="type-embedding">Type embedding. <a href="#type-embedding">#</a></h3>
<p>Type embedding facilitates type composition by using the namespace of a child field's type: <em>Planned Feature</em></p>
<pre><code class="language-cy">type Base:
    a int

fn (&Base) double() -> int:
    return self.a * 2

type Container:
    b use Base

c := Container{b = Base{a=123}}
print(c.a)
--> 123
print(c.double())
--> 246
</code></pre>
<p>Note that embedding a type does not declare extra fields or methods in the containing type. It simply augments the type's using namespace by binding the embedding field.</p>
<p>If there is a member name conflict, the containing type's member has a higher precedence:</p>
<pre><code class="language-cy">type Container:
    a int
    b use Base

c := Container{a=999, b = Base{a=123}}
print(c.a)
--> 999
print(c.double())
--> 246
</code></pre>
<p>Since the embedding field is named, it can be used just like any other field:</p>
<pre><code class="language-cy">print(c.b.a)
--> 123
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="@init"><code>@init</code>. <a href="#@init">#</a></h2>
<p>Types can declare an <code>@init</code> function that gets invoked when calling the type as a function:</p>
<pre><code class="language-cy">type Vec2:
    x float
    y float

fn Vec2 :: @init(x int, y int) -> Self:
    return Vec2{x=x, y=y}

v := Vec2(1, 2)
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="@init_sequence"><code>@init_sequence</code>. <a href="#@init_sequence">#</a></h3>
<p><code>@init_sequence</code> overrides the sequence literal <code>T{_, _, ...}</code> which can contain a varying number of elements:</p>
<pre><code class="language-cy">type MyArray

fn MyArray :: @init_sequence(init [&]int):
    print(init.len())
    return meta.init_type(MyArray, {})

arr := MyArray{1, 2, 3}
--> 3
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="@init_record"><code>@init_record</code>. <a href="#@init_record">#</a></h3>
<p><code>@init_record</code> overrides the record literal <code>T{_=_, _=_, ...}</code> which can contain a varying number of record pairs:</p>
<pre><code class="language-cy">type MyMap

fn MyMap :: @init_record(init [&]Pair[str, int]) -> Self:
    print(init.len())
    return meta.init_type(MyMap, {})

map := MyMap{a=123, b=234, c=345}
--> 3
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="methods">Methods. <a href="#methods">#</a></h2>
<p>Methods are functions that are invoked with a parent value (receiver).</p>
<p>They are declared by specifying the receiver's type before the function name and the other parameters. Inside a method body, <code>self</code> references the receiver's members as well as invoking other methods:</p>
<pre><code class="language-cy">type Node:
    value int
    next  ?^Node

fn (&Node) inc(n int):
    self.value += n
    self.inc_one()

fn (&Node) inc_one():
    self.value += 1

var n = Node{value=123, next=none}
n.inc(321)    --> 445
</code></pre>
<p>The receiver type can be passed by value, reference, borrow, or pointer:</p>
<pre><code class="language-cy">-- Pass by value.
fn (Node) inc(n int)

-- Pass by borrow.
fn (&Node) inc(n int)

-- Pass by exclusive borrow.
fn (&&Node) inc(n int)

-- Pass by reference.
fn (^Node) inc(n int)

-- Pass by pointer.
fn (Ptr[Node]) inc(n int)
</code></pre>
<p>It's recommended to use a borrow for the receiver unless there is a good reason not to.</p>
<a href="#custom-types">^topic</a>
<h3 id="operator-methods">Operator methods. <a href="#operator-methods">#</a></h3>
<p>Most operators are implemented as type methods.</p>
<p>The following is a list of operators:</p>
<table><thead><tr><th>Operator</th><th>Name</th></tr></thead><tbody><tr><td>Bitwise not, xor</td><td><code>~</code></td></tr><tr><td>Minus, Subtract</td><td><code>-</code></td></tr><tr><td>Greater</td><td><code>></code></td></tr><tr><td>Greater equal</td><td><code>>=</code></td></tr><tr><td>Less</td><td><code><</code></td></tr><tr><td>Less equal</td><td><code><=</code></td></tr><tr><td>Add</td><td><code>+</code></td></tr><tr><td>Multiply</td><td><code>*</code></td></tr><tr><td>Divide</td><td><code>/</code></td></tr><tr><td>Modulus</td><td><code>%</code></td></tr><tr><td>Power</td><td><code>**</code></td></tr><tr><td>Bitwise and</td><td><code>&&</code></td></tr><tr><td>Bitwise or</td><td><code>||</code></td></tr><tr><td>Bitwise left shift</td><td><code><<</code></td></tr><tr><td>Bitwise right shift</td><td><code>>></code></td></tr><tr><td>Address of index</td><td><code>@index_addr</code></td></tr><tr><td>Index</td><td><code>@index</code></td></tr><tr><td>Set index</td><td><code>@set_index</code></td></tr><tr><td>Slice</td><td><code>@slice</code></td></tr></tbody></table><p>Prefix operators only have a receiver parameter while infix operators have a receiver and RHS parameter. Currently, postfix operators cannot be overloaded. Since operator characters aren't allowed as standard identifiers, they are wrapped as raw string literals:</p>
<pre><code class="language-cy">type Vec2:
    x float
    y float

fn (&Vec2) `+`(o Vec2) -> Vec2:
    return {
        x = self.x + o.x,
        y = self.y + o.y,
    }

fn (&Vec2) `-`() -> Vec2:
    return {x=-self.x, y=-self.y}

a := Vec2{x=1, y=2}
b := a + Vec2{x=3, y=4}
c := -a
</code></pre>
<p>Special operators have their own name. This example overloads the <code>index</code> operator and the <code>set index</code> operator:</p>
<pre><code class="language-cy">type MyCollection:
    arr []int

fn (&MyCollection) @index(idx int) -> int:
    return self.arr[idx * 2]

fn (&MyCollection) @set_index(idx int, value int):
    self.arr[idx * 2] = val 

a := MyCollection{arr={1, 2, 3, 4}}
print(a[1])
--> 3
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="special-methods">Special methods. <a href="#special-methods">#</a></h3>
<p>The <code>@get</code> method allows overriding field accesses for undeclared fields:</p>
<pre><code class="language-cy">type Foo

fn (&Foo) @get(name str):
    return name.len()

f := Foo{}
print(f.abc)
--> 3

print(f.hello)
--> 5
</code></pre>
<p>The <code>@set</code> method allows overriding field assignments for undeclared fields:</p>
<pre><code class="language-cy">type Foo

fn (&Foo) @set(name str, value int):
    print('setting %{name} %{value}')

f := Foo{}
f.abc = 123
--> setting abc 123
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="tuples">Tuples. <a href="#tuples">#</a></h2>
<p>Tuples are declared using parentheses to wrap member fields:</p>
<pre><code class="language-cy">type Vec2 struct(x float, y float)

-- Shorthand declaration.
type Vec(x float, y float)
</code></pre>
<p>If the fields share the same type, they can be declared in a field group:</p>
<pre><code class="language-cy">type Vec3(x, y, z float)
</code></pre>
<p>Function and methods can still be declared inside the type's namespace:</p>
<pre><code class="language-cy">type Vec2(x float, y float)

fn (&Vec2) scale(s float):
    self.x *= s
    self.y *= s
</code></pre>
<p>Tuples can be initialized with member values corresponding to the order they were declared:</p>
<pre><code class="language-cy">v := Vec2{3, 4}
</code></pre>
<p>The initializer literal can infer the target tuple type:</p>
<pre><code class="language-cy">var v Vec2 = {3, 4}
</code></pre>
<p>Tuples can still be initialized with explicit field names:</p>
<pre><code class="language-cy">v := Vec2{x=3, y=4}
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="type-namespace">Type namespace. <a href="#type-namespace">#</a></h2>
<p>Functions and other symbols (except types) can be declared within the type's namespace.
<code>Self</code> is alias for the parent type:</p>
<pre><code class="language-cy">type Node:
    value int
    next  ?^Node

fn Node :: @init() -> Self:
    return Node{value=123, next=none}

const Node :: DefaultValue = 100

n := Node()
print(n.value)             --> 123
print(Node.DefaultValue)   --> 100
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="type-aliases">Type aliases. <a href="#type-aliases">#</a></h2>
<p>A type alias refers to a different type.
Once declared, the alias and the target type can be used interchangeably:</p>
<pre><code class="language-cy">type Vec2:
    x float
    y float

type Pos2 = Vec2

pos := Pos2{x=3, y=4}
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="enums">Enums. <a href="#enums">#</a></h2>
<p>An enum type is an exhaustive type where all possible values are defined by case members.</p>
<pre><code class="language-cy">type Fruit enum:
    case apple
    case orange
    case banana
    case kiwi

fruit := Fruit.kiwi
print(fruit)       --> Fruit.kiwi
print(int(fruit))  --> 3
</code></pre>
<p>The memory representation of an enum defaults to <code>int</code>. Each case has an increasing value starting from 0.</p>
<p>A dot literal can infer a target enum type:</p>
<pre><code class="language-cy">fruit := Fruit.kiwi
fruit = .orange
print(fruit == Fruit.orange)   --> true
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="enum-switch">Enum <code>switch</code>. <a href="#enum-switch">#</a></h3>
<p><code>switch case</code> can match enum cases:</p>
<pre><code class="language-cy">fn binary_search(arr []int, needle int, compare CompareFn) -> ?int:
    low := 0
    high := len
    while low < high:
        mid := low + (high - low) / 2
        switch compare(needle, mid):
            case .eq: return mid
            case .gt: low = mid + 1
            case .lt: high = mid
    return none
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="choices">Choices. <a href="#choices">#</a></h2>
<p>A choice type is an exhaustive type where only one defined case can be active. Each case member may contain a payload of an arbitrary type. An enum declaration becomes a choice declaration if one of the cases has a payload type specifier:</p>
<pre><code class="language-cy">type Shape enum:
    case rectangle Rectangle
    case circle    Circle
    case triangle  Triangle
    case line      float
    case point 

type Circle(radius float)
type Rectangle(width, height float)
type Triangle(base, height float)
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="initialize-choice">Initialize choice. <a href="#initialize-choice">#</a></h3>
<p>A choice can be initialized with the case payload as an argument:</p>
<pre><code class="language-cy">rect := Rectangle{width=10, height=20}
s := Shape.rectangle(rect)

-- Alternatively.
s = Shape.rectangle({width=10, height=20})

s = Shape.line(20)
</code></pre>
<p>A choice without a payload is initialized like an enum case:</p>
<pre><code class="language-cy">s = Shape.point
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="choice-switch">Choice <code>switch</code>. <a href="#choice-switch">#</a></h3>
<p><code>switch case</code> can match choice cases and capture the payload:</p>
<pre><code class="language-cy">switch s:
    case .rectangle |r|:
        print('%{r.width} %{r.height}')
    case .circle |c|:
        print(c.radius)
    case .triangle |t|:
        print('%{t.base} %{t.height}')
    case .line |len|:
        print(len)
    case .point:
        print('a point')
    else:
        print('Unsupported.')
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="unwrap-choice">Unwrap choice. <a href="#unwrap-choice">#</a></h3>
<p>A choice can be unwrapped with the <code>.!</code> operator. This will either return the payload or signals a thread panic if the expected case is not active:</p>
<pre><code class="language-cy">s := Shape.line(20)
print(s.!line)     --> 20
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="traits">Traits. <a href="#traits">#</a></h2>
<p>A trait is a generic type that defines a common interface for implementing types:</p>
<pre><code class="language-cy">type Shape trait:
    fn area() -> float
</code></pre>
<p>Types can be declared to implement a trait with the <code>with</code> keyword:</p>
<pre><code class="language-cy">type Circle:
    with Shape
    radius float

fn (&Circle) area() -> float:
    return 3.14 * self.radius^2

type Rectangle:
    with Shape
    width  float
    height float

fn (&Rectangle) area() -> float:
    return self.width * self.height
</code></pre>
<p>A type that intends to implement a trait but does not satisfy the trait's interface results in a compile error.</p>
<a href="#custom-types">^topic</a>
<h3 id="dynamic-dispatch">Dynamic dispatch. <a href="#dynamic-dispatch">#</a></h3>
<p>Since traits are a generic type, they need to be wrapped in a <code>Dyn</code> container to be materialized into a dynamic dispatch value. Implementing types become assignable to a <code>Dyn</code> reference type:</p>
<pre><code class="language-cy">var s ^Dyn[Shape] = ^Circle{radius=2}
print(s.area())       --> 12.57

s = ^Rectangle{width=4, height=5}
print(s.area())       --> 20
</code></pre>
<a href="#custom-types">^topic</a>
<h2 id="type-evaluation">Type evaluation. <a href="#type-evaluation">#</a></h2>
<p>Types can be declared from const evaluation:</p>
<pre><code class="language-">type File const:
    if meta.system() == .windows:
        return WinFile
    else:
        return PosixFile
</code></pre>
<p>This can be used to specialize types based on compile-time values.</p>
<a href="#custom-types">^topic</a>
<h2 id="type-templates">Type templates. <a href="#type-templates">#</a></h2>
<p>Type declarations can include template parameters.
Unlike function parameters, template parameters accept types rather than values of types by default. The type provided is constrained by a <strong>generic</strong> type specifier. The <code>Any</code> generic type allows any type:</p>
<pre><code class="language-cy">type MyContainer[T Any]:
    id    int
    value T

fn (&MyContainer[]) get() -> T:
    return self.value
</code></pre>
<p>When the type template is expanded, a variant of the type is generated:</p>
<pre><code class="language-cy">a := MyContainer[str]{id=123, value='abc'}
print(a.get())     --> abc
</code></pre>
<p>Expanding the template with the same parameters returns the same generated type. In other words, the generated type is always memoized from the input parameters.</p>
<a href="#custom-types">^topic</a>
<h3 id="const-template-parameter"><code>const</code> template parameter. <a href="#const-template-parameter">#</a></h3>
<p>Template parameters can accept const values other than types with the <code>const</code> modifier:</p>
<pre><code class="language-cy">type MyArray[T Any, const N int]
</code></pre>
<a href="#custom-types">^topic</a>
<h3 id="template-specialization">Template specialization. <a href="#template-specialization">#</a></h3>
<p>Wrapping <a href="#type-evaluation" title="">type evaluation</a> as a type template allows template specialization from template parameters:</p>
<pre><code class="language-cy">type MyContainer[T Any] const:
    if T == int:
        return IntContainer
    else:
        return GenericContainer[T]

a := MyContainer[int]{1, 2, 3}
</code></pre>
<a href="#custom-types">^topic</a>
<h1 id="control-flow">Control flow. <a href="#control-flow">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#branching" title="">Branching.</a><ul>
<li><a href="#if-statement" title=""><code>if</code> statement.</a></li>
<li><a href="#if-expression" title=""><code>if</code> expression.</a></li>
<li><a href="#and-expression" title=""><code>and</code> expression.</a></li>
<li><a href="#or-expression" title=""><code>or</code> expression.</a></li>
</ul>
</li>
<li><a href="#iterations" title="">Iterations.</a><ul>
<li><a href="#infinite-while" title="">Infinite <code>while</code>.</a></li>
<li><a href="#conditional-while" title="">Conditional <code>while</code>.</a></li>
<li><a href="#for-range" title=""><code>for</code> range.</a></li>
<li><a href="#for-each" title=""><code>for</code> each.</a></li>
<li><a href="#break-statement" title=""><code>break</code> statement.</a></li>
<li><a href="#continue-statement" title=""><code>continue</code> statement.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#switch-matching" title=""><code>switch</code> matching.</a><ul>
<li><a href="#case-range" title=""><code>case</code> range.</a></li>
<li><a href="#case-fallthrough" title=""><code>case</code> fallthrough.</a></li>
<li><a href="#switch-expression" title=""><code>switch</code> expression.</a></li>
</ul>
</li>
<li><a href="#begin-block" title=""><code>begin</code> block.</a></li>
<li><a href="#error-branching" title="">Error branching.</a></li>
<li><a href="#deferred-execution" title="">Deferred execution.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="branching">Branching. <a href="#branching">#</a></h2>
<a href="#control-flow">^topic</a>
<h3 id="if-statement"><code>if</code> statement. <a href="#if-statement">#</a></h3>
<p>The <code>if</code> and <code>else</code> statements branch execution depending on conditions. The <code>else</code> clause can contain a condition which is only evaluated if the previous if/else conditional evaluated to <code>false</code>:</p>
<pre><code class="language-cy">a := 10
if a == 10:
    print('a is 10')
else a == 20:
    print('a is 20')
else:
    print('neither 10 nor 20')
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="if-expression"><code>if</code> expression. <a href="#if-expression">#</a></h3>
<p>An <code>if</code> expression evaluates to a value depending on the condition.
Unlike the <code>if</code> statement, the <code>if</code> expression can not contain <code>else</code> conditions:</p>
<pre><code class="language-cy">x := 123
b := if (x) 1 else 0
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="and-expression"><code>and</code> expression. <a href="#and-expression">#</a></h3>
<p><code>and</code> evaluates to <code>true</code> if both operands are <code>true</code>. Otherwise, it evaluates to <code>false</code>. If the left operand is <code>false</code>, the evaluation of the right operand is skipped:</p>
<pre><code class="language-cy">true and true    --> true
true and false   --> false
false and true   --> false
false and false  --> false

a := 10
if a > 5 and a < 15:
    print('a is between 5 and 15')
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="or-expression"><code>or</code> expression. <a href="#or-expression">#</a></h3>
<p><code>or</code> evaluates to <code>true</code> if at least one of the operands is <code>true</code>. Otherwise, it evaluates to <code>false</code>. If the left operand is <code>true</code>, the evaluation of the right operand is skipped:</p>
<pre><code class="language-cy">true or true     --> true
true or false    --> true
false or true    --> true
false or false   --> false

a := 10
if a == 20 or a == 10: 
    print('a is 10 or 20')
</code></pre>
<a href="#control-flow">^topic</a>
<h2 id="iterations">Iterations. <a href="#iterations">#</a></h2>
<a href="#control-flow">^topic</a>
<h3 id="infinite-while">Infinite <code>while</code>. <a href="#infinite-while">#</a></h3>
<p>The <code>while</code> keyword starts an infinite loop which continues to run the code in the block until a <code>break</code> or <code>return</code> is reached:</p>
<pre><code class="language-cy">count := 0
while:
    if count > 100:
        break
    count += 1
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="conditional-while">Conditional <code>while</code>. <a href="#conditional-while">#</a></h3>
<p>When the <code>while</code> clause contains a condition, the loop continues to run until the condition is evaluated to <code>false</code>:</p>
<pre><code class="language-cy">running := true
count := 0
while running:
    if count > 100:
        running = false
    count += 1
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="for-range"><code>for</code> range. <a href="#for-range">#</a></h3>
<p><code>for</code> loops can iterate over a range that starts at an <code>int</code> (inclusive) to a target <code>int</code> (exclusive):</p>
<pre><code class="language-cy">for 0..4:
    performAction() 
</code></pre>
<p>The loop's counter variable can be captured:</p>
<pre><code class="language-cy">for 0..100 |i|:
    print(i)   --> 0, 1, 2, ... , 99
</code></pre>
<p>When <code>..=</code> is used, the target <code>int</code> is inclusive:</p>
<pre><code class="language-cy">for 0..=100 |i|:
    print(i)   --> 0, 1, 2, ... , 100
</code></pre>
<p>To decrement the counter instead, use either <code>..></code> or <code>..>=</code>:</p>
<pre><code class="language-cy">for 100..>=0 |i|:
    print(i)   --> 100, 99, 98, ... , 0
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="for-each"><code>for</code> each. <a href="#for-each">#</a></h3>
<p>The <code>for</code> clause can iterate over any type that implements the <code>Iterable</code> trait. An Iterable contains an <code>iterator()</code> method which returns a value that implements the <code>Iterator</code> trait. The for loop continually invokes the iterator's <code>next()</code> method until <code>none</code> is returned.</p>
<p>A <code>Slice</code> can be iterated. The element value returned from an iterator's <code>next()</code> can be captured in the <code>|_|</code> clause:</p>
<pre><code class="language-cy">arr := {1, 2, 3, 4, 5}

for arr |n|:
    print(n)
</code></pre>
<p>Iterating a <code>Map</code> yields <code>MapEntry</code> values:</p>
<pre><code class="language-cy">map := {a=123, b=234}

for map |entry|:
    print(entry.key)
    print(entry.value)
</code></pre>
<p>A counting index can be captured before the <strong>each</strong> variable. The count starts at 0 for the first value:</p>
<pre><code class="language-cy">arr := {1, 2, 3, 4, 5}
for arr |i, val|:
    print('index %{i}, value %{val}')
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="break-statement"><code>break</code> statement. <a href="#break-statement">#</a></h3>
<p>The <code>break</code> statement exits the current parent loop prematurely:</p>
<pre><code class="language-cy">for 0..10 |i|:
    if i == 4:
        break
    print(i)
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="continue-statement"><code>continue</code> statement. <a href="#continue-statement">#</a></h3>
<p>The <code>continue</code> statement skips the rest of the current loop iteration and resumes execution on the next iteration:</p>
<pre><code class="language-cy">for 0..10 |i|:
    if i == 4:
        -- Skips printing `4`.
        continue
    print(i)
</code></pre>
<a href="#control-flow">^topic</a>
<h2 id="switch-matching"><code>switch</code> matching. <a href="#switch-matching">#</a></h2>
<p>The <code>switch</code> statement matches on a control expression and branches to a case from a matching condition. Multiple cases can be grouped together with a comma separator:</p>
<pre><code class="language-cy">val := 1000
switch val:
    case 100:
        print('val is 100')
    case 200, 300:
        print('combined case')
    else:
        print('val is %{val}')
</code></pre>
<p>An <code>else</code> fallback case is branched to when no other cases were matched.
A switch statement requires an <code>else</code> case unless the type is <a href="#enum-switch" title=""><code>exhaustive</code></a>.</p>
<a href="#control-flow">^topic</a>
<h3 id="case-range"><code>case</code> range. <a href="#case-range">#</a></h3>
<p>Case ranges can be declared for integer types. Unlike other range clauses, a case range's last value is inclusive:</p>
<pre><code class="language-cy">val := 50 
switch val:
    case 0..100:
        print('at or between 0 and 100')
    case 'a'..'z', 'A'..'Z', '0'..'9', '_':
        print('an identifier character')
    else:
        print('val is %{val}')
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="case-fallthrough"><code>case</code> fallthrough. <a href="#case-fallthrough">#</a></h3>
<p>When a case is declared without a body, it will fallthough to the next case:</p>
<pre><code class="language-cy">val := 1000
switch val:
    case 100
    case 200
    case 1000
        print('handle case')
    else:
        print('val is %{val}')
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="switch-expression"><code>switch</code> expression. <a href="#switch-expression">#</a></h3>
<p>The result of a <code>switch</code> statement can be assigned to a variable. Each case must return an expression:</p>
<pre><code class="language-cy">shu := switch pepper:
    case 'bell'     => 0
    case 'anaheim'  => 500
    case 'jalape√±o' => 2000
    case 'serrano'  => 10000
    else => -1
</code></pre>
<a href="#control-flow">^topic</a>
<h2 id="begin-block"><code>begin</code> block. <a href="#begin-block">#</a></h2>
<p>A <code>begin</code> block executes its body statements within a new scope:</p>
<pre><code class="language-cy">a := 123

begin:
    a := 234
    print(a)
    --> 234    

print(a)
--> 123
</code></pre>
<a href="#control-flow">^topic</a>
<h2 id="error-branching">Error branching. <a href="#error-branching">#</a></h2>
<p>See <a href="#error-handling" title="">Error handling</a>.</p>
<a href="#control-flow">^topic</a>
<h2 id="deferred-execution">Deferred execution. <a href="#deferred-execution">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#control-flow">^topic</a>
<h1 id="functions">Functions. <a href="#functions">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#function-declaration" title="">Function declaration.</a><ul>
<li><a href="#function-overloading" title="">Function overloading.</a></li>
<li><a href="#parameter-groups" title="">Parameter groups.</a></li>
<li><a href="#named-parameters" title="">Named parameters.</a></li>
</ul>
</li>
<li><a href="#function-values" title="">Function values.</a><ul>
<li><a href="#lambdas" title="">Lambdas.</a></li>
<li><a href="#inferred-lambdas" title="">Inferred lambdas.</a></li>
<li><a href="#closures" title="">Closures.</a></li>
<li><a href="#function-pointer-types" title="">Function pointer types.</a></li>
<li><a href="#function-union-types" title="">Function union types.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#function-calls" title="">Function calls.</a><ul>
<li><a href="#no-parameter-calls" title="">No parameter calls.</a></li>
<li><a href="#shorthand-calls" title="">Shorthand calls.</a></li>
</ul>
</li>
<li><a href="#function-templates" title="">Function templates.</a><ul>
<li><a href="#generic-functions" title="">Generic functions.</a></li>
<li><a href="#infer-parameter" title="">Infer parameter.</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="function-declaration">Function declaration. <a href="#function-declaration">#</a></h2>
<p>Functions must be declared with a name:</p>
<pre><code class="language-cy">use math

fn dist(x0, y0, x1, y1 float) -> float:
    dx := x0 - x1
    dy := y0 - y1
    return math.sqrt(dx**2 + dy**2)
</code></pre>
<p>Functions can not reference outside local variables unless it's a <a href="#lambdas" title="">lambda</a>:</p>
<pre><code class="language-cy">a := 1

fn foo():
    print(a)    --> error: Undeclared variable `a`.
</code></pre>
<p>Functions can only return one value. However, the value can be destructured: <em>Planned Feature</em></p>
<pre><code class="language-cy">use math

fn compute(rad float) -> [2]float:
    return {math.cos(rad), math.sin(rad)}

{x, y} := compute(pi)
</code></pre>
<a href="#functions">^topic</a>
<h3 id="function-overloading">Function overloading. <a href="#function-overloading">#</a></h3>
<p>Functions can be overloaded by their type signature:</p>
<pre><code class="language-cy">fn foo() -> int:
    return 2 + 2

fn foo(n int) -> int:
    return 10 + n

fn foo(n, m int) -> int:
    return n * m

print(foo())         --> 4
print(foo(2))        --> 12
print(foo(20, 5))    --> 100
</code></pre>
<a href="#functions">^topic</a>
<h2 id="parameter-groups">Parameter groups. <a href="#parameter-groups">#</a></h2>
<p>When multiple parameters share the same type they can be declared together in a sequence:</p>
<pre><code class="language-cy">fn sum(a, b, c int) -> int
    return a + b + c
</code></pre>
<a href="#functions">^topic</a>
<h2 id="named-parameters">Named parameters. <a href="#named-parameters">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#functions">^topic</a>
<h2 id="function-values">Function values. <a href="#function-values">#</a></h2>
<p>Functions can be assigned to variables or passed around as values:</p>
<pre><code class="language-cy">-- Assigning to a local variable.
bar := dist

-- Passing `dist` as an argument.
print(sq_dist(dist, 30))

type DistFn = fn(float, float, float, float) -> float
fn sq_dist(dist DistFn, size float) -> float:
    return dist(0, 0, size, size) 

fn dist(x0, y0, x1, y1 float) -> float:
    dx := x0 - x1
    dy := y0 - y1
    return math.sqrt(dx**2 + dy**2)    
</code></pre>
<a href="#functions">^topic</a>
<h3 id="lambdas">Lambdas. <a href="#lambdas">#</a></h3>
<p>A lambda is an anonymous function that can only be referenced as a function value:</p>
<pre><code class="language-cy">add := fn(a, b int) -> int:
    return a + b
</code></pre>
<a href="#functions">^topic</a>
<h3 id="inferred-lambdas">Inferred lambdas. <a href="#inferred-lambdas">#</a></h3>
<p>Inferred lambdas are declared with the capture <code>|_|</code> clause followed by the function body expression. The parameter and return types are inferred from the target function type:</p>
<pre><code class="language-cy">-- Lambda without any parameters.
do(|_| print('hello'))

-- Lambda with a single parameter.
filter(|word| word.upper())

-- Lambda with multiple parameters.
symbol_name(|word, prefix| prefix + word.upper())

-- Assigning a lambda.
app.on_update = |delta_ms| update_physics(delta_ms)
</code></pre>
<p>A blockless statement can contain one lambda that has their function body continued in a new block:</p>
<pre><code class="language-cy">queue_task(.high_priority, |_|):
    print('My important task.')
    do_stuff()
</code></pre>
<a href="#functions">^topic</a>
<h3 id="closures">Closures. <a href="#closures">#</a></h3>
<p>Lambdas can capture local variables with reference types from an immediate parent scope. The following example shows the lambda <code>f</code> capturing <code>a</code> from the main scope:</p>
<pre><code class="language-cy">a := ^1
f := fn() -> int:
    return a.* + 2
print(f())     --> 3
</code></pre>
<p>When a closure captures a local variable that is not a reference <code>^T</code>, it becomes a pinned closure. A pinned closure cannot be copied or moved: <em>Still experimental</em></p>
<pre><code class="language-cy">a := 1
f := fn() -> int:
    return a + 2
print(f())     --> 3
</code></pre>
<a href="#functions">^topic</a>
<h3 id="function-pointer-types">Function pointer types. <a href="#function-pointer-types">#</a></h3>
<p>A function pointer type is denoted as <code>fn(P1, P2, ...) -> R</code> where <code>P</code>s are parameter types and <code>R</code> is the return type. Currently, function pointer types can only only be declared as a type alias:</p>
<pre><code class="language-cy">type AddFn = fn(int, int) -> int
</code></pre>
<p>Function pointer types can include optional parameter names.
If one parameter has a name, the other parameters must also have names.
Parameter names do not alter the function signature and only serve as documentation:</p>
<pre><code class="language-cy">type AddFn = fn(a int, b int) -> int
</code></pre>
<p>Functions and lambdas (excluding closures) can be assigned to a function pointer type:</p>
<pre><code class="language-cy">fn add(a, b int) -> int:
    return a + b

type AddFn = fn(int, int) -> int

var func AddFn = add
func = |a, b| a + b + 123
</code></pre>
<a href="#functions">^topic</a>
<h3 id="function-union-types">Function union types. <a href="#function-union-types">#</a></h3>
<p>A function union type is denoted as <code>Func(FN)</code> where <code>FN</code> is a function pointer type.</p>
<p>It can hold closures in addition to functions and lambdas:</p>
<pre><code class="language-cy">c := ^5
fn add_c(a int, b int) -> int:
    return a + b + c.*

type AddFn = fn(int, int) -> int

var func Func(AddFn) = add_c
func(10, 20)       --> 35
</code></pre>
<a href="#functions">^topic</a>
<h2 id="function-calls">Function calls. <a href="#function-calls">#</a></h2>
<p>Functions can be called with arguments wrapped in parentheses:</p>
<pre><code class="language-cy">d := dist(100, 100, 200, 200)
</code></pre>
<p>Named arguments are required for named parameters:</p>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><pre><code class="language-cy">d := dist(x0=10, x1=20, y0=30, y1=40)
</code></pre>
<a href="#functions">^topic</a>
<h3 id="no-parameter-calls">No parameter calls. <a href="#no-parameter-calls">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#functions">^topic</a>
<h3 id="shorthand-calls">Shorthand calls. <a href="#shorthand-calls">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#functions">^topic</a>
<h2 id="function-templates">Function templates. <a href="#function-templates">#</a></h2>
<p>Function declarations become function templates if they have template parameters:</p>
<pre><code class="language-cy">fn add[T Any](a T, b T) -> T:
    return a + b
</code></pre>
<p>The function template can then be expanded to a function:</p>
<pre><code class="language-cy">add_int := add[int]
print(add_int(1, 2))    --> 3
print(add[float](1, 2)) --> 3.0
</code></pre>
<a href="#functions">^topic</a>
<h3 id="generic-functions">Generic functions. <a href="#generic-functions">#</a></h3>
<p>When function's signature contains embedded template parameters <code>%</code>, it becomes a generic function:</p>
<pre><code class="language-cy">fn add(%T type, a T, b T) -> T:
    return a + b
</code></pre>
<p>Generic functions automatically expand to a function when invoked.
The template parameter(s) are used to generate the appropriate function:</p>
<pre><code class="language-cy">print(add(int, 1, 2))   --> 3
print(add(float, 1, 2)) --> 3.0
</code></pre>
<p>Note that invoking the function again with the same template parameter(s) uses the same generated function. The generated function is always memoized from the template parameters.</p>
<a href="#functions">^topic</a>
<h3 id="infer-parameter">Infer parameter. <a href="#infer-parameter">#</a></h3>
<p>When a template parameter is declared in a type specifier, it's inferred from the call  argument's type:</p>
<pre><code class="language-cy">fn add(a %T, b T) -> T:
    return a + b

print(add(1, 2))        --> 3
print(add(1.0, 2.0))    --> 3.0
</code></pre>
<p>Nested template parameters can also be inferred:</p>
<pre><code class="language-cy">fn set(m Map[%K, %V], key K, val V):
    m[key] = val
</code></pre>
<a href="#functions">^topic</a>
<h1 id="memory">Memory. <a href="#memory">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#structured-memory" title="">Structured memory.</a><ul>
<li><a href="#value-ownership" title="">Value ownership.</a></li>
<li><a href="#copy-semantics" title="">Copy semantics.</a></li>
<li><a href="#cloning" title="">Cloning.</a></li>
<li><a href="#moving" title="">Moving.</a></li>
<li><a href="#borrows" title="">Borrows.</a></li>
<li><a href="#exclusive-borrows" title="">Exclusive borrows.</a></li>
<li><a href="#self-borrow" title=""><code>self</code> borrow.</a></li>
<li><a href="#scope-parameter" title=""><code>scope</code> parameter.</a></li>
<li><a href="#sink-parameter" title=""><code>sink</code> parameter.</a></li>
<li><a href="#deinitializers" title="">Deinitializers.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#shared-references" title="">Shared references.</a><ul>
<li><a href="#arc" title="">ARC.</a></li>
<li><a href="#retain-optimizations" title="">Retain optimizations.</a></li>
<li><a href="#default-allocator" title="">Default allocator.</a></li>
<li><a href="#weak-references" title="">Weak references.</a></li>
<li><a href="#cycle-detection" title="">Cycle detection.</a></li>
</ul>
</li>
<li><a href="#manual-memory" title="">Manual memory.</a><ul>
<li><a href="#pointers" title="">Pointers.</a></li>
<li><a href="#memory-allocations" title="">Memory allocations.</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Cyber provides memory safety by default by providing structured memory semantics.
Manual memory is also supported but it's forbidden in safe mode.</p>
<h2 id="structured-memory">Structured memory. <a href="#structured-memory">#</a></h2>
<p>Cyber supports value ownership, borrowing, and deinitializers.
These concepts allow a value to be cleaned up automatically during execution because their lifetimes can be determined from analyzing the program's control flow.</p>
<p>This means that memory can be automatically managed without a garbage collector and deinitializer logic can be coupled with the value's lifetime.
This prevents memory and state bugs such as:</p>
<ul>
<li>Use before init, allocation.</li>
<li>Use after deinit, invalidation, free.</li>
<li>Invalid deinit, free. (decoupling value from its deinitializer logic)</li>
<li>Free before allocated.</li>
<li>Free with wrong allocator.</li>
<li>Double free.</li>
<li>Memory leaks. (forgetting to free)</li>
</ul>
<p>At the same time, the use of structured memory is performant because it leverages cache locality and allows referencing to stack and interior heap members which flattens the memory hierarchy (less object indirection). In some cases, no-alias optimizations can be enabled because the compiler can prove there is only one reference pointing to a value.</p>
<a href="#memory">^topic</a>
<h3 id="value-ownership">Value ownership. <a href="#value-ownership">#</a></h3>
<p>A value can be any type such as primitives, containers, and even references.</p>
<p>A value created on the stack can only have one owner; the variable it was assigned to, otherwise a temporary variable. A heap value can have multiple owners as shared references <code>^T</code>.</p>
<p>When the last owner goes out of scope (no longer reachable), its value is deinitialized.</p>
<p>At the end of a block, a child variable can no longer be accessed so its value is deinitialized:</p>
<pre><code class="language-cy">a := 123

-- Deinit `a`.
</code></pre>
<p>In this case, it's effectively a no-op because <code>a</code> is a primitive <code>int</code> type.</p>
<p>If the value was a <code>str</code> (an immutable type backed by a reference counted buffer), the deinitialize logic would release a reference count (-1) on the underlying buffer:</p>
<pre><code class="language-cy">a := 'hello'

-- Deinit `a`.
-- `a.buf` is released.
-- `a.buf` is freed.
</code></pre>
<p>Since the string buffer's reference count reaches 0, it's the last owner that points to the buffer so the buffer value is deinitialized (freed from heap memory).</p>
<p>The following initializes a value that holds a system resource:</p>
<pre><code class="language-cy">a := os.open_file('foo.txt')!

-- Deinit `a`.
-- `a.@deinit()` is called.
-- `a.fd` file handle is closed.
</code></pre>
<p>In this case, <code>a</code> deinitializes by closing the file handle that it owns.</p>
<p>Owners can also go out of scope when they have been reassigned:</p>
<pre><code class="language-cy">a := 123

-- Deinit `a`.
a = 234

b := Foo{a=123}

-- Deinit `b.a`.
b.a = 234
</code></pre>
<p>Value ownership allows the lifetime of values to be understood from the control flow.
A value always knows <strong>how</strong> to deinitialize itself as described by its type, and the owner knows <strong>when</strong> to deinitialize the value.</p>
<a href="#memory">^topic</a>
<h3 id="copy-semantics">Copy semantics. <a href="#copy-semantics">#</a></h3>
<p>Commonly used data types are copyable such as primitives, <code>str</code>, <code>Slice</code>, and others.
A copyable type is implicitly copied. This can result in a shallow or deep copy depending on how the type is defined:</p>
<pre><code class="language-cy">a := 123

b := a
-- Bit copy of `int`
</code></pre>
<p>Composite types are also copyable if all its members are copyable:</p>
<pre><code class="language-cy">?int       -- Copyable option.

type Foo:  -- Copyable struct.
    a int
    b str
</code></pre>
<p>A custom type can also be copyable if it declares a <code>@copy</code> method:</p>
<pre><code class="language-cy">type MyArray:
    ptr Ptr[byte]
    len int

-- Performs deep copy.
fn (&MyArray) @copy() -> Self:
    new_ptr := alloc(byte, self.len)
    @memcpy(new_ptr, self.ptr, self.len)
    return {ptr=new_ptr}
</code></pre>
<p>A type that implements the <code>NoCopy</code> trait prevents implicit copying:</p>
<pre><code class="language-cy">type Foo:
    with NoCopy

    a int

f := Foo{a=123}

g := f
--> error: `Foo` is not copyable.
</code></pre>
<p>Some types such as <code>Array</code> disallows copying but can still be <a href="#cloning" title="">cloned</a> or <a href="#moving" title="">moved</a>.</p>
<a href="#memory">^topic</a>
<h3 id="cloning">Cloning. <a href="#cloning">#</a></h3>
<p>Some value types cannot be implicitly copied but can be explicitly cloned: <em>Planned feature</em></p>
<pre><code class="language-cy">a := Array[int]{1, 2, 3}
b := clone(a)
</code></pre>
<p>Any implicitly <code>Copyable</code> type is also implicitly <code>Cloneable</code>. By default, <code>clone</code> will invoke the type's copy constructor:</p>
<pre><code class="language-cy">a := 123

b := clone(a)
-- Equivalent to a copy.
</code></pre>
<p>The default <code>clone</code> behavior can be overridden by declaring a <code>@clone</code> method on the type:</p>
<pre><code class="language-cy">type Foo:
    a int

fn (&Foo) @clone() -> Self:
    return {a=self.a}
</code></pre>
<a href="#memory">^topic</a>
<h3 id="moving">Moving. <a href="#moving">#</a></h3>
<p>Values can be moved, thereby transfering ownership from one variable to another:</p>
<pre><code class="language-cy">a := 123
b := move a

print(a)
--> error: `a` does not own a value.
</code></pre>
<p>Some types such as <code>Array</code> can not be passed around by default without moving (or cloning) the value:</p>
<pre><code class="language-cy">a := Array[int]{1, 2, 3}

print(compute_sum(move a))
</code></pre>
<p>In this case, the <code>Array</code> value is moved into the <code>compute_sum</code> function, so the <code>Array</code> is deinitialized by the callee function and not the callsite.</p>
<p>Values can be partially moved if a subset of its members were moved:</p>
<pre><code class="language-cy">type Foo:
    a int
    b str

f := Foo{a=123, b='abc'}
b := move f.b
</code></pre>
<a href="#memory">^topic</a>
<h3 id="borrows">Borrows. <a href="#borrows">#</a></h3>
<p>Borrows are safe references to values that can never escape the stack.
Unlike unsafe pointers, a borrow is never concerned with when to free or deinitialize a value since that responsibility always belongs to the value's owner.
A borrow is guaranteed to point to an active value because they never outlive the lifetime of the active value.</p>
<p>Borrows grant <strong>mutability</strong> or read/write access to a value.
<strong>Multiple</strong> borrows can be alive at once as long as there is no exclusive borrow alive at the same time.</p>
<p>A borrow type is denoted as <code>&T</code> where <code>T</code> is the type that the borrow points to.
The <code>&</code> operator is used to obtain a borrow to a value:</p>
<pre><code class="language-cy">a := 123
ref := &a
ref.* = 234

print(a)
--> 234

inc(&a)
print(a)
--> 235

fn inc(a &int):
    a.* = a.* + 1
</code></pre>
<p>A borrow can not outlive the value it's referencing:</p>
<pre><code class="language-cy">a := 123
ref := &a
if true:
    b := 234
    ref = &b
    --> error: `ref` can not outlive `b`.
</code></pre>
<p>Some dynamic data structure types allow borrowing a reference to an inner element:</p>
<pre><code class="language-cy">a := Array[int]{1, 2, 3}
elem := &a[2]
elem.* = 300

print(a)
--> {1, 2, 300}
</code></pre>
<p>The element that <code>elem</code> points to can be mutated because the <code>Array</code> guarantees that the address remains stable.</p>
<a href="#memory">^topic</a>
<h3 id="exclusive-borrows">Exclusive borrows. <a href="#exclusive-borrows">#</a></h3>
<p>Like borrows, an exclusive borrow also grants <strong>mutability</strong> to a value.
A <strong>single</strong> exclusive borrow can be alive as long as no other borrows are also alive.
Exclusivity can be a useful constraint when invalidating an indirect buffer or value.
Since no other borrows are allowed to be alive at the same time, no borrows can become invalidated. Exclusivity also enables no-alias optimizations.</p>
<p>The <code>&&</code> prefix operator is used to obtain an exclusive borrow to a value.
An exclusive borrow type is denoted as <code>&&T</code> where <code>T</code> is the type that the reference points to.</p>
<p><code>Array</code> is a type that requires an exclusive borrow for operations that can resize or reallocate its dynamic buffer:</p>
<pre><code class="language-cy">a := Array[int]{1, 2, 3}
invalidate(&&a)

fn invalidate(arr &&Array[int]):
    a << 4
    if arr.len() > 3:
        arr.clear()
</code></pre>
<p>Note that invoking the append <code><<</code> and <code>clear</code> methods automatically obtain an exclusive borrow for <code>self</code> without an explicit <code>&&</code> operator.</p>
<p>Resize operations such as <code><<</code> and <code>clear</code> require an exclusive borrow because they can potentially reallocate a dynamic buffer, thereby invalidating other borrows.
If another borrow is alive before invoking these methods, the compiler would attempt to prematurely end the lifetime of the other borrows in order to satisfy the exclusivity constraint.
If this is not possible, then obtaining an exclusive borrow would result in a compile error:</p>
<pre><code class="language-cy">a := Array[int]{1, 2, 3}
elem := &a[2]
a << 4
-- Ok. `elem` is no longer alive.

append_to(&a[2], &&a)
--> error: Can not obtain exclusive borrow, `&a[2]` is still alive.

fn append_to(elem &int, arr &&Array[int]):
    arr << elem.*
</code></pre>
<a href="#memory">^topic</a>
<h3 id="self-borrow"><code>self</code> borrow. <a href="#self-borrow">#</a></h3>
<p>Methods can be declared to accept borrows or exclusive borrows from the <code>self</code> receiver:</p>
<pre><code class="language-cy">type Foo:
    a int

fn (&Foo) mutate():
    self.a = 123
</code></pre>
<p>Invoking methods automatically attempts to obtain the correct borrow type as specified by the method:</p>
<pre><code class="language-cy">f := Foo{a=1}
f.mutate()
-- Obtain borrow to `f`.
</code></pre>
<a href="#memory">^topic</a>
<h3 id="scope-parameter"><code>scope</code> parameter. <a href="#scope-parameter">#</a></h3>
<p>Functions can only return borrows if the scope is bound to a borrow parameter. This is possible with the <code>scope</code> modifier:</p>
<pre><code class="language-cy">fn (scope &FooArray) @index_addr(idx int) -> scope &Foo:
    return &self.inner[idx]
</code></pre>
<p>The <code>scope</code> binding informs the callsite that the returned borrow belongs to the same scope as a borrowed argument. This ensures the returned borrow's lifetime does not exceed the lifetime of the borrowed argument.</p>
<p>Any type that contains a borrow member becomes a borrow container and requires the <code>scope</code> binding:</p>
<pre><code class="language-cy">type FooIterator:
    rec &FooArray
    idx int

fn (scope &FooArray) iterator() -> scope FooIterator:
    return {
        rec = self,
        idx = 0,
    }
</code></pre>
<a href="#memory">^topic</a>
<h3 id="sink-parameter"><code>sink</code> parameter. <a href="#sink-parameter">#</a></h3>
<p>The <code>sink</code> modifier accepts and consumes a value argument: <em>This is not much different from a <code>move</code> operation, so this feature may be removed.</em></p>
<pre><code class="language-cy">fn (sink Array[]) as_buffer() -> Buffer[T]:
    buf := self.buf
    length := self.length
    cap := self.cap()
    @consume(self)
    return {
        base   = buf,
        length = length,
        header = cap,
    }
</code></pre>
<a href="#memory">^topic</a>
<h3 id="deinitializers">Deinitializers. <a href="#deinitializers">#</a></h3>
<p>When a value is no longer alive, its deinitializer is invoked.
Under normal conditions, the procedure follows these steps:</p>
<ol>
<li>The value's custom <code>@deinit</code> method is invoked.</li>
<li>Performs the deinitialize procedure for any child values (defined as type members).</li>
</ol>
<p>Custom deinitializers can be declared with a <code>@deinit</code> method:</p>
<pre><code class="language-cy">type File:
    fd int

fn (&File) @deinit():
    C.close(self.fd)
</code></pre>
<p>On thread panic, the runtime begins its <strong>fatal</strong> deinitialization procedure.
Value deinitializers are only invoked for types that implement <code>Unwind</code>. <em>TBD</em>
In addition, the deinitializers are not invoked in any hierarchical order but rather a flattened order (as the runtime iterates the alive values at the time of the panic).</p>
<a href="#memory">^topic</a>
<h2 id="shared-references">Shared references. <a href="#shared-references">#</a></h2>
<p>Shared references <code>^T</code> point to objects (values that were allocated on the heap).
The usage of shared references has been described in <a href="#references" title="">Basic types -> References</a>. This section describes their implementation details and how the runtime manages them.</p>
<a href="#memory">^topic</a>
<h3 id="arc">ARC. <a href="#arc">#</a></h3>
<p>Objects in Cyber are reference counted. Each shared reference retains the count upon initialization and releases the count when it goes out of scope. The value that the reference points to is deinitialized and freed when the reference count reaches zero. This is also known as ARC (automatic reference counting).</p>
<p>Shared references are meant to describe a shared dependency to an object when it would be inconvenient to do so through single value ownership. It is not meant to describe a cyclic graph of objects (where there is no clear ownership hierarchy). In fact, reference cycles is a sign of a bug in the program and is <a href="#cycle-detection" title="">reported</a>.</p>
<a href="#memory">^topic</a>
<h3 id="retain-optimizations">Retain optimizations. <a href="#retain-optimizations">#</a></h3>
<p>Reference counting is not zero-cost. Retaining and releasing an object's reference count is a write operation so the compiler will look for opportunities to keep the book keeping to a minimum.
It turns out a significant amount of retain/release ops can be avoided when the lifetime of a reference is known on the stack.
For example, passing a reference to a function call doesn't need a retain since it is guaranteed to be alive when the call returns.</p>
<a href="#memory">^topic</a>
<h3 id="default-allocator">Default allocator. <a href="#default-allocator">#</a></h3>
<p>Currently, <code>mimalloc</code> is used as the default heap allocator for objects, but it can be swapped with libc <code>malloc</code> or a custom allocator.</p>
<a href="#memory">^topic</a>
<h3 id="weak-references">Weak references. <a href="#weak-references">#</a></h3>
<blockquote><p><em>TBD</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="cycle-detection">Cycle detection. <a href="#cycle-detection">#</a></h3>
<p>When shared references form a reference cycle, it's considered a runtime error.
In safe mode, cycle detection is dispatched at the end of a thread.
The thread will panic if a cycle is detected which subsequently begins the runtime's <a href="#deinitializers" title="">fatal deinitialization procedure</a>.</p>
<p>When enabled, the cycle detector can also be invoked manually <code>@check_cycles</code>: <em>TBD</em></p>
<pre><code class="language-cy">fn foo():
    -- Create a reference cycle.
    a := ^Foo{child=none}
    b := ^Foo{child=none}
    a.child = b
    b.child = a

    -- Cycle still alive in the current stack so it reports no cyclic objects.
    res := @check_cycles()
    print(res.num_cyc_objs)   --> 0

foo()
-- `a` and `b` are no longer reachable.
res := @check_cycles()
print(res.num_cyc_objs)       --> 2
</code></pre>
<a href="#memory">^topic</a>
<h2 id="manual-memory">Manual memory. <a href="#manual-memory">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="pointers">Pointers. <a href="#pointers">#</a></h3>
<p>See <a href="#pointers-1" title="">FFI / Pointers</a>.</p>
<a href="#memory">^topic</a>
<h3 id="memory-allocations">Memory allocations. <a href="#memory-allocations">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h1 id="error-handling">Error handling. <a href="#error-handling">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#errors" title="">Errors.</a><ul>
<li><a href="#error-literal" title=""><code>error</code> literal.</a></li>
<li><a href="#error-payload" title=""><code>error</code> payload.</a></li>
<li><a href="#error-set-type" title=""><code>error</code> set type.</a></li>
</ul>
</li>
<li><a href="#results" title="">Results.</a><ul>
<li><a href="#unwrap-or-rethrow" title="">Unwrap or rethrow.</a></li>
<li><a href="#unwrap-or-default" title="">Unwrap or default.</a></li>
<li><a href="#unwrap-or-guard" title="">Unwrap or guard.</a></li>
<li><a href="#unwrap-block" title="">Unwrap block.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#panics" title="">Panics.</a></li>
<li><a href="#stack-traces" title="">Stack traces.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="errors">Errors. <a href="#errors">#</a></h2>
<p>An <code>error</code> is copyable value that should be handled at the call site or bubbled up.</p>
<a href="#error-handling">^topic</a>
<h3 id="error-literal"><code>error</code> literal. <a href="#error-literal">#</a></h3>
<p>An error value can be constructed from an <code>error</code> literal:</p>
<pre><code class="language-cy">err := error.Oops
</code></pre>
<p><code>error</code> values can be compared using the <code>==</code> operator:</p>
<pre><code class="language-cy">if err == error.Oops:
    handle_oops()
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="error-payload"><code>error</code> payload. <a href="#error-payload">#</a></h3>
<p>A payload value can be attached when creating an error value. <em>TBD</em></p>
<a href="#error-handling">^topic</a>
<h3 id="error-set-type"><code>error</code> set type. <a href="#error-set-type">#</a></h3>
<p>An error set type is an exhaustive type of possible error values: <em>TBD</em></p>
<pre><code class="language-cy">type MyError error:
    case Boom
    case BadArgument
    case NameTooLong

err := MyError.NameTooLong
</code></pre>
<a href="#error-handling">^topic</a>
<h2 id="results">Results. <a href="#results">#</a></h2>
<p>A result value forces the call site to unwrap it in order to use the payload.</p>
<p>A result type is a choice type that holds either an <code>error</code> or a payload.
It is denoted as <code>!T</code> where <code>T</code> is the payload type.</p>
<p>It can be constructed by inferring an error or a payload value:</p>
<pre><code class="language-cy">var res !str = error.Failed

res = 'abcxyz'
</code></pre>
<p>In practice, results are typically constructed when returning from a function:</p>
<pre><code class="language-cy">fn compute(input int) -> !int:
    if input == 42:
        return error.WhyPick42

    return fib(input)
</code></pre>
<p>A function that can fail but has no payload would return <code>!void</code>:</p>
<pre><code class="language-cy">fn validate(name str) -> !void:
    if name.len() > 64:
        return error.NameTooLong
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="unwrap-or-rethrow">Unwrap or rethrow. <a href="#unwrap-or-rethrow">#</a></h3>
<p>The <code>!</code> postfix operator unwraps a result's payload or rethrows the error:</p>
<pre><code class="language-cy">data := os.read_file('data.txt')!
</code></pre>
<p>In the main block, the rethrow case would result in a thread panic.</p>
<p>If the unwrap expression is inside a function, the rethrow case would bubble up the error to the caller. This suggests that the function must have a <code>Result</code> return type:</p>
<pre><code class="language-cy">fn content_length(path str) -> !int:
    data := os.read_file(path)!
    return data.len()
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="unwrap-or-default-1">Unwrap or default. <a href="#unwrap-or-default-1">#</a></h3>
<p>The <code>!else</code> expression either unwraps a result's payload or defaults to a value:</p>
<pre><code class="language-cy">res := do_something() !else 0
</code></pre>
<p>The default case can be implemented in a block:</p>
<pre><code class="language-cy">res := do_something() !else:
    panic('Failed.')
</code></pre>
<p>The error value can be captured:</p>
<pre><code class="language-cy">res := do_something() !else |err|:
    panic('Failed with %{err}')
</code></pre>
<p>The <code>try</code> block catches thrown errors and resumes execution in a followup <code>catch</code> block:</p>
<pre><code class="language-cy">try:
    funcThatCanFail()
catch err:
    print err      -- 'error.Failed'
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="unwrap-or-guard">Unwrap or guard. <a href="#unwrap-or-guard">#</a></h3>
<p><em>TBD</em></p>
<a href="#error-handling">^topic</a>
<h3 id="unwrap-block">Unwrap block. <a href="#unwrap-block">#</a></h3>
<p>Sometimes it can be useful to catch all errors thrown in a block: <em>TBD</em></p>
<pre><code class="language-cy">try:
    res := do_something()!
    do_even_more_things(res)!
    validate(res)!
    print('Success.')
else |err|:
    panic('Failed with %{err}.')
</code></pre>
<a href="#error-handling">^topic</a>
<h2 id="panics">Panics. <a href="#panics">#</a></h2>
<p>The builtin <code>panic</code> is a fail-fast mechanism to quickly exit the current thread with an error message:</p>
<pre><code class="language-cy">panic('oops')
</code></pre>
<p>Panics can not be caught. Once <code>panic</code> is invoked, the current thread stops execution and begins to unwind its call stack. Afterwards, the thread can not be used and transitions to a panic state.
If the main thread panics, then the program aborts without unwinding other child threads.</p>
<p>A parent thread can obtain the status of a child thread. <em>TBD</em></p>
<p>A panic reports the <a href="#stack-trace" title="">stack trace</a> automatically to the console.</p>
<a href="#error-handling">^topic</a>
<h2 id="stack-traces">Stack traces. <a href="#stack-traces">#</a></h2>
<p>The builtin <code>stack_trace()</code> and <code>stack_trace_info()</code> are used to obtain the stack trace info at any point in the program:</p>
<pre><code class="language-cy">fn some_nested_func():
    -- Prints the stack trace summary.
    print(stack_trace())

    -- Provides structured info about the stack trace.
    info := stack_trace_info()
    print(info.frames.len())
</code></pre>
<a href="#error-handling">^topic</a>
<h1 id="concurrency">Concurrency. <a href="#concurrency">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#threads" title="">Threads.</a><ul>
<li><a href="#spawn-threads" title="">Spawn threads.</a></li>
<li><a href="#sendable-values" title=""><code>Sendable</code> values.</a></li>
<li><a href="#fibers" title="">Fibers.</a></li>
<li><a href="#growable-stacks" title="">Growable stacks.</a></li>
<li><a href="#gas-mileage" title="">Gas mileage.</a></li>
</ul>
</li>
<li><a href="#os-threads" title="">OS threads.</a></li>
<li><a href="#simd" title="">SIMD.</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#futures" title="">Futures.</a><ul>
<li><a href="#future-await" title="">Future <code>await</code>.</a></li>
<li><a href="#future-chains" title="">Future chains.</a></li>
<li><a href="#resolving-futures" title="">Resolving futures.</a></li>
</ul>
</li>
<li><a href="#shared-memory" title="">Shared memory.</a><ul>
<li><a href="#channels" title="">Channels.</a></li>
</ul>
</li>
<li><a href="#await-union" title=""><code>await</code> union.</a></li>
<li><a href="#generators" title="">Generators.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="threads">Threads. <a href="#threads">#</a></h2>
<p>Threads are light-weight virtual threads that have their own execution context and heap memory. The program can spawn many threads but only some of them can run in parallel depending on the operating system and the number of CPU cores.</p>
<p>Threads are isolated from one another and can communicate by message passing or by sharing memory safely.</p>
<a href="#concurrency">^topic</a>
<h3 id="spawn-threads">Spawn threads. <a href="#spawn-threads">#</a></h3>
<p>The builtin <code>spawn</code> creates and starts a new thread with a function as the entry point:</p>
<pre><code class="language-cy">task := spawn(fib, {40})

fn fib(n int) -> int:
    if n < 2:
        return n
    return fib(n - 1) + fib(n - 2)
</code></pre>
<p>Similarly, a thread can be spawned with a lambda as the entry point: <em>TBD</em></p>
<pre><code class="language-cy">task := spawn(|_| -> int, {}):
    -- Do computation.
</code></pre>
<p><code>spawn</code> returns a <code>Result[Future[T]]</code> where <code>T</code> is the return type of the entry function. If the runtime could not dispatch the thread, a panic is raised.
If the thread was dispatched, the wrapped <code>Future</code> contains the asynchronous result of the new thread.</p>
<a href="#concurrency">^topic</a>
<h3 id="sendable-values"><code>Sendable</code> values. <a href="#sendable-values">#</a></h3>
<p>Values that can be transferred from one thread to another must be types that implement <code>Sendable</code>.</p>
<p>Here is a list of common types that implement <code>Sendable</code>:</p>
<ul>
<li>Primitives types: <code>int</code>, <code>byte</code>, <code>bool</code></li>
<li><code>str</code></li>
<li><code>?T</code> if <code>T</code> is <code>Sendable</code></li>
<li><code>!T</code> if <code>T</code> is <code>Sendable</code></li>
<li><code>[]T</code> if <code>T</code> is <code>Sendable</code>. <code>[]T</code> is cloned when sending.</li>
<li><code>Array[T]</code> if <code>T</code>  is <code>Sendable</code></li>
<li><code>Map[K, V]</code> if <code>K</code> and <code>V</code> are <code>Sendable</code></li>
<li><code>[N]T</code> if <code>T</code> is <code>Sendable</code></li>
<li><code>[..N]T</code> if <code>T</code> is <code>Sendable</code></li>
<li>Composite types if all member types are <code>Sendable</code>.</li>
<li>Choice types if all member payload types are <code>Sendable</code>.</li>
<li>Function pointers.</li>
<li><code>Ptr[T]</code>.</li>
</ul>
<p>Types that don't implement <code>Sendable</code> include:</p>
<ul>
<li>Reference types: <code>^T</code>, <code>&T</code>, <code>&&T</code>, <code>[&]T</code>.</li>
<li>Function unions. (Closures are not <code>Sendable</code>)</li>
</ul>
<a href="#concurrency">^topic</a>
<h3 id="fibers">Fibers. <a href="#fibers">#</a></h3>
<p>A fiber is a cooperative execution context that belongs to a parent thread.
It has its own stack but shares the thread's heap: <em>TODO</em></p>
<pre><code class="language-cy">f := Fiber(|_|):
    print('in a fiber')

f.resume()
--> in a fiber
</code></pre>
<p>When a fiber panics, all other fibers in the same thread are terminated.</p>
<p>Fibers are cooperative using a resume and yield mechanism:</p>
<pre><code class="language-cy">fn two_steps():
    print('first')
    Fiber.yield()
    print('last')

f := Fiber(two_steps, {})
f.resume()
--> first

f.resume()
--> last
</code></pre>
<p>When a fiber is destructed, it will panic if it's still in progress:</p>
<pre><code class="language-cy">fn forever():
    while:
        Fiber.yield()

f := Fiber(forever, {})
f.resume()

--> panic: Fiber is still in progress.
</code></pre>
<a href="#concurrency">^topic</a>
<h3 id="growable-stacks">Growable stacks. <a href="#growable-stacks">#</a></h3>
<p>When running on Cyber's VM, threads can grow their stack on demand.
The compiler generates pointer layouts that tells the runtime where pointer values are so they can be patched with new addresses.</p>
<p>Growable stacks allow threads to be lighter. They can be initialized with a smaller stack and grow on demand. However, this feature is not available when compiling AOT where stacks are fixed in size.</p>
<a href="#concurrency">^topic</a>
<h3 id="gas-mileage">Gas mileage. <a href="#gas-mileage">#</a></h3>
<p><em>TBD</em></p>
<a href="#concurrency">^topic</a>
<h2 id="os-threads">OS threads. <a href="#os-threads">#</a></h2>
<p><em>TBD</em></p>
<a href="#concurrency">^topic</a>
<h2 id="simd">SIMD. <a href="#simd">#</a></h2>
<p><em>TBD</em></p>
<a href="#concurrency">^topic</a>
<h2 id="futures">Futures. <a href="#futures">#</a></h2>
<p>A <code>Future</code> is an asynchronous result type. It represents the result of work that will either complete or fail at some point in the future.
This abstraction allows the current thread to continue execution without waiting for the completion of the <code>Future</code>.</p>
<p>Futures can represent asynchronous work that is run in parallel or on a single thread.
I/O bound work can be delegated to the operating system and CPU bound work can be run across multiple threads. A <code>Future</code> is not concerned with how the work is accomplished.</p>
<p>If an API function is meant to do work asynchronously, it would return a <code>Future</code>:</p>
<pre><code class="language-cy">use aio

work := aio.delay(1000)
print(work)
--> Future[void]
</code></pre>
<p>Futures can hold a result value when they are completed:</p>
<pre><code class="language-cy">use aio

work := aio.read_file_defer('foo.txt')
print(work)
--> Future[[]byte]
</code></pre>
<p>Futures can be created with a completed value:</p>
<pre><code class="language-cy">work := Future.complete(100)
print(f)
--> Future[int]

print(f.get().?)
--> 100
</code></pre>
<a href="#concurrency">^topic</a>
<h3 id="future-await">Future <code>await</code>. <a href="#future-await">#</a></h3>
<p><code>Future.await()</code> asynchronously waits for a <code>Future</code> to complete.</p>
<p><code>await</code> suspends the current thread so that the scheduler can resume other threads that are in a ready state.</p>
<p>When <code>await</code> resumes, the expression evaluates to the completed value of the <code>Future</code>:</p>
<pre><code class="language-cy">use aio

work := aio.read_file_defer('foo.txt')
print(work.await())
--> "foo.txt contents"
</code></pre>
<p><code>await</code> can be used in any function which makes asynchronous functions <strong>colorless</strong>. They do not need a special function modifier. This means that asynchronous work can be wrapped in a synchronous API.</p>
<a href="#concurrency">^topic</a>
<h3 id="future-chains">Future chains. <a href="#future-chains">#</a></h3>
<p><code>Future.then_spawn</code> spawns another thread that is when the future completes, thereby creating an asynchronous chain. The runtime prefers to reuse the same worker that completed the future when possible: <em>TBD</em></p>
<pre><code class="language-cy">use aio

res := aio.read_file_defer('foo.txt').then_spawn(|contents|):
    print(contents)
    --> "foo.txt contents"

print(res)
--> Future[void]
</code></pre>
<p>Like <code>spawn</code>, the continuation can return a value:</p>
<pre><code class="language-cy">res := aio.read_file_defer('foo.txt').then_spawn(|contents| -> int):
    return contents.len()

print(res)
--> Future[int]

print(res.await())
--> 3
</code></pre>
<a href="#concurrency">^topic</a>
<h3 id="resolving-futures">Resolving futures. <a href="#resolving-futures">#</a></h3>
<p>A <code>Future</code> can be produced and completed by a <code>FutureResolver</code>: <em>TBD</em></p>
<pre><code class="language-cy">r := FutureResolver(int)
f := r.future()

spawn(|r Resolver|, {r}):
    r.complete(234)

v := f.await()
print(v)
--> 234
</code></pre>
<a href="#concurrency">^topic</a>
<h2 id="shared-memory">Shared memory. <a href="#shared-memory">#</a></h2>
<p><em>TBD</em></p>
<a href="#concurrency">^topic</a>
<h3 id="channels">Channels. <a href="#channels">#</a></h3>
<p><em>TBD</em></p>
<a href="#concurrency">^topic</a>
<h2 id="await-union"><code>await</code> union. <a href="#await-union">#</a></h2>
<p><em>TBD</em></p>
<a href="#concurrency">^topic</a>
<h2 id="generators">Generators. <a href="#generators">#</a></h2>
<p>Generators are stackless coroutines that are intended to yield values incrementally.
A function annotated with <code>#[generator]</code> returns a <code>Generator[Fn]</code> when invoked:</p>
<pre><code class="language-">#[generator]
fn iterate() -> int:
    yield 123
    yield 456

gen := iterate()
print(gen)
--> Generator[fn()->int]
</code></pre>
<p><code>yield</code> pauses the current generator and returns a value back to the call site of <code>Generator.next</code>.</p>
<p>A generator begins and resumes execution with <code>next</code> which returns the next yielded value as an optional:</p>
<pre><code class="language-cy">while gen.next() |res|:
    print(res)
    --> 123
    --> 456
</code></pre>
<p>The current state of a generator can be obtained with <code>Generator.status</code>:</p>
<pre><code class="language-cy">gen := iterate()
print(gen.status())
--> GeneratorStatus.paused

while gen.next() |res|:
    pass

print(gen.status())
--> GeneratorStatus.done
</code></pre>
<p>A generator can be reset to its entry point with the original arguments or different arguments: <em>TBD</em></p>
<a href="#concurrency">^topic</a>
<h1 id="metaprogramming">Metaprogramming. <a href="#metaprogramming">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#compile-time-execution" title="">Compile-time execution.</a><ul>
<li><a href="#inline-evaluation" title="">Inline evaluation.</a></li>
<li><a href="#inline-type-creation" title="">Inline type creation.</a></li>
<li><a href="#if-inline" title=""><code>#if</code> inline.</a></li>
<li><a href="#for-inline" title=""><code>#for</code> inline.</a></li>
<li><a href="#switch-inline" title=""><code>#switch</code> inline.</a></li>
<li><a href="#switch-for-inline" title=""><code>switch #for</code> inline.</a></li>
<li><a href="#compile-time-variables" title="">Compile-time variables.</a></li>
</ul>
</li>
<li><a href="#conditional-compilation" title="">Conditional compilation.</a></li>
<li><a href="#runtime-execution" title="">Runtime execution.</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#meta-module" title=""><code>meta</code> module</a></li>
<li><a href="#reflection" title="">Reflection.</a></li>
<li><a href="#bind-hooks" title=""><code>#bind</code> hooks.</a></li>
<li><a href="#templates" title="">Templates.</a></li>
<li><a href="#generic-types" title="">Generic types.</a></li>
<li><a href="#compile-time-types" title="">Compile-time types.</a><ul>
<li><a href="#type-type" title=""><code>type</code> type.</a></li>
<li><a href="#fnsym-type" title=""><code>fnsym</code> type.</a></li>
<li><a href="#evalstr-type" title=""><code>EvalStr</code> type.</a></li>
<li><a href="#evalint-type" title=""><code>EvalInt</code> type.</a></li>
</ul>
</li>
<li><a href="#attributes" title="">Attributes.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="compile-time-execution">Compile-time execution. <a href="#compile-time-execution">#</a></h2>
<p>Compile-time execution is run during the compilation of the user's program.</p>
<a href="#metaprogramming">^topic</a>
<h3 id="inline-evaluation">Inline evaluation. <a href="#inline-evaluation">#</a></h3>
<p>Inline evaluation is a form of compile-time execution where the code is evaluated as each node in the AST is visited. This can not emulate the entire language but many basic operations can be evaluated and eligible types can be materialized into IR for code generation.</p>
<p>A <code>const</code> declaration evaluates its initializer at compile-time which also evaluates the recursive calls to the <code>fib</code> function:</p>
<pre><code class="language-cy">fn fib(n int) -> int:
    if n < 2:
        return n
    return fib(n - 1) + fib(n - 2)

const fib30 = fib(30)
</code></pre>
<p>An expression needs to be wrapped with <code>#{}</code> to perform inline evaluation if it's not already in a compile-time context:</p>
<pre><code class="language-cy">-- Assign pre-computed value to a local.
res := #{fib(30)}
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="inline-type-creation">Inline type creation. <a href="#inline-type-creation">#</a></h3>
<p>Types can be created from inline evaluation. Currently, only structs can be created with <code>meta.new_struct</code>:</p>
<pre><code class="language-cy">type MyType[T Any] const: 
    struct_t := type.info(T).!struct
    fields := [struct_t.fields.length]meta.StructField({name='', type=void, offset=0, state_offset=0})
    for 0..struct_t.fields.length |i|:
        field := struct_t.fields[i]
        fields[i] = {
            name = 'myfield' + str(i),
            type = field.type,
            offset = 0,
            state_offset = 0,
        }
    return meta.new_struct(fields, {})
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="if-inline"><code>#if</code> inline. <a href="#if-inline">#</a></h3>
<p>The <code>#if</code> statement performs inline evaluation on the condition expression and inserts it's child statements if the condition evaluates to <code>true</code>:</p>
<pre><code class="language-cy">#if meta.system() == .windows:
    print('Running on Windows.')
#else:
    print('Running on %{meta.system()}')
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="for-inline"><code>#for</code> inline. <a href="#for-inline">#</a></h3>
<p>The <code>#for</code> statement iterates at compile-time and inserts it's child statements on every iteration. The following prints the name of every field in the type <code>Foo</code>:</p>
<pre><code class="language-cy">#struct_t := type.info(Foo).!struct
#for 0..struct_t.fields.length |i|:
    #field := struct_t.fields[i]
    print(#{field.name})
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="switch-inline"><code>#switch</code> inline. <a href="#switch-inline">#</a></h3>
<p>The <code>#switch</code> statement evaluates at compile-time and inserts the child statements of the matching case block:</p>
<pre><code class="language-cy">#switch type.info(T):
    #case .struct |struct_t|:
        print('a struct')
    #case .option |option_t|:
        print('an optional')
    #else:
        print('unsupported')
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="switch-for-inline"><code>switch #for</code> inline. <a href="#switch-for-inline">#</a></h3>
<p>A regular <code>switch</code> statement with a <code>#for</code> block can automatically expand all <code>case</code> statements:</p>
<pre><code class="language-cy">switch value:
    #for meta.enum_values(MyEnum) |Tag|:
        case Tag:
            print('value is a %{Tag}')
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="compile-time-variables">Compile-time variables. <a href="#compile-time-variables">#</a></h3>
<p>Compile-time variables are assigned with a leading <code>#</code>:</p>
<pre><code class="language-cy">#info := type.info(Foo)
</code></pre>
<a href="#metaprogramming">^topic</a>
<h2 id="conditional-compilation">Conditional compilation. <a href="#conditional-compilation">#</a></h2>
<p><em>TBD</em></p>
<a href="#metaprogramming">^topic</a>
<h2 id="runtime-execution">Runtime execution. <a href="#runtime-execution">#</a></h2>
<p>The <code>cy</code> module provides an API to <a href="#libcyber" title="">libcyber</a>.</p>
<p><code>cy.eval</code> evaluates source code in an isolated VM:</p>
<pre><code class="language-cy">use cy

res := cy.eval('''
fn main() -> int:
    return 1 + 2
''')!
print(res)
--> 3
</code></pre>
<a href="#metaprogramming">^topic</a>
<h2 id="meta-module"><code>meta</code> module. <a href="#meta-module">#</a></h2>
<p>The <code>meta</code> module contains metaprogramming utilities. See the <a href="api.html#meta" title=""><code>meta</code> docs</a>.</p>
<a href="#metaprogramming">^topic</a>
<h2 id="reflection">Reflection. <a href="#reflection">#</a></h2>
<p><code>type.info</code> returns compile-time type info. See <a href="api.html#meta" title=""><code>TypeInfo</code> docs</a>:</p>
<pre><code class="language-cy">#info := type.info(Foo).!struct
#meta.log(info.fields.length)
</code></pre>
<p>Runtime type info is currently limited to a name and ID:</p>
<pre><code class="language-cy">rt_type := MetaType(Foo)
print(rt_type.id())
--> 123

print(rt_type.name())
--> Foo
</code></pre>
<a href="#metaprogramming">^topic</a>
<h2 id="bind-hooks"><code>#[bind]</code> hooks. <a href="#bind-hooks">#</a></h2>
<p>The <code>#[bind]</code> annotation creates a compiler hook for a type or function declaration.
<a href="#libcyber" title=""><code>libcyber</code></a> allows an embedder to register these hooks.
Many of the builtins in Cyber core and std modules are implemented using these bind hooks.</p>
<a href="#metaprogramming">^topic</a>
<h2 id="templates">Templates. <a href="#templates">#</a></h2>
<p>Templates generate varying types and functions with template parameters.
See <a href="#type-templates" title="">Custom types / Type templates</a> and <a href="#function-templates" title="">Functions / Function templates</a>.</p>
<a href="#metaprogramming">^topic</a>
<h2 id="generic-types">Generic types. <a href="#generic-types">#</a></h2>
<p>Generic types are type constraints for parametric polymorphism. They aren't concrete types themselves but rather a placeholder that constrains an input type. They are used in template parameters and generic function parameters.</p>
<p>The <code>Any</code> type is a generic type that has no constraints, allowing any <code>type</code>:</p>
<pre><code class="language-cy">type MyContainer[T Any]:
    inner T
</code></pre>
<p>Traits are considered generic types and constrain types to those that implement its interface:</p>
<pre><code class="language-cy">type Shape trait:
    fn area() -> float

fn less(a Shape, b Shape):
    return a.area() < b.area()
</code></pre>
<p>When a function parameter contains a generic type, the function becomes generic. The function is then specialized by the call site arguments.</p>
<p>Type templates are considered generic types: <em>TBD</em></p>
<pre><code class="language-cy">fn size(c MyContainer) -> int:
    return type.size(type.of(c))
</code></pre>
<p>Composing a generic type creates another generic type: <em>TBD</em></p>
<pre><code class="language-cy">fn size(c ?MyContainer) -> int:
    return type.size(type.of(c))
</code></pre>
<a href="#metaprogramming">^topic</a>
<h2 id="compile-time-types">Compile-time types. <a href="#compile-time-types">#</a></h2>
<p>Some types can only be used at compile-time.</p>
<a href="#metaprogramming">^topic</a>
<h3 id="type-type"><code>type</code> type. <a href="#type-type">#</a></h3>
<p>A <code>type</code> represents a compiler type symbol and only exists at compile-time.</p>
<a href="#metaprogramming">^topic</a>
<h3 id="fnsym-type"><code>fnsym</code> type. <a href="#fnsym-type">#</a></h3>
<p>An <code>fnsym</code> represents a compiler function symbol that can be expanded to a runtime function pointer or a function call. They can be used as parameterized values:</p>
<pre><code class="language-cy">type IntMap[K Any, const HASH fnsym(K)->int]
    ptr [*]int
    len int

fn (&IntMap[]) get(key K) -> int:
    slot := HASH(key) % self.len
    return self.ptr[slot]

fn my_hash(s str) -> int:
    return s.len()

m := IntMap[str, my_hash]{}
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="evalstr-type"><code>EvalStr</code> type. <a href="#evalstr-type">#</a></h3>
<p><code>EvalStr</code> can be expanded to a <code>str</code>, <code>[]byte</code>, zero terminated <code>Ptr[byte]</code>, <code>int</code>, or <code>byte</code>.</p>
<a href="#metaprogramming">^topic</a>
<h3 id="evalint-type"><code>EvalInt</code> type. <a href="#evalint-type">#</a></h3>
<p><code>EvalInt</code> can be expanded to different integer types. Currently, it has the extent of an <code>int</code> type.</p>
<a href="#metaprogramming">^topic</a>
<h2 id="attributes">Attributes. <a href="#attributes">#</a></h2>
<p><em>TBD</em></p>
<a href="#metaprogramming">^topic</a>
<h1 id="modules">Modules. <a href="#modules">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#main-module" title="">Main module.</a></li>
<li><a href="#main-function" title="">Main function.</a></li>
<li><a href="#builtin-modules" title="">Builtin modules.</a></li>
<li><a href="#importing" title="">Importing.</a><ul>
<li><a href="#import-file" title="">Import file.</a></li>
<li><a href="#import-url" title="">Import URL.</a></li>
<li><a href="#import-all" title="">Import all.</a></li>
<li><a href="#circular-imports" title="">Circular imports.</a></li>
<li><a href="#destructure-import" title="">Destructure import.</a></li>
</ul>
</li>
<li><a href="#exporting" title="">Exporting.</a></li>
<li><a href="#symbol-visibility" title="">Symbol visibility.</a></li>
<li><a href="#symbol-alias" title="">Symbol alias.</a></li>
</ul>
</td><td valign="top">
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Modules have their own namespace of static symbols. By default, importing another Cyber script returns a module with its declared symbols.</p>
<h2 id="main-module">Main module. <a href="#main-module">#</a></h2>
<p>The main module can contain top-level imperative statements if no main function is declared.
An imported module containing top-level statements returns an error:</p>
<pre><code class="language-cy">-- main.cy
print('ok')

-- foo.cy
print('not ok')         
-- error: Top-level statement not allowed.
</code></pre>
<a href="#modules">^topic</a>
<h2 id="main-function">Main function. <a href="#main-function">#</a></h2>
<p>The main module can contain a main function. It's the starting point for a program:</p>
<pre><code class="language-cy">fn main():
    print('program start')
</code></pre>
<a href="#modules">^topic</a>
<h2 id="builtin-modules">Builtin modules. <a href="#builtin-modules">#</a></h2>
<p>Builtin and std modules come with Cyber. See the <a href="api.html" title="">API docs</a>.</p>
<a href="#modules">^topic</a>
<h2 id="importing">Importing. <a href="#importing">#</a></h2>
<p>The <code>use</code> statement can import modules. Builtin and std modules such as <code>math</code> can be imported without any configuration:</p>
<pre><code class="language-cy">use math

print(math.cos(0))
</code></pre>
<p>When a <code>use</code> statement contains only a single identifier, it reuses the module name as the local name.</p>
<p>To bind to a different local name, the <code>use</code> statement requires a name before the import specifier. Note that this also requires the import specifier to be a string literal:</p>
<pre><code class="language-cy">use m 'math'

print(m.random())
</code></pre>
<a href="#modules">^topic</a>
<h3 id="import-file">Import file. <a href="#import-file">#</a></h3>
<p>Source files can be imported from the local file system:</p>
<pre><code class="language-cy">-- Importing a module from the local directory.
use b 'bar.cy'

print(b.myFunc())
print(b.myVar)
</code></pre>
<a href="#modules">^topic</a>
<h3 id="import-url">Import URL. <a href="#import-url">#</a></h3>
<p>Source files can be imported from the Internet:</p>
<pre><code class="language-cy">-- Importing a module from a CDN.
use rl 'https://mycdn.com/raylib'
</code></pre>
<p>When importing a URL without a file name, Cyber's CLI will look for a <code>mod.cy</code> from the path instead.</p>
<a href="#modules">^topic</a>
<h3 id="import-all">Import all. <a href="#import-all">#</a></h3>
<p>If the alias name is the wildcard character, all symbols from the module are imported into the using namespace: <em>This feature is experimental and may be removed in a future version.</em></p>
<pre><code class="language-cy">use * 'math'

print(random())
</code></pre>
<a href="#modules">^topic</a>
<h3 id="circular-imports">Circular imports. <a href="#circular-imports">#</a></h3>
<p>Circular imports are allowed. In the following example, <code>main.cy</code> and <code>foo.cy</code> import each other without problems.</p>
<pre><code class="language-cy">-- main.cy
use foo 'foo.cy'

fn print_b():
    foo.print_c()

foo.print_a()

-- foo.cy
use main 'main.cy'

fn print_a():
    main.print_b()

fn print_c():
    print('done')
</code></pre>
<p>However, this doesn't imply that circular symbol dependencies are allowed. Different symbols have their own rules for circular dependencies.</p>
<a href="#modules">^topic</a>
<h3 id="destructure-import">Destructure import. <a href="#destructure-import">#</a></h3>
<p>Modules can also be destructured using the following syntax:</p>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><pre><code class="language-cy">use { cos, pi } 'math'

print(cos(pi))
</code></pre>
<a href="#modules">^topic</a>
<h2 id="exporting">Exporting. <a href="#exporting">#</a></h2>
<p>All symbols are exported by default without any additional modifiers:</p>
<pre><code class="language-cy">fn foo():          
    pass

global state int = 234

type Foo:
    a float
</code></pre>
<p>Any symbol alias declared from <code>use</code> is not exported:</p>
<pre><code class="language-cy">-- Not visible from other modules.
use math
</code></pre>
<a href="#modules">^topic</a>
<h2 id="symbol-visibility">Symbol visibility. <a href="#symbol-visibility">#</a></h2>
<p>Symbols can have private visibility when declared with a <code>-</code> prefix.
This only allows the source module to access the symbol:</p>
<pre><code class="language-cy">-type Foo:
    a int
    b int

-fn add(a, b int) -> int:
    return a + b
</code></pre>
<a href="#modules">^topic</a>
<h2 id="symbol-alias">Symbol alias. <a href="#symbol-alias">#</a></h2>
<p><code>use</code> can create an alias to another symbol:</p>
<pre><code class="language-cy">use eng 'lib/engine.cy'

use Vec2 -> eng.Vector2
</code></pre>
<a href="#modules">^topic</a>
<h1 id="ffi">FFI. <a href="#ffi">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#c-primitives" title="">C primitives.</a></li>
<li><a href="#pointers-1" title="">Pointers.</a><ul>
<li><a href="#address-of" title="">Address of.</a></li>
<li><a href="#dereferencing-pointers" title="">Dereferencing pointers.</a></li>
<li><a href="#pointer-indexing" title="">Pointer indexing.</a></li>
<li><a href="#pointer-arithmetic" title="">Pointer arithmetic.</a></li>
</ul>
</li>
<li><a href="#pointer-spans" title="">Pointer spans.</a></li>
<li><a href="#c-strings" title="">C strings.</a></li>
<li><a href="#c-structs" title="">C structs.</a></li>
<li><a href="#c-unions" title="">C unions.</a></li>
<li><a href="#zero-values" title="">Zero values.</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#binding-to-c" title="">Binding to C.</a><ul>
<li><a href="#static-binding" title="">Static binding.</a></li>
<li><a href="#runtime-binding" title="">Runtime binding.</a></li>
<li><a href="#open_lib-binding" title=""><code>open_lib</code> binding.</a></li>
<li><a href="#extern-functions" title=""><code>extern</code> functions.</a></li>
<li><a href="#extern-globals" title=""><code>extern</code> variables.</a></li>
<li><a href="#cbindgency" title="">cbindgen.cy</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="c-primitives">C primitives. <a href="#c-primitives">#</a></h2>
<p><a href="api.html#c" title="">mod c</a> contains aliases to C types that are compiler/architecture dependent. These can be used when generating bindings or interfacing with C.</p>
<p>This table maps Cyber to C primitive types:</p>
<table><thead><tr><th>Cyber</th><th>C</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>void</code></td></tr><tr><td><code>i8</code></td><td><code>int8_t</code></td></tr><tr><td><code>r8</code>, <code>byte</code></td><td><code>uint8_t</code></td></tr><tr><td><code>c_char</code></td><td><code>char</code></td></tr><tr><td><code>i16</code></td><td><code>int16_t</code></td></tr><tr><td><code>r16</code></td><td><code>uint16_t</code></td></tr><tr><td><code>c_short</code></td><td><code>short</code></td></tr><tr><td><code>c_ushort</code></td><td><code>unsigned short</code></td></tr><tr><td><code>i32</code></td><td><code>int32_t</code></td></tr><tr><td><code>r32</code></td><td><code>uint32_t</code></td></tr><tr><td><code>c_int</code></td><td><code>int</code></td></tr><tr><td><code>c_uint</code></td><td><code>unsigned int</code></td></tr><tr><td><code>i64</code>, <code>int</code></td><td><code>int64_t</code></td></tr><tr><td><code>r64</code></td><td><code>uint64_t</code></td></tr><tr><td><code>c_long</code></td><td><code>long</code></td></tr><tr><td><code>c_ulong</code></td><td><code>unsigned long</code></td></tr><tr><td><code>c_longlong</code></td><td><code>long long</code></td></tr><tr><td><code>c_ulonglong</code></td><td><code>unsigned long long</code></td></tr><tr><td><code>f32</code></td><td><code>float</code></td></tr><tr><td><code>f64</code>, <code>float</code></td><td><code>double</code></td></tr><tr><td><code>N/A</code></td><td><code>long double</code></td></tr><tr><td><code>Ptr[T]</code></td><td><code>T*</code></td></tr></tbody></table><a href="#ffi">^topic</a>
<h2 id="pointers-1">Pointers. <a href="#pointers-1">#</a></h2>
<p>A <code>Ptr[T]</code> type is an unmanaged reference type to the address of a <code>T</code> value.
<code>none</code> evaluates to NULL or 0:</p>
<pre><code class="language-cy">var ptr Ptr[int] = none
</code></pre>
<p>An address can be casted to a pointer type:</p>
<pre><code class="language-cy">var ptr Ptr[int] = as 0xDEADBEEF
</code></pre>
<a href="#ffi">^topic</a>
<h3 id="address-of">Address of. <a href="#address-of">#</a></h3>
<p>The <code>*</code> operator returns the address to a value as a pointer <code>Ptr[T]</code>:</p>
<pre><code class="language-cy">value := 123
ptr := *value
ptr.* = 1000

print(value.x)
--> 1000
</code></pre>
<p>The right side of a <code>*</code> has higher precedence so it can refer to an inner member:</p>
<pre><code class="language-cy">type Vec2 cstruct:
    x float
    y float

v := Vec2{}
ptr := *v.x
</code></pre>
<a href="#ffi">^topic</a>
<h3 id="dereferencing-pointers">Dereferencing pointers. <a href="#dereferencing-pointers">#</a></h3>
<p>Pointers are dereferenced with the <code>.*</code> operator:</p>
<pre><code class="language-cy">a := 123
ptr := *a
print(ptr.*)
--> 123

ptr.* = 10
print(a)
--> 10
</code></pre>
<p>Accessing a member automatically dereferences the parent pointer:</p>
<pre><code class="language-cy">type Vec2 cstruct:
    x float
    y float

v := Vec2{x=30, y=40}
ptr := *v
print(ptr.x)   --> 30
</code></pre>
<a href="#ffi">^topic</a>
<h3 id="pointer-indexing">Pointer indexing. <a href="#pointer-indexing">#</a></h3>
<p>The index operator can access the nth element:</p>
<pre><code class="language-cy">arr := alloc(int, 10).ptr
arr[5] = 123
print(arr[5])
--> 123
</code></pre>
<p>Negative indexing will locate the element before the pointer's address.</p>
<p>Slicing returns a new span <code>PtrSpan[T]</code> over the given range:</p>
<pre><code class="language-cy">span := arr[0..5]
</code></pre>
<a href="#ffi">^topic</a>
<h3 id="pointer-arithmetic">Pointer arithmetic. <a href="#pointer-arithmetic">#</a></h3>
<p>Addition advances the address of <code>Ptr[T]</code> by the size of <code>T</code>:</p>
<pre><code class="language-cy">arr := alloc(int, 10).ptr
arr += 1
(arr + 3).* = 234
print((arr + 3).*)    --> 234
</code></pre>
<p>Subtraction between two pointers of the same type returns the difference in units of <code>T</code>:</p>
<pre><code class="language-cy">fn pc_off(base Ptr[Inst], pc Ptr[Inst]) -> int:
    return pc - base
</code></pre>
<a href="#ffi">^topic</a>
<h2 id="pointer-spans">Pointer spans. <a href="#pointer-spans">#</a></h2>
<p>Pointer spans contains a pointer and a length. The type is denoted as <code>PtrSpan[T]</code> where <code>T</code> is the element type.</p>
<p>Read and write to the nth element with the index operator:</p>
<pre><code class="language-cy">span := alloc(int, 10)
print(span[0])
--> 1

span[1] = 123
print(span[1])
--> 123
</code></pre>
<p>A <code>PtrSpan</code> has bounds checking when runtime safety is enabled:</p>
<pre><code class="language-cy">print(s[100])
--> panic: Out of bounds.
</code></pre>
<p>A <code>PtrSpan</code> can be sliced:</p>
<pre><code class="language-cy">a := span[0..2]
</code></pre>
<a href="#ffi">^topic</a>
<h2 id="c-strings">C strings. <a href="#c-strings">#</a></h2>
<p>There are utilities in the <code>c</code> module to convert between <code>str</code> and a zero terminated C string:</p>
<pre><code class="language-cy">use c

s := c.from_strz('c string')
c_str := c.to_strz(s)
</code></pre>
<p>A <code>str</code> can also be constructed with zero appended as the last character. Since <code>str</code> is a managed type, it doesnt need an explicit free:</p>
<pre><code class="language-cy">sz := str.initz('c string')
</code></pre>
<a href="#ffi">^topic</a>
<h2 id="c-structs">C structs. <a href="#c-structs">#</a></h2>
<p>A <code>cstruct</code> type mimics the memory layout of a C struct type:</p>
<pre><code class="language-cy">type Data cstruct:
    x   float
    y   float
    ptr Ptr[int]
</code></pre>
<p>A <code>cstruct</code> may contain:</p>
<ul>
<li>C structs/unions types.</li>
<li>Primitive types.</li>
<li><code>enum</code> types.</li>
</ul>
<a href="#ffi">^topic</a>
<h2 id="c-unions">C unions. <a href="#c-unions">#</a></h2>
<p>A <code>cunion</code> type mimics the memory layout of a C union type:</p>
<pre><code class="language-cy">type Data cunion:
    case i int
    case f float
    case s Foo
</code></pre>
<p>A <code>cunion</code> may contain:</p>
<ul>
<li>C structs/unions types.</li>
<li>Primitive types.</li>
<li><code>enum</code> types.</li>
</ul>
<p>A <code>cunion</code> type is constructed with a case wrapping its payload:</p>
<pre><code class="language-cy">cdata := Data.i(123)

print(cdata.i)
--> 123
</code></pre>
<a href="#ffi">^topic</a>
<h2 id="zero-values">Zero values. <a href="#zero-values">#</a></h2>
<p>Uninitialized C struct members default to their zero values:</p>
<pre><code class="language-cy">type Vec2 cstruct:
    x float
    y float

v := Vec2{}
print(v.x)      --> 0
print(v.y)      --> 0
</code></pre>
<p>The following shows the zero values of C and C compatible types:</p>
<table><thead><tr><th>Type</th><th>Zero value</th></tr></thead><tbody><tr><td><code>bool</code></td><td><code>false</code></td></tr><tr><td><code>i8</code></td><td><code>0</code></td></tr><tr><td><code>i16</code></td><td><code>0</code></td></tr><tr><td><code>i32</code></td><td><code>0</code></td></tr><tr><td><code>i64</code>, <code>int</code></td><td><code>0</code></td></tr><tr><td><code>r8</code>, <code>byte</code></td><td><code>0</code></td></tr><tr><td><code>r16</code></td><td><code>0</code></td></tr><tr><td><code>r32</code></td><td><code>0</code></td></tr><tr><td><code>r64</code></td><td><code>0</code></td></tr><tr><td><code>f32</code></td><td><code>0.0</code></td></tr><tr><td><code>f64</code>, <code>float</code></td><td><code>0.0</code></td></tr><tr><td><code>Ptr[T]</code></td><td><code>none</code></td></tr><tr><td><code>type T cstruct</code></td><td><code>{}</code></td></tr><tr><td><code>type T cunion</code></td><td><code>{}</code></td></tr></tbody></table><a href="#ffi">^topic</a>
<h2 id="binding-to-c">Binding to C. <a href="#binding-to-c">#</a></h2>
<p>Cyber supports binding to an existing C ABI compatible library at runtime.
This allows calling into dynamic libraries created in C or other languages.
When compiled AOT, the libraries can be linked statically.</p>
<p>There are different approaches to binding a C library:</p>
<ol>
<li>Static binding. The application and C library is compiled into a single executable.</li>
<li>Runtime binding. The C library is loaded and binded upon program start-up.</li>
<li><code>os.open_lib</code> binding. The user is responsible for loading the C library at runtime.</li>
<li>When embedding <a href="#libcyber" title=""><code>libcyber</code></a>, compiler hooks can bind VM or C functions with the host language.</li>
</ol>
<a href="#ffi">^topic</a>
<h3 id="static-binding">Static binding. <a href="#static-binding">#</a></h3>
<p>When targeting the C backend, the C library's source or static library can be included for compilation. The final output will be a statically linked executable. <em>TODO</em></p>
<p><code>extern</code> functions and variables are required to link with the C library. They can be autogenerated with <a href="#cbindgency" title=""><code>cbindgen.cy</code></a> and the library's header file.</p>
<p>Source code for the library can be declared with <code>c.source</code>:</p>
<pre><code class="language-cy">use c

#c.source('mylib.c')
</code></pre>
<p><code>cc</code> build flags can be declared with <code>c.flag</code>:</p>
<pre><code class="language-cy">#if meta.system() == .macos:
    #c.flag('-Dmacos')
</code></pre>
<p>A static library can be linked with <code>c.static_lib</code>:</p>
<pre><code class="language-cy">#c.static_lib('mylib.a')
</code></pre>
<a href="#ffi">^topic</a>
<h3 id="runtime-binding">Runtime binding. <a href="#runtime-binding">#</a></h3>
<p>Cyber uses <code>libtcc</code> to JIT compile the bindings from <code>extern</code> declarations.
An example can be found in <a href="https://github.com/fubark/cyber/blob/master/examples/ffi.cy" title="">ffi.cy</a>.</p>
<p><code>#extern</code> bindings are resolved from a dynamic library upon program startup.</p>
<p><code>c.bind_lib</code> tells the compiler where to look for the dynamic library. The extern declarations in the same module are then resolved at runtime:</p>
<pre><code class="language-cy">#c.bind_lib('mylib.dylib')
</code></pre>
<p>A module can be configured to use static binding when building an executable or a runtime binding for faster iterations. The same <code>#extern</code> declarations are reused in both cases:</p>
<pre><code class="language-cy">#if meta.is_vm_target():
    #c.bind_lib('mylib.dylib')
</code></pre>
<a href="#ffi">^topic</a>
<h3 id="open_lib-binding"><code>open_lib</code> binding. <a href="#open_lib-binding">#</a></h3>
<p><em>TODO</em></p>
<p>If the path argument to <code>open_lib</code> is just a filename, the search steps for the library is specific to the operating system. Provide an absolute (eg. '/foo/mylib.so') or relative (eg. './mylib.so') path to load from a direct location instead. When the path argument is <code>none</code>, it loads the currently running executable as a library.</p>
<a href="#ffi">^topic</a>
<h3 id="extern-functions"><code>extern</code> functions. <a href="#extern-functions">#</a></h3>
<p>An <code>extern</code> function is configured with a C call convention and registered for static or runtime binding:</p>
<pre><code class="language-cy">#[extern]
fn SDL_CreateWindow(title Ptr[c_char], w c_int, h c_int, flags WindowFlags) -> Ptr[Window]
</code></pre>
<p>An extern symbol name can be declared if it differs from the API name:</p>
<pre><code class="language-cy">#[extern='SDL_CreateWindow']
fn CreateWindow(title Ptr[c_char], w c_int, h c_int, flags WindowFlags) -> Ptr[Window]
</code></pre>
<p>The example above would be bound to this C function:</p>
<pre><code class="language-c">SDL_Window* SDL_CreateWindow(const char *title, int w, int h, SDL_WindowFlags flags);
</code></pre>
<a href="#ffi">^topic</a>
<h3 id="extern-globals"><code>extern</code> globals. <a href="#extern-globals">#</a></h3>
<p>An <code>extern</code> global is registered for static or runtime binding: <em>TBD</em></p>
<pre><code class="language-cy">#[extern] global count Ptr[int]
</code></pre>
<p>Note that an <code>extern</code> global requires a pointer type.</p>
<a href="#ffi">^topic</a>
<h2 id="cbindgency">cbindgen.cy <a href="#cbindgency">#</a></h2>
<p><a href="https://github.com/fubark/cyber/blob/master/src/tools/cbindgen.cy" title="">cbindgen.cy</a> is a script that automatically generates bindings given a C header file. Some example bindings that were generated include: <a href="https://github.com/fubark/ray-cyber" title="">Raylib</a>, <a href="https://github.com/fubark/cyber/blob/master/src/x/sdl" title="">SDL3</a>, <a href="https://github.com/fubark/cyber/blob/master/src/x/vk" title="">Vulkan</a>, and <a href="https://github.com/fubark/cyber/blob/master/src/tools/llvm.cy" title="">LLVM</a>.</p>
<a href="#ffi">^topic</a>
<h1 id="libcyber">libcyber. <a href="#libcyber">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#create-vm" title="">Create VM.</a></li>
<li><a href="#override-print" title="">Override <code>print</code>.</a></li>
<li><a href="#eval-script" title="">Eval script.</a><ul>
<li><a href="#eval-return" title="">Eval return.</a></li>
</ul>
</li>
<li><a href="#module-loader" title="">Module loader.</a></li>
<li><a href="#function-binding" title="">Function binding.</a><ul>
<li><a href="#vm-functions" title="">VM functions.</a></li>
</ul>
</li>
<li><a href="#global-binding" title="">Global binding.</a></li>
<li><a href="#type-binding" title="">Type binding.</a></li>
</ul>
</td><td valign="top">
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p><code>libcyber</code> allows embedding the Cyber compiler and VM into an application. Cyber's builtin types, functions, and the CLI app were built using <code>libcyber</code>.</p>
<p>The API is defined in the <a href="https://github.com/fubark/cyber/blob/master/src/include/cyber.h" title="">C header file</a>.
The examples shown below can be found in the repository under <a href="https://github.com/fubark/cyber/blob/master/examples/libcyber" title="">libcyber</a>. The examples are in C, but it can be easily translated to C++ or any C-ABI compatible language.</p>
<p>Types and constants from the C-API begin with <code>CL</code> and functions begin with <code>cl</code>.</p>
<h2 id="create-vm">Create VM. <a href="#create-vm">#</a></h2>
<p>A VM instance is required to compile and interpret Cyber code. To create a new VM instance, call <code>cl_vm_init</code>:</p>
<pre><code class="language-c">#include "cyber.h"

int main() {
    CLVM* vm = cl_vm_init();
    // ...
    cl_vm_deinit(vm);
    return 0;
}
</code></pre>
<a href="#libcyber">^topic</a>
<h2 id="override-print">Override <code>print</code>. <a href="#override-print">#</a></h2>
<p>The builtin <code>print</code> function does nothing by default, so it needs to be overrided to print to stdout for example:</p>
<pre><code class="language-c">void printer(CLThread* t, CLBytes str) {
    printf("Invoked printer: %.*s\n", (int)str.len, str.buf);
}

int main() {
    // ...
    cl_vm_set_printer(vm, printer);
    // ...
}
</code></pre>
<p>Note that <code>prints</code> invokes printer once. But <code>print</code> invokes the printer twice, once for the value's string and another for the new line character.</p>
<p>Similarly, <code>eprint</code>, and <code>log</code> can also be overridden:</p>
<pre><code class="language-c">void eprinter(CLThread* vm, CLBytes str) {
    fprintf(stderr, "Invoked eprinter: %.*s\n", (int)str.len, str.buf);
}

void logger(CLThread* vm, CLBytes str) {
    fprintf(stderr, "Invoked log: %.*s\n", (int)str.len, str.buf);
}

int main() {
    // ...
    cl_vm_set_eprinter(vm, eprinter);
    cl_vm_set_logger(vm, logger);
    // ...
}
</code></pre>
<a href="#libcyber">^topic</a>
<h2 id="eval-script">Eval script. <a href="#eval-script">#</a></h2>
<p><code>cl_vm_eval</code> compiles and evaluates a script.</p>
<pre><code class="language-c">CLBytes src = CL_BYTES(
    "a := 1\n"
    "print(a + 2)\n"
);

CLEvalResult res;
CLResultCode code = cl_vm_eval(vm, src, &res);
if (code == CL_SUCCESS) {
    printf("Success!\n");
} else {
    CLBytes summary = cl_vm_error_summary(vm);
    printf("%.*s\n", (int)summary.len, summary.buf);
    cl_vm_freeb(vm, summary);
}
</code></pre>
<p><code>cl_vm_eval</code> returns a result code that indicates whether it was successful.</p>
<a href="#libcyber">^topic</a>
<h3 id="eval-return">Eval return. <a href="#eval-return">#</a></h3>
<p>To return a value back to the host, a main function with a return type is required:</p>
<pre><code class="language-c">CLBytes src = CL_BYTES(
    "fn main() -> int:"
    "  a := 1\n"
    "  return a + 2\n"
);

CLEvalResult res;
cl_vm_eval(vm, src, &res);
if (code == CL_SUCCESS) {
    printf("returned %lld\n", *(int64_t*)res.res);
}
</code></pre>
<a href="#libcyber">^topic</a>
<h2 id="module-loader">Module loader. <a href="#module-loader">#</a></h2>
<p>A module loader is set with <code>cl_vm_set_loader</code>.
It describes how a module is loaded when triggered by a <code>use</code> import statement:</p>
<pre><code class="language-c">bool loader(CLVM* vm, CLSym* mod, CLBytes uri, CLLoaderResult* res) {
    if (strncmp("my_mod", uri.ptr, uri.len) == 0) {
        const char* src = (
            "#[bind] fn add(a, b float) -> float\n"
            "#[bind] global my_global float\n"
            "\n"
            "type MyNode:\n"
            "  data float\n"
            "\n"
            "#[bind] fn MyNode :: @init() -> MyNode\n"
            "#[bind] fn (&MyNode) @deinit()\n"
            "#[bind] fn (&MyNode) compute() -> float\n"
        );

        cl_mod_add_func(mod, CL_BYTES("add"), CL_BIND_FUNC(add));
        cl_mod_add_func(mod, CL_BYTES("MyNode.@init"), CL_BIND_FUNC(mynode_init));
        cl_mod_add_func(mod, CL_BYTES("MyNode.@deinit"), CL_BIND_FUNC(mynode_deinit));
        cl_mod_add_func(mod, CL_BYTES("MyNode.compute"), CL_BIND_FUNC(mynode_compute));
        cl_mod_add_global(mod, CL_BYTES("my_global"), CL_BIND_GLOBAL(&myglobal));

        res->src = CL_BYTES(src);
        return true;
    } else {
        // Fallback to the default module loader to load builtin modules such as `core`.
        return cl_default_loader(vm, mod, uri, res);
    }
}

int main() {
    //...
    cl_vm_set_loader(vm, loader);
    //...
}
</code></pre>
<p>The above example loads <code>my_mod</code> by setting the appropriate function and global bindings, and returning its source code. Other modules get delegated to the default loader <code>cl_default_loader</code> which knows how to load the builtin modules such as <code>core</code>.</p>
<a href="#libcyber">^topic</a>
<h2 id="function-binding">Function binding. <a href="#function-binding">#</a></h2>
<p>A function binding describes how to load a <code>#[bind]</code> function.</p>
<a href="#libcyber">^topic</a>
<h3 id="vm-functions">VM functions. <a href="#vm-functions">#</a></h3>
<p>A VM function binding is created with <code>CL_BIND_FUNC()</code> and mapped to a module function name with <code>cl_mod_add_func</code>:</p>
<pre><code class="language-c">// ...
cl_mod_add_func(mod, CL_BYTES("add"), CL_BIND_FUNC(add));
// ...
</code></pre>
<p>A VM function is a C function that the VM can call into. Cyber is a statically typed language so it requires the return and parameters to be defined by how much space they occupy on the stack:</p>
<pre><code class="language-c">CLRet add(CLThread* t) {
    double* ret = cl_thread_ret(t, sizeof(double));
    double a = cl_thread_float(t);
    double b = cl_thread_float(t);
    *ret = a * b;
    return CL_RET_OK;
}
</code></pre>
<a href="#libcyber">^topic</a>
<h2 id="global-binding">Global binding. <a href="#global-binding">#</a></h2>
<p>A global binding describes how to load a <code>#[bind]</code> global:</p>
<pre><code class="language-c">double myglobal = 234.0;

// ..
cl_mod_add_global(mod, CL_BYTES("my_global"), CL_BIND_GLOBAL(&myglobal));
// ..
</code></pre>
<a href="#libcyber">^topic</a>
<h2 id="type-binding">Type binding. <a href="#type-binding">#</a></h2>
<p>A type binding describes how to load a <code>#[bind]</code> type:
<em>TODO: example</em></p>
<p>Types in Cyber have the same memory layout as a C type (assuming the member types are mapped correctly):</p>
<pre><code class="language-cy">-- Cyber
type MyNode:
    data float
</code></pre>
<pre><code class="language-c">// C
typedef struct MyNode {
    double data;
} MyNode;
</code></pre>
<a href="#libcyber">^topic</a>
<h1 id="cli">CLI. <a href="#cli">#</a></h1>
<ul>
<li><a href="#run-program" title="">Run program.</a></li>
<li><a href="#help" title="">Help.</a></li>
<li><a href="#repl" title="">REPL.</a></li>
<li><a href="#jit-compiler" title="">JIT compiler.</a></li>
<li><a href="#c-backend" title="">C backend.</a></li>
</ul>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="run-program">Run program. <a href="#run-program">#</a></h2>
<p>When given the main source file, <code>cyber</code> will compile and run a program in a VM:</p>
<pre><code class="language-bash">cyber main.cy
cyber path/to/main.cy
</code></pre>
<a href="#cli">^topic</a>
<h2 id="help">Help. <a href="#help">#</a></h2>
<p>To see more options and commands, print the help screen:</p>
<pre><code class="language-bash">cyber help

# These are aliases to the help command.
cyber -h
cyber --help
</code></pre>
<a href="#cli">^topic</a>
<h2 id="repl">REPL. <a href="#repl">#</a></h2>
<p>The default behavior of <code>cyber</code> is to start a REPL:</p>
<pre><code class="language-bash">cyber
> a := 123
> a * 2
`int` 246
</code></pre>
<p>Unlike conventional Cyber code, the REPL allows variable redeclarations:</p>
<pre><code class="language-bash">> a := 'a is now a string'
> a
`str` 'a is now a string'
</code></pre>
<p>When the first input ends with <code>:</code>, the REPL will automatically indent the next line. To recede the indentation, provide an empty input. Once the indent returns to the beginning, the entire code block is submitted for evaluation:</p>
<pre><code class="language-bash">> if true:
    | print('hello!')
    | 
hello!
</code></pre>
<p>Top level declarations such as imports, types, and functions can be referenced in subsequent evals:</p>
<pre><code class="language-bash">> use math
> math.random()
`float` 0.3650744641604983
</code></pre>
<pre><code class="language-bash">> type Foo:
    | a int
    |
> f = Foo{a=123}
> f.a
`int` 123
</code></pre>
<a href="#cli">^topic</a>
<h2 id="jit-compiler">JIT compiler. <a href="#jit-compiler">#</a></h2>
<p>Cyber's just-in-time compiler is incomplete and unstable. To run your script with JIT enabled:</p>
<pre><code class="language-bash">cyber -jit &lt;script&gt;
</code></pre>
<p>The goal of the JIT compiler is to be fast at compilation while still being significantly faster than the interpreter. The codegen involves stitching together pregenerated machine code that targets the same runtime stack slots used by the VM. This technique is also known as <code>copy-and-patch</code>.</p>
<a href="#cli">^topic</a>
<h2 id="c-backend">C backend. <a href="#c-backend">#</a></h2>
<p>The C backend generates a static binary from Cyber source code by transpiling to C code and relying on a local C compiler.
The user can specify the system's <code>cc</code> compiler or the builtin <code>tinyc</code> compiler that is bundled with the CLI.
<em>This is currently in progress.</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</main>
<script>/*!
  Highlight.js v11.9.0 (git: b7ec4bfafc)
  (c) 2006-2023 undefined and other contributors
  License: BSD-3-Clause
 */
var hljs=function(){"use strict";function e(t){
return t instanceof Map?t.clear=t.delete=t.set=()=>{
throw Error("map is read-only")}:t instanceof Set&&(t.add=t.clear=t.delete=()=>{
throw Error("set is read-only")
}),Object.freeze(t),Object.getOwnPropertyNames(t).forEach((n=>{
const i=t[n],s=typeof i;"object"!==s&&"function"!==s||Object.isFrozen(i)||e(i)
})),t}class t{constructor(e){
void 0===e.data&&(e.data={}),this.data=e.data,this.isMatchIgnored=!1}
ignoreMatch(){this.isMatchIgnored=!0}}function n(e){
return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")
}function i(e,...t){const n=Object.create(null);for(const t in e)n[t]=e[t]
;return t.forEach((e=>{for(const t in e)n[t]=e[t]})),n}const s=e=>!!e.scope
;class o{constructor(e,t){
this.buffer="",this.classPrefix=t.classPrefix,e.walk(this)}addText(e){
this.buffer+=n(e)}openNode(e){if(!s(e))return;const t=((e,{prefix:t})=>{
if(e.startsWith("language:"))return e.replace("language:","language-")
;if(e.includes(".")){const n=e.split(".")
;return[`${t}${n.shift()}`,...n.map(((e,t)=>`${e}${"_".repeat(t+1)}`))].join(" ")
}return`${t}${e}`})(e.scope,{prefix:this.classPrefix});this.span(t)}
closeNode(e){s(e)&&(this.buffer+="</span>")}value(){return this.buffer}span(e){
this.buffer+=`<span class="${e}">`}}const r=(e={})=>{const t={children:[]}
;return Object.assign(t,e),t};class a{constructor(){
this.rootNode=r(),this.stack=[this.rootNode]}get top(){
return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(e){
this.top.children.push(e)}openNode(e){const t=r({scope:e})
;this.add(t),this.stack.push(t)}closeNode(){
if(this.stack.length>1)return this.stack.pop()}closeAllNodes(){
for(;this.closeNode(););}toJSON(){return JSON.stringify(this.rootNode,null,4)}
walk(e){return this.constructor._walk(e,this.rootNode)}static _walk(e,t){
return"string"==typeof t?e.addText(t):t.children&&(e.openNode(t),
t.children.forEach((t=>this._walk(e,t))),e.closeNode(t)),e}static _collapse(e){
"string"!=typeof e&&e.children&&(e.children.every((e=>"string"==typeof e))?e.children=[e.children.join("")]:e.children.forEach((e=>{
a._collapse(e)})))}}class c extends a{constructor(e){super(),this.options=e}
addText(e){""!==e&&this.add(e)}startScope(e){this.openNode(e)}endScope(){
this.closeNode()}__addSublanguage(e,t){const n=e.root
;t&&(n.scope="language:"+t),this.add(n)}toHTML(){
return new o(this,this.options).value()}finalize(){
return this.closeAllNodes(),!0}}function l(e){
return e?"string"==typeof e?e:e.source:null}function g(e){return h("(?=",e,")")}
function u(e){return h("(?:",e,")*")}function d(e){return h("(?:",e,")?")}
function h(...e){return e.map((e=>l(e))).join("")}function f(...e){const t=(e=>{
const t=e[e.length-1]
;return"object"==typeof t&&t.constructor===Object?(e.splice(e.length-1,1),t):{}
})(e);return"("+(t.capture?"":"?:")+e.map((e=>l(e))).join("|")+")"}
function p(e){return RegExp(e.toString()+"|").exec("").length-1}
const b=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./
;function m(e,{joinWith:t}){let n=0;return e.map((e=>{n+=1;const t=n
;let i=l(e),s="";for(;i.length>0;){const e=b.exec(i);if(!e){s+=i;break}
s+=i.substring(0,e.index),
i=i.substring(e.index+e[0].length),"\\"===e[0][0]&&e[1]?s+="\\"+(Number(e[1])+t):(s+=e[0],
"("===e[0]&&n++)}return s})).map((e=>`(${e})`)).join(t)}
const E="[a-zA-Z]\\w*",x="[a-zA-Z_]\\w*",w="\\b\\d+(\\.\\d+)?",y="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",_="\\b(0b[01]+)",O={
begin:"\\\\[\\s\\S]",relevance:0},v={scope:"string",begin:"'",end:"'",
illegal:"\\n",contains:[O]},k={scope:"string",begin:'"',end:'"',illegal:"\\n",
contains:[O]},N=(e,t,n={})=>{const s=i({scope:"comment",begin:e,end:t,
contains:[]},n);s.contains.push({scope:"doctag",
begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0})
;const o=f("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/)
;return s.contains.push({begin:h(/[ ]+/,"(",o,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),s
},S=N("//","$"),M=N("/\\*","\\*/"),R=N("#","$");var j=Object.freeze({
__proto__:null,APOS_STRING_MODE:v,BACKSLASH_ESCAPE:O,BINARY_NUMBER_MODE:{
scope:"number",begin:_,relevance:0},BINARY_NUMBER_RE:_,COMMENT:N,
C_BLOCK_COMMENT_MODE:M,C_LINE_COMMENT_MODE:S,C_NUMBER_MODE:{scope:"number",
begin:y,relevance:0},C_NUMBER_RE:y,END_SAME_AS_BEGIN:e=>Object.assign(e,{
"on:begin":(e,t)=>{t.data._beginMatch=e[1]},"on:end":(e,t)=>{
t.data._beginMatch!==e[1]&&t.ignoreMatch()}}),HASH_COMMENT_MODE:R,IDENT_RE:E,
MATCH_NOTHING_RE:/\b\B/,METHOD_GUARD:{begin:"\\.\\s*"+x,relevance:0},
NUMBER_MODE:{scope:"number",begin:w,relevance:0},NUMBER_RE:w,
PHRASAL_WORDS_MODE:{
begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
},QUOTE_STRING_MODE:k,REGEXP_MODE:{scope:"regexp",begin:/\/(?=[^/\n]*\/)/,
end:/\/[gimuy]*/,contains:[O,{begin:/\[/,end:/\]/,relevance:0,contains:[O]}]},
RE_STARTERS_RE:"!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
SHEBANG:(e={})=>{const t=/^#![ ]*\//
;return e.binary&&(e.begin=h(t,/.*\b/,e.binary,/\b.*/)),i({scope:"meta",begin:t,
end:/$/,relevance:0,"on:begin":(e,t)=>{0!==e.index&&t.ignoreMatch()}},e)},
TITLE_MODE:{scope:"title",begin:E,relevance:0},UNDERSCORE_IDENT_RE:x,
UNDERSCORE_TITLE_MODE:{scope:"title",begin:x,relevance:0}});function A(e,t){
"."===e.input[e.index-1]&&t.ignoreMatch()}function I(e,t){
void 0!==e.className&&(e.scope=e.className,delete e.className)}function T(e,t){
t&&e.beginKeywords&&(e.begin="\\b("+e.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",
e.__beforeBegin=A,e.keywords=e.keywords||e.beginKeywords,delete e.beginKeywords,
void 0===e.relevance&&(e.relevance=0))}function L(e,t){
Array.isArray(e.illegal)&&(e.illegal=f(...e.illegal))}function B(e,t){
if(e.match){
if(e.begin||e.end)throw Error("begin & end are not supported with match")
;e.begin=e.match,delete e.match}}function P(e,t){
void 0===e.relevance&&(e.relevance=1)}const D=(e,t)=>{if(!e.beforeMatch)return
;if(e.starts)throw Error("beforeMatch cannot be used with starts")
;const n=Object.assign({},e);Object.keys(e).forEach((t=>{delete e[t]
})),e.keywords=n.keywords,e.begin=h(n.beforeMatch,g(n.begin)),e.starts={
relevance:0,contains:[Object.assign(n,{endsParent:!0})]
},e.relevance=0,delete n.beforeMatch
},H=["of","and","for","in","not","or","if","then","parent","list","value"],C="keyword"
;function $(e,t,n=C){const i=Object.create(null)
;return"string"==typeof e?s(n,e.split(" ")):Array.isArray(e)?s(n,e):Object.keys(e).forEach((n=>{
Object.assign(i,$(e[n],t,n))})),i;function s(e,n){
t&&(n=n.map((e=>e.toLowerCase()))),n.forEach((t=>{const n=t.split("|")
;i[n[0]]=[e,U(n[0],n[1])]}))}}function U(e,t){
return t?Number(t):(e=>H.includes(e.toLowerCase()))(e)?0:1}const z={},W=e=>{
console.error(e)},X=(e,...t)=>{console.log("WARN: "+e,...t)},G=(e,t)=>{
z[`${e}/${t}`]||(console.log(`Deprecated as of ${e}. ${t}`),z[`${e}/${t}`]=!0)
},K=Error();function F(e,t,{key:n}){let i=0;const s=e[n],o={},r={}
;for(let e=1;e<=t.length;e++)r[e+i]=s[e],o[e+i]=!0,i+=p(t[e-1])
;e[n]=r,e[n]._emit=o,e[n]._multi=!0}function Z(e){(e=>{
e.scope&&"object"==typeof e.scope&&null!==e.scope&&(e.beginScope=e.scope,
delete e.scope)})(e),"string"==typeof e.beginScope&&(e.beginScope={
_wrap:e.beginScope}),"string"==typeof e.endScope&&(e.endScope={_wrap:e.endScope
}),(e=>{if(Array.isArray(e.begin)){
if(e.skip||e.excludeBegin||e.returnBegin)throw W("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),
K
;if("object"!=typeof e.beginScope||null===e.beginScope)throw W("beginScope must be object"),
K;F(e,e.begin,{key:"beginScope"}),e.begin=m(e.begin,{joinWith:""})}})(e),(e=>{
if(Array.isArray(e.end)){
if(e.skip||e.excludeEnd||e.returnEnd)throw W("skip, excludeEnd, returnEnd not compatible with endScope: {}"),
K
;if("object"!=typeof e.endScope||null===e.endScope)throw W("endScope must be object"),
K;F(e,e.end,{key:"endScope"}),e.end=m(e.end,{joinWith:""})}})(e)}function V(e){
function t(t,n){
return RegExp(l(t),"m"+(e.case_insensitive?"i":"")+(e.unicodeRegex?"u":"")+(n?"g":""))
}class n{constructor(){
this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}
addRule(e,t){
t.position=this.position++,this.matchIndexes[this.matchAt]=t,this.regexes.push([t,e]),
this.matchAt+=p(e)+1}compile(){0===this.regexes.length&&(this.exec=()=>null)
;const e=this.regexes.map((e=>e[1]));this.matcherRe=t(m(e,{joinWith:"|"
}),!0),this.lastIndex=0}exec(e){this.matcherRe.lastIndex=this.lastIndex
;const t=this.matcherRe.exec(e);if(!t)return null
;const n=t.findIndex(((e,t)=>t>0&&void 0!==e)),i=this.matchIndexes[n]
;return t.splice(0,n),Object.assign(t,i)}}class s{constructor(){
this.rules=[],this.multiRegexes=[],
this.count=0,this.lastIndex=0,this.regexIndex=0}getMatcher(e){
if(this.multiRegexes[e])return this.multiRegexes[e];const t=new n
;return this.rules.slice(e).forEach((([e,n])=>t.addRule(e,n))),
t.compile(),this.multiRegexes[e]=t,t}resumingScanAtSamePosition(){
return 0!==this.regexIndex}considerAll(){this.regexIndex=0}addRule(e,t){
this.rules.push([e,t]),"begin"===t.type&&this.count++}exec(e){
const t=this.getMatcher(this.regexIndex);t.lastIndex=this.lastIndex
;let n=t.exec(e)
;if(this.resumingScanAtSamePosition())if(n&&n.index===this.lastIndex);else{
const t=this.getMatcher(0);t.lastIndex=this.lastIndex+1,n=t.exec(e)}
return n&&(this.regexIndex+=n.position+1,
this.regexIndex===this.count&&this.considerAll()),n}}
if(e.compilerExtensions||(e.compilerExtensions=[]),
e.contains&&e.contains.includes("self"))throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.")
;return e.classNameAliases=i(e.classNameAliases||{}),function n(o,r){const a=o
;if(o.isCompiled)return a
;[I,B,Z,D].forEach((e=>e(o,r))),e.compilerExtensions.forEach((e=>e(o,r))),
o.__beforeBegin=null,[T,L,P].forEach((e=>e(o,r))),o.isCompiled=!0;let c=null
;return"object"==typeof o.keywords&&o.keywords.$pattern&&(o.keywords=Object.assign({},o.keywords),
c=o.keywords.$pattern,
delete o.keywords.$pattern),c=c||/\w+/,o.keywords&&(o.keywords=$(o.keywords,e.case_insensitive)),
a.keywordPatternRe=t(c,!0),
r&&(o.begin||(o.begin=/\B|\b/),a.beginRe=t(a.begin),o.end||o.endsWithParent||(o.end=/\B|\b/),
o.end&&(a.endRe=t(a.end)),
a.terminatorEnd=l(a.end)||"",o.endsWithParent&&r.terminatorEnd&&(a.terminatorEnd+=(o.end?"|":"")+r.terminatorEnd)),
o.illegal&&(a.illegalRe=t(o.illegal)),
o.contains||(o.contains=[]),o.contains=[].concat(...o.contains.map((e=>(e=>(e.variants&&!e.cachedVariants&&(e.cachedVariants=e.variants.map((t=>i(e,{
variants:null},t)))),e.cachedVariants?e.cachedVariants:q(e)?i(e,{
starts:e.starts?i(e.starts):null
}):Object.isFrozen(e)?i(e):e))("self"===e?o:e)))),o.contains.forEach((e=>{n(e,a)
})),o.starts&&n(o.starts,r),a.matcher=(e=>{const t=new s
;return e.contains.forEach((e=>t.addRule(e.begin,{rule:e,type:"begin"
}))),e.terminatorEnd&&t.addRule(e.terminatorEnd,{type:"end"
}),e.illegal&&t.addRule(e.illegal,{type:"illegal"}),t})(a),a}(e)}function q(e){
return!!e&&(e.endsWithParent||q(e.starts))}class J extends Error{
constructor(e,t){super(e),this.name="HTMLInjectionError",this.html=t}}
const Y=n,Q=i,ee=Symbol("nomatch"),te=n=>{
const i=Object.create(null),s=Object.create(null),o=[];let r=!0
;const a="Could not find the language '{}', did you forget to load/include a language module?",l={
disableAutodetect:!0,name:"Plain text",contains:[]};let p={
ignoreUnescapedHTML:!1,throwUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,
languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",
cssSelector:"pre code",languages:null,__emitter:c};function b(e){
return p.noHighlightRe.test(e)}function m(e,t,n){let i="",s=""
;"object"==typeof t?(i=e,
n=t.ignoreIllegals,s=t.language):(G("10.7.0","highlight(lang, code, ...args) has been deprecated."),
G("10.7.0","Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"),
s=e,i=t),void 0===n&&(n=!0);const o={code:i,language:s};N("before:highlight",o)
;const r=o.result?o.result:E(o.language,o.code,n)
;return r.code=o.code,N("after:highlight",r),r}function E(e,n,s,o){
const c=Object.create(null);function l(){if(!N.keywords)return void M.addText(R)
;let e=0;N.keywordPatternRe.lastIndex=0;let t=N.keywordPatternRe.exec(R),n=""
;for(;t;){n+=R.substring(e,t.index)
;const s=_.case_insensitive?t[0].toLowerCase():t[0],o=(i=s,N.keywords[i]);if(o){
const[e,i]=o
;if(M.addText(n),n="",c[s]=(c[s]||0)+1,c[s]<=7&&(j+=i),e.startsWith("_"))n+=t[0];else{
const n=_.classNameAliases[e]||e;u(t[0],n)}}else n+=t[0]
;e=N.keywordPatternRe.lastIndex,t=N.keywordPatternRe.exec(R)}var i
;n+=R.substring(e),M.addText(n)}function g(){null!=N.subLanguage?(()=>{
if(""===R)return;let e=null;if("string"==typeof N.subLanguage){
if(!i[N.subLanguage])return void M.addText(R)
;e=E(N.subLanguage,R,!0,S[N.subLanguage]),S[N.subLanguage]=e._top
}else e=x(R,N.subLanguage.length?N.subLanguage:null)
;N.relevance>0&&(j+=e.relevance),M.__addSublanguage(e._emitter,e.language)
})():l(),R=""}function u(e,t){
""!==e&&(M.startScope(t),M.addText(e),M.endScope())}function d(e,t){let n=1
;const i=t.length-1;for(;n<=i;){if(!e._emit[n]){n++;continue}
const i=_.classNameAliases[e[n]]||e[n],s=t[n];i?u(s,i):(R=s,l(),R=""),n++}}
function h(e,t){
return e.scope&&"string"==typeof e.scope&&M.openNode(_.classNameAliases[e.scope]||e.scope),
e.beginScope&&(e.beginScope._wrap?(u(R,_.classNameAliases[e.beginScope._wrap]||e.beginScope._wrap),
R=""):e.beginScope._multi&&(d(e.beginScope,t),R="")),N=Object.create(e,{parent:{
value:N}}),N}function f(e,n,i){let s=((e,t)=>{const n=e&&e.exec(t)
;return n&&0===n.index})(e.endRe,i);if(s){if(e["on:end"]){const i=new t(e)
;e["on:end"](n,i),i.isMatchIgnored&&(s=!1)}if(s){
for(;e.endsParent&&e.parent;)e=e.parent;return e}}
if(e.endsWithParent)return f(e.parent,n,i)}function b(e){
return 0===N.matcher.regexIndex?(R+=e[0],1):(T=!0,0)}function m(e){
const t=e[0],i=n.substring(e.index),s=f(N,e,i);if(!s)return ee;const o=N
;N.endScope&&N.endScope._wrap?(g(),
u(t,N.endScope._wrap)):N.endScope&&N.endScope._multi?(g(),
d(N.endScope,e)):o.skip?R+=t:(o.returnEnd||o.excludeEnd||(R+=t),
g(),o.excludeEnd&&(R=t));do{
N.scope&&M.closeNode(),N.skip||N.subLanguage||(j+=N.relevance),N=N.parent
}while(N!==s.parent);return s.starts&&h(s.starts,e),o.returnEnd?0:t.length}
let w={};function y(i,o){const a=o&&o[0];if(R+=i,null==a)return g(),0
;if("begin"===w.type&&"end"===o.type&&w.index===o.index&&""===a){
if(R+=n.slice(o.index,o.index+1),!r){const t=Error(`0 width match regex (${e})`)
;throw t.languageName=e,t.badRule=w.rule,t}return 1}
if(w=o,"begin"===o.type)return(e=>{
const n=e[0],i=e.rule,s=new t(i),o=[i.__beforeBegin,i["on:begin"]]
;for(const t of o)if(t&&(t(e,s),s.isMatchIgnored))return b(n)
;return i.skip?R+=n:(i.excludeBegin&&(R+=n),
g(),i.returnBegin||i.excludeBegin||(R=n)),h(i,e),i.returnBegin?0:n.length})(o)
;if("illegal"===o.type&&!s){
const e=Error('Illegal lexeme "'+a+'" for mode "'+(N.scope||"<unnamed>")+'"')
;throw e.mode=N,e}if("end"===o.type){const e=m(o);if(e!==ee)return e}
if("illegal"===o.type&&""===a)return 1
;if(I>1e5&&I>3*o.index)throw Error("potential infinite loop, way more iterations than matches")
;return R+=a,a.length}const _=O(e)
;if(!_)throw W(a.replace("{}",e)),Error('Unknown language: "'+e+'"')
;const v=V(_);let k="",N=o||v;const S={},M=new p.__emitter(p);(()=>{const e=[]
;for(let t=N;t!==_;t=t.parent)t.scope&&e.unshift(t.scope)
;e.forEach((e=>M.openNode(e)))})();let R="",j=0,A=0,I=0,T=!1;try{
if(_.__emitTokens)_.__emitTokens(n,M);else{for(N.matcher.considerAll();;){
I++,T?T=!1:N.matcher.considerAll(),N.matcher.lastIndex=A
;const e=N.matcher.exec(n);if(!e)break;const t=y(n.substring(A,e.index),e)
;A=e.index+t}y(n.substring(A))}return M.finalize(),k=M.toHTML(),{language:e,
value:k,relevance:j,illegal:!1,_emitter:M,_top:N}}catch(t){
if(t.message&&t.message.includes("Illegal"))return{language:e,value:Y(n),
illegal:!0,relevance:0,_illegalBy:{message:t.message,index:A,
context:n.slice(A-100,A+100),mode:t.mode,resultSoFar:k},_emitter:M};if(r)return{
language:e,value:Y(n),illegal:!1,relevance:0,errorRaised:t,_emitter:M,_top:N}
;throw t}}function x(e,t){t=t||p.languages||Object.keys(i);const n=(e=>{
const t={value:Y(e),illegal:!1,relevance:0,_top:l,_emitter:new p.__emitter(p)}
;return t._emitter.addText(e),t})(e),s=t.filter(O).filter(k).map((t=>E(t,e,!1)))
;s.unshift(n);const o=s.sort(((e,t)=>{
if(e.relevance!==t.relevance)return t.relevance-e.relevance
;if(e.language&&t.language){if(O(e.language).supersetOf===t.language)return 1
;if(O(t.language).supersetOf===e.language)return-1}return 0})),[r,a]=o,c=r
;return c.secondBest=a,c}function w(e){let t=null;const n=(e=>{
let t=e.className+" ";t+=e.parentNode?e.parentNode.className:""
;const n=p.languageDetectRe.exec(t);if(n){const t=O(n[1])
;return t||(X(a.replace("{}",n[1])),
X("Falling back to no-highlight mode for this block.",e)),t?n[1]:"no-highlight"}
return t.split(/\s+/).find((e=>b(e)||O(e)))})(e);if(b(n))return
;if(N("before:highlightElement",{el:e,language:n
}),e.dataset.highlighted)return void console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",e)
;if(e.children.length>0&&(p.ignoreUnescapedHTML||(console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),
console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),
console.warn("The element with unescaped HTML:"),
console.warn(e)),p.throwUnescapedHTML))throw new J("One of your code blocks includes unescaped HTML.",e.innerHTML)
;t=e;const i=t.textContent,o=n?m(i,{language:n,ignoreIllegals:!0}):x(i)
;e.innerHTML=o.value,e.dataset.highlighted="yes",((e,t,n)=>{const i=t&&s[t]||n
;e.classList.add("hljs"),e.classList.add("language-"+i)
})(e,n,o.language),e.result={language:o.language,re:o.relevance,
relevance:o.relevance},o.secondBest&&(e.secondBest={
language:o.secondBest.language,relevance:o.secondBest.relevance
}),N("after:highlightElement",{el:e,result:o,text:i})}let y=!1;function _(){
"loading"!==document.readyState?document.querySelectorAll(p.cssSelector).forEach(w):y=!0
}function O(e){return e=(e||"").toLowerCase(),i[e]||i[s[e]]}
function v(e,{languageName:t}){"string"==typeof e&&(e=[e]),e.forEach((e=>{
s[e.toLowerCase()]=t}))}function k(e){const t=O(e)
;return t&&!t.disableAutodetect}function N(e,t){const n=e;o.forEach((e=>{
e[n]&&e[n](t)}))}
"undefined"!=typeof window&&window.addEventListener&&window.addEventListener("DOMContentLoaded",(()=>{
y&&_()}),!1),Object.assign(n,{highlight:m,highlightAuto:x,highlightAll:_,
highlightElement:w,
highlightBlock:e=>(G("10.7.0","highlightBlock will be removed entirely in v12.0"),
G("10.7.0","Please use highlightElement now."),w(e)),configure:e=>{p=Q(p,e)},
initHighlighting:()=>{
_(),G("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.")},
initHighlightingOnLoad:()=>{
_(),G("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.")
},registerLanguage:(e,t)=>{let s=null;try{s=t(n)}catch(t){
if(W("Language definition for '{}' could not be registered.".replace("{}",e)),
!r)throw t;W(t),s=l}
s.name||(s.name=e),i[e]=s,s.rawDefinition=t.bind(null,n),s.aliases&&v(s.aliases,{
languageName:e})},unregisterLanguage:e=>{delete i[e]
;for(const t of Object.keys(s))s[t]===e&&delete s[t]},
listLanguages:()=>Object.keys(i),getLanguage:O,registerAliases:v,
autoDetection:k,inherit:Q,addPlugin:e=>{(e=>{
e["before:highlightBlock"]&&!e["before:highlightElement"]&&(e["before:highlightElement"]=t=>{
e["before:highlightBlock"](Object.assign({block:t.el},t))
}),e["after:highlightBlock"]&&!e["after:highlightElement"]&&(e["after:highlightElement"]=t=>{
e["after:highlightBlock"](Object.assign({block:t.el},t))})})(e),o.push(e)},
removePlugin:e=>{const t=o.indexOf(e);-1!==t&&o.splice(t,1)}}),n.debugMode=()=>{
r=!1},n.safeMode=()=>{r=!0},n.versionString="11.9.0",n.regex={concat:h,
lookahead:g,either:f,optional:d,anyNumberOfTimes:u}
;for(const t in j)"object"==typeof j[t]&&e(j[t]);return Object.assign(n,j),n
},ne=te({});return ne.newInstance=()=>te({}),ne}()
;"object"==typeof exports&&"undefined"!=typeof module&&(module.exports=hljs);/*! `bash` grammar compiled for Highlight.js 11.9.0 */
(()=>{var e=(()=>{"use strict";return e=>{const s=e.regex,t={},n={begin:/\$\{/,
end:/\}/,contains:["self",{begin:/:-/,contains:[t]}]};Object.assign(t,{
className:"variable",variants:[{
begin:s.concat(/\$[\w\d#@][\w\d_]*/,"(?![\\w\\d])(?![$])")},n]});const a={
className:"subst",begin:/\$\(/,end:/\)/,contains:[e.BACKSLASH_ESCAPE]
},i=e.inherit(e.COMMENT(),{match:[/(^|\s)/,/#.*$/],scope:{2:"comment"}}),c={
begin:/<<-?\s*(?=\w+)/,starts:{contains:[e.END_SAME_AS_BEGIN({begin:/(\w+)/,
end:/(\w+)/,className:"string"})]}},o={className:"string",begin:/"/,end:/"/,
contains:[e.BACKSLASH_ESCAPE,t,a]};a.contains.push(o);const r={begin:/\$?\(\(/,
end:/\)\)/,contains:[{begin:/\d+#[0-9a-f]+/,className:"number"},e.NUMBER_MODE,t]
},l=e.SHEBANG({binary:"(fish|bash|zsh|sh|csh|ksh|tcsh|dash|scsh)",relevance:10
}),m={className:"function",begin:/\w[\w\d_]*\s*\(\s*\)\s*\{/,returnBegin:!0,
contains:[e.inherit(e.TITLE_MODE,{begin:/\w[\w\d_]*/})],relevance:0};return{
name:"Bash",aliases:["sh"],keywords:{$pattern:/\b[a-z][a-z0-9._-]+\b/,
keyword:["if","then","else","elif","fi","for","while","until","in","do","done","case","esac","function","select"],
literal:["true","false"],
built_in:["break","cd","continue","eval","exec","exit","export","getopts","hash","pwd","readonly","return","shift","test","times","trap","umask","unset","alias","bind","builtin","caller","command","declare","echo","enable","help","let","local","logout","mapfile","printf","read","readarray","source","type","typeset","ulimit","unalias","set","shopt","autoload","bg","bindkey","bye","cap","chdir","clone","comparguments","compcall","compctl","compdescribe","compfiles","compgroups","compquote","comptags","comptry","compvalues","dirs","disable","disown","echotc","echoti","emulate","fc","fg","float","functions","getcap","getln","history","integer","jobs","kill","limit","log","noglob","popd","print","pushd","pushln","rehash","sched","setcap","setopt","stat","suspend","ttyctl","unfunction","unhash","unlimit","unsetopt","vared","wait","whence","where","which","zcompile","zformat","zftp","zle","zmodload","zparseopts","zprof","zpty","zregexparse","zsocket","zstyle","ztcp","chcon","chgrp","chown","chmod","cp","dd","df","dir","dircolors","ln","ls","mkdir","mkfifo","mknod","mktemp","mv","realpath","rm","rmdir","shred","sync","touch","truncate","vdir","b2sum","base32","base64","cat","cksum","comm","csplit","cut","expand","fmt","fold","head","join","md5sum","nl","numfmt","od","paste","ptx","pr","sha1sum","sha224sum","sha256sum","sha384sum","sha512sum","shuf","sort","split","sum","tac","tail","tr","tsort","unexpand","uniq","wc","arch","basename","chroot","date","dirname","du","echo","env","expr","factor","groups","hostid","id","link","logname","nice","nohup","nproc","pathchk","pinky","printenv","printf","pwd","readlink","runcon","seq","sleep","stat","stdbuf","stty","tee","test","timeout","tty","uname","unlink","uptime","users","who","whoami","yes"]
},contains:[l,e.SHEBANG(),m,r,i,c,{match:/(\/[a-z._-]+)+/},o,{match:/\\"/},{
className:"string",begin:/'/,end:/'/},{match:/\\'/},t]}}})()
;hljs.registerLanguage("bash",e)})();/*! `c` grammar compiled for Highlight.js 11.9.0 */
(()=>{var e=(()=>{"use strict";return e=>{const n=e.regex,t=e.COMMENT("//","$",{
contains:[{begin:/\\\n/}]
}),s="decltype\\(auto\\)",a="[a-zA-Z_]\\w*::",r="("+s+"|"+n.optional(a)+"[a-zA-Z_]\\w*"+n.optional("<[^<>]+>")+")",i={
className:"type",variants:[{begin:"\\b[a-z\\d_]*_t\\b"},{
match:/\batomic_[a-z]{3,6}\b/}]},l={className:"string",variants:[{
begin:'(u8?|U|L)?"',end:'"',illegal:"\\n",contains:[e.BACKSLASH_ESCAPE]},{
begin:"(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
end:"'",illegal:"."},e.END_SAME_AS_BEGIN({
begin:/(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,end:/\)([^()\\ ]{0,16})"/})]},o={
className:"number",variants:[{begin:"\\b(0b[01']+)"},{
begin:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
},{
begin:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
}],relevance:0},c={className:"meta",begin:/#\s*[a-z]+\b/,end:/$/,keywords:{
keyword:"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
},contains:[{begin:/\\\n/,relevance:0},e.inherit(l,{className:"string"}),{
className:"string",begin:/<.*?>/},t,e.C_BLOCK_COMMENT_MODE]},d={
className:"title",begin:n.optional(a)+e.IDENT_RE,relevance:0
},g=n.optional(a)+e.IDENT_RE+"\\s*\\(",u={
keyword:["asm","auto","break","case","continue","default","do","else","enum","extern","for","fortran","goto","if","inline","register","restrict","return","sizeof","struct","switch","typedef","union","volatile","while","_Alignas","_Alignof","_Atomic","_Generic","_Noreturn","_Static_assert","_Thread_local","alignas","alignof","noreturn","static_assert","thread_local","_Pragma"],
type:["float","double","signed","unsigned","int","short","long","char","void","_Bool","_Complex","_Imaginary","_Decimal32","_Decimal64","_Decimal128","const","static","complex","bool","imaginary"],
literal:"true false NULL",
built_in:"std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
},m=[c,i,t,e.C_BLOCK_COMMENT_MODE,o,l],_={variants:[{begin:/=/,end:/;/},{
begin:/\(/,end:/\)/},{beginKeywords:"new throw return else",end:/;/}],
keywords:u,contains:m.concat([{begin:/\(/,end:/\)/,keywords:u,
contains:m.concat(["self"]),relevance:0}]),relevance:0},p={
begin:"("+r+"[\\*&\\s]+)+"+g,returnBegin:!0,end:/[{;=]/,excludeEnd:!0,
keywords:u,illegal:/[^\w\s\*&:<>.]/,contains:[{begin:s,keywords:u,relevance:0},{
begin:g,returnBegin:!0,contains:[e.inherit(d,{className:"title.function"})],
relevance:0},{relevance:0,match:/,/},{className:"params",begin:/\(/,end:/\)/,
keywords:u,relevance:0,contains:[t,e.C_BLOCK_COMMENT_MODE,l,o,i,{begin:/\(/,
end:/\)/,keywords:u,relevance:0,contains:["self",t,e.C_BLOCK_COMMENT_MODE,l,o,i]
}]},i,t,e.C_BLOCK_COMMENT_MODE,c]};return{name:"C",aliases:["h"],keywords:u,
disableAutodetect:!0,illegal:"</",contains:[].concat(_,p,m,[c,{
begin:e.IDENT_RE+"::",keywords:u},{className:"class",
beginKeywords:"enum class struct union",end:/[{;:<>=]/,contains:[{
beginKeywords:"final class struct"},e.TITLE_MODE]}]),exports:{preprocessor:c,
strings:l,keywords:u}}}})();hljs.registerLanguage("c",e)})();</script>
<script>
hljs.registerLanguage('cy', function() {
    return {
    keywords: {
        keyword: [
            'fn', 'mod', 'for', 'coinit', 'coresume', 'coyield', 'use', 'await', 'global', 'const', 'scope', 'sink',
            'return', 'if', 'else', 'as', 'while', 'var', 'let', 'struct', 'cstruct', 'with',
            'break', 'continue', 'switch', 'pass', 'or', 'and', 'not', 'is', 'error', 'throws', 'move',
            'true', 'false', 'none', 'throw', 'try', 'catch', 'recover', 'enum', 'type', 'case', 'trait'
        ],
        type: [
            'r8', 'byte', 'r16', 'r32', 'r64', 'i8', 'i16', 'i32', 'i64', 'f32', 'f64', 'float', 'str', 'Array', 'bool', 'int', 'Map', 'symbol'
        ],
    },
    contains: [
        {
            scope: 'string',
            begin: "\"", end: "\""
        },
        {
            scope: 'string',
            begin: "'", end: "'"
        },
        {
            scope: 'string',
            begin: "```", end: "```"
        },
        {
            scope: 'string',
            begin: "`", end: "`"
        },
        {
            scope: 'keyword',
            begin: '\\|',
            end: '\\|',
            contains: [
              {
                scope: 'subst', 
                match: /[^|]+/,
              }
            ]
        },
        /*
        {
            scope: 'symbol',
            begin: '.', end: /\w(?=[^\w])/
        },*/
        hljs.COMMENT(
        '\-\-', // begin
        '\n', // end
        {
            contains: [
            ]
        }
        ),
        hljs.C_NUMBER_MODE,
    ]
    };
})
hljs.highlightAll();
</script>
</body>
</html>