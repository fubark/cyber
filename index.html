<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Docs</title>
    <style>/* Global variables. */
:root {
  /* Set sans-serif & mono fonts */
  --sans-font: -apple-system, BlinkMacSystemFont, "Avenir Next", Avenir,
    "Nimbus Sans L", Roboto, "Noto Sans", "Segoe UI", Arial, Helvetica,
    "Helvetica Neue", sans-serif;
  --mono-font: Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace;

  /* Default (light) theme */
  --bg: #fff;
  --accent-bg: #f5f7ff;
  --text: #212121;
  --text-light: #585858;
  --border: #898EA4;
  --accent: #0d47a1;
  --code: #d81b60;
  --preformatted: #444;
  --marked: #ffdd33;
  --disabled: #efefef;
}

/* Dark theme */
@media (prefers-color-scheme: dark) {
  :root {
    color-scheme: dark;
    --bg: #212121;
    --accent-bg: #2b2b2b;
    --text: #dcdcdc;
    --text-light: #ababab;
    --accent: #ffb300;
    --code: #f06292;
    --preformatted: #ccc;
    --disabled: #111;
  }
  /* Add a bit of transparency so light media isn't so glaring in dark mode */
  img,
  video {
    opacity: 0.8;
  }
}

/* Reset box-sizing */
*, *::before, *::after {
  box-sizing: border-box;
}

/* Reset default appearance */
textarea,
select,
input,
progress {
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}

html {
  /* Set the font globally */
  font-family: var(--sans-font);
  scroll-behavior: smooth;
}

/* Make the body a nice central block */
body {
  color: var(--text);
  background-color: var(--bg);
  font-size: 1.15rem;
  line-height: 1.5;
  display: grid;
  grid-template-columns: 1fr min(45rem, 90%) 1fr;
  margin: 0;
}
body > * {
  grid-column: 2;
}

/* Make the header bg full width, but the content inline with body */
body > header {
  background-color: var(--accent-bg);
  border-bottom: 1px solid var(--border);
  text-align: center;
  padding: 0 0.5rem 2rem 0.5rem;
  grid-column: 1 / -1;
}

body > header h1 {
  max-width: 1200px;
  margin: 1rem auto;
}

body > header p {
  max-width: 40rem;
  margin: 1rem auto;
}

/* Add a little padding to ensure spacing is correct between content and header > nav */
main {
  padding-top: 1.5rem;
}

body > footer {
  margin-top: 4rem;
  padding: 2rem 1rem 1.5rem 1rem;
  color: var(--text-light);
  font-size: 0.9rem;
  text-align: center;
  border-top: 1px solid var(--border);
}

/* Format headers */
h1 {
  font-size: 3rem;
}

h2 {
  font-size: 2.6rem;
  margin-top: 3rem;
}

h3 {
  font-size: 2rem;
  margin-top: 3rem;
}

h4 {
  font-size: 1.44rem;
}

h5 {
  font-size: 1.15rem;
}

h6 {
  font-size: 0.96rem;
}

/* Prevent long strings from overflowing container */
p, h1, h2, h3, h4, h5, h6 {
  overflow-wrap: break-word;
}

/* Fix line height when title wraps */
h1,
h2,
h3 {
  line-height: 1.1;
}

/* Reduce header size on mobile */
@media only screen and (max-width: 720px) {
  h1 {
    font-size: 2.5rem;
  }

  h2 {
    font-size: 2.1rem;
  }

  h3 {
    font-size: 1.75rem;
  }

  h4 {
    font-size: 1.25rem;
  }
}

/* Format links & buttons */
a,
a:visited {
  color: var(--accent);
}

a:hover {
  text-decoration: none;
}

button,
[role="button"],
input[type="submit"],
input[type="reset"],
input[type="button"],
label[type="button"] {
  border: none;
  border-radius: 5px;
  background-color: var(--accent);
  font-size: 1rem;
  color: var(--bg);
  padding: 0.7rem 0.9rem;
  margin: 0.5rem 0;
}

button[disabled],
[role="button"][aria-disabled="true"],
input[type="submit"][disabled],
input[type="reset"][disabled],
input[type="button"][disabled],
input[type="checkbox"][disabled],
input[type="radio"][disabled],
select[disabled] {
  opacity: 0.5;
  cursor: not-allowed;
}

input:disabled,
textarea:disabled,
select:disabled {
  cursor: not-allowed;
  background-color: var(--disabled);
}

input[type="range"] {
  padding: 0;
}

/* Set the cursor to '?' on an abbreviation and style the abbreviation to show that there is more information underneath */
abbr[title] {
  cursor: help;
  text-decoration-line: underline;
  text-decoration-style: dotted;
}

button:focus,
button:enabled:hover,
[role="button"]:focus,
[role="button"]:not([aria-disabled="true"]):hover,
input[type="submit"]:focus,
input[type="submit"]:enabled:hover,
input[type="reset"]:focus,
input[type="reset"]:enabled:hover,
input[type="button"]:focus,
input[type="button"]:enabled:hover,
label[type="button"]:focus,
label[type="button"]:hover {
  filter: brightness(1.4);
  cursor: pointer;
}

/* Format navigation */
header > nav {
  font-size: 1rem;
  line-height: 2;
  padding: 1rem 0 0 0;
}

/* Use flexbox to allow items to wrap, as needed */
header > nav ul,
header > nav ol {
  align-content: space-around;
  align-items: center;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  list-style-type: none;
  margin: 0;
  padding: 0;
}

/* List items are inline elements, make them behave more like blocks */
header > nav ul li,
header > nav ol li {
  display: inline-block;
}

header > nav a,
header > nav a:visited {
  margin: 0 0.5rem 1rem 0.5rem;
  border: 1px solid var(--border);
  border-radius: 5px;
  color: var(--text);
  display: inline-block;
  padding: 0.1rem 1rem;
  text-decoration: none;
}

header > nav a:hover {
  border-color: var(--accent);
  color: var(--accent);
  cursor: pointer;
}

/* Reduce nav side on mobile */
@media only screen and (max-width: 720px) {
  header > nav a {
    border: none;
    padding: 0;
    text-decoration: underline;
    line-height: 1;
  }
}

/* Consolidate box styling */
aside, details, pre, progress {
  background-color: var(--accent-bg);
  border: 1px solid var(--border);
  border-radius: 5px;
  margin-bottom: 1rem;
}

aside {
  font-size: 1rem;
  width: 30%;
  padding: 0 15px;
  margin-left: 15px;
  float: right;
}

/* Make aside full-width on mobile */
@media only screen and (max-width: 720px) {
  aside {
    width: 100%;
    float: none;
    margin-left: 0;
  }
}

article, fieldset {
  border: 1px solid var(--border);
  padding: 1rem;
  border-radius: 5px;
  margin-bottom: 1rem;
}

article h2:first-child,
section h2:first-child {
  margin-top: 1rem;
}

section {
  border-top: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 2rem 1rem;
  margin: 3rem 0;
}

/* Don't double separators when chaining sections */
section + section,
section:first-child {
  border-top: 0;
  padding-top: 0;
}

section:last-child {
  border-bottom: 0;
  padding-bottom: 0;
}

details {
  padding: 0.7rem 1rem;
}

summary {
  cursor: pointer;
  font-weight: bold;
  padding: 0.7rem 1rem;
  margin: -0.7rem -1rem;
  word-break: break-all;
}

details[open] > summary + * {
  margin-top: 0;
}

details[open] > summary {
  margin-bottom: 0.5rem;
}

details[open] > :last-child {
  margin-bottom: 0;
}

/* Format tables */
table {
  border-collapse: collapse;
  display: block;
  margin: 1.5rem 0;
  overflow: auto;
  width: 100%;
}

td,
th {
  border: 1px solid var(--border);
  text-align: left;
  padding: 0.5rem;
}

th {
  background-color: var(--accent-bg);
  font-weight: bold;
}

tr:nth-child(even) {
  /* Set every other cell slightly darker. Improves readability. */
  background-color: var(--accent-bg);
}

table caption {
  font-weight: bold;
  margin-bottom: 0.5rem;
}

/* Format forms */
textarea,
select,
input {
  font-size: inherit;
  font-family: inherit;
  padding: 0.5rem;
  margin-bottom: 0.5rem;
  color: var(--text);
  background-color: var(--bg);
  border: 1px solid var(--border);
  border-radius: 5px;
  box-shadow: none;
  max-width: 100%;
  display: inline-block;
}
label {
  display: block;
}
textarea:not([cols]) {
  width: 100%;
}

/* Add arrow to drop-down */
select:not([multiple]) {
  background-image: linear-gradient(45deg, transparent 49%, var(--text) 51%),
    linear-gradient(135deg, var(--text) 51%, transparent 49%);
  background-position: calc(100% - 15px), calc(100% - 10px);
  background-size: 5px 5px, 5px 5px;
  background-repeat: no-repeat;
  padding-right: 25px;
}

/* checkbox and radio button style */
input[type="checkbox"],
input[type="radio"] {
  vertical-align: middle;
  position: relative;
  width: min-content;
}

input[type="checkbox"] + label,
input[type="radio"] + label {
  display: inline-block;
}

input[type="radio"] {
  border-radius: 100%;
}

input[type="checkbox"]:checked,
input[type="radio"]:checked {
  background-color: var(--accent);
}

input[type="checkbox"]:checked::after {
  /* Creates a rectangle with colored right and bottom borders which is rotated to look like a check mark */
  content: " ";
  width: 0.18em;
  height: 0.32em;
  border-radius: 0;
  position: absolute;
  top: 0.05em;
  left: 0.17em;
  background-color: transparent;
  border-right: solid var(--bg) 0.08em;
  border-bottom: solid var(--bg) 0.08em;
  font-size: 1.8em;
  transform: rotate(45deg);
}
input[type="radio"]:checked::after {
  /* creates a colored circle for the checked radio button  */
  content: " ";
  width: 0.25em;
  height: 0.25em;
  border-radius: 100%;
  position: absolute;
  top: 0.125em;
  background-color: var(--bg);
  left: 0.125em;
  font-size: 32px;
}

/* Makes input fields wider on smaller screens */
@media only screen and (max-width: 720px) {
  textarea,
  select,
  input {
    width: 100%;
  }
}

/* Set a height for color input */
input[type="color"] {
  height: 2.5rem;
  padding:  0.2rem;
}

/* do not show border around file selector button */
input[type="file"] {
  border: 0;
}

/* Misc body elements */
hr {
  border: none;
  height: 1px;
  background: var(--border);
  margin: 1rem auto;
}

mark {
  padding: 2px 5px;
  border-radius: 4px;
  background-color: var(--marked);
}

img,
video {
  max-width: 100%;
  height: auto;
  border-radius: 5px;
}

figure {
  margin: 0;
  text-align: center;
}

figcaption {
  font-size: 0.9rem;
  color: var(--text-light);
  margin-bottom: 1rem;
}

blockquote {
  margin: 2rem 0 2rem 2rem;
  padding: 0.4rem 0.8rem;
  border-left: 0.35rem solid var(--accent);
  color: var(--text-light);
  font-style: italic;
}

cite {
  font-size: 0.9rem;
  color: var(--text-light);
  font-style: normal;
}

dt {
    color: var(--text-light);
}

/* Use mono font for code elements */
code,
pre,
pre span,
kbd,
samp {
  font-family: var(--mono-font);
  color: var(--code);
}

kbd {
  color: var(--preformatted);
  border: 1px solid var(--preformatted);
  border-bottom: 3px solid var(--preformatted);
  border-radius: 5px;
  padding: 0.1rem 0.4rem;
}

pre {
  padding: 1rem 1.4rem;
  max-width: 100%;
  overflow: auto;
  color: var(--preformatted);
}

/* Fix embedded code within pre */
pre code {
  color: var(--preformatted);
  background: none;
  margin: 0;
  padding: 0;
}

/* Progress bars */
/* Declarations are repeated because you */
/* cannot combine vendor-specific selectors */
progress {
  width: 100%;
}

progress:indeterminate {
  background-color: var(--accent-bg);
}

progress::-webkit-progress-bar {
  border-radius: 5px;
  background-color: var(--accent-bg);
}

progress::-webkit-progress-value {
  border-radius: 5px;
  background-color: var(--accent);
}

progress::-moz-progress-bar {
  border-radius: 5px;
  background-color: var(--accent);
  transition-property: width;
  transition-duration: 0.3s;
}

progress:indeterminate::-moz-progress-bar {
  background-color: var(--accent-bg);
}
</style>
    <style>pre code.hljs{display:block;overflow-x:auto;padding:1em}code.hljs{padding:3px 5px}/*!
  Theme: GitHub Dark
  Description: Dark theme as seen on github.com
  Author: github.com
  Maintainer: @Hirse
  Updated: 2021-05-15

  Outdated base version: https://github.com/primer/github-syntax-dark
  Current colors taken from GitHub's CSS
*/.hljs{color:#c9d1d9;background:#0d1117}.hljs-doctag,.hljs-keyword,.hljs-meta .hljs-keyword,.hljs-template-tag,.hljs-template-variable,.hljs-type,.hljs-variable.language_{color:#ff7b72}.hljs-title,.hljs-title.class_,.hljs-title.class_.inherited__,.hljs-title.function_{color:#d2a8ff}.hljs-attr,.hljs-attribute,.hljs-literal,.hljs-meta,.hljs-number,.hljs-operator,.hljs-selector-attr,.hljs-selector-class,.hljs-selector-id,.hljs-variable{color:#79c0ff}.hljs-meta .hljs-string,.hljs-regexp,.hljs-string{color:#a5d6ff}.hljs-built_in,.hljs-symbol{color:#ffa657}.hljs-code,.hljs-comment,.hljs-formula{color:#8b949e}.hljs-name,.hljs-quote,.hljs-selector-pseudo,.hljs-selector-tag{color:#7ee787}.hljs-subst{color:#c9d1d9}.hljs-section{color:#1f6feb;font-weight:700}.hljs-bullet{color:#f2cc60}.hljs-emphasis{color:#c9d1d9;font-style:italic}.hljs-strong{color:#c9d1d9;font-weight:700}.hljs-addition{color:#aff5b4;background-color:#033a16}.hljs-deletion{color:#ffdcd7;background-color:#67060c}</style>
    <style>:root {
    --bg: #0c0c0c;
    --accent-bg: #0d0707;
    --border: #614721;
/*    --text: #d2d2d2;*/
    --text: #fff;
    --text-light: #888888;
    --accent-light: #ffc57b;
/*    --header: #c4beb9;*/
    --header: #b5aea8;
    /* --accent-light: #fab760; */
    --accent: #ffa430;
    --marked: #ffa430;
    --mono-font: Consolas, Menlo, Monaco, "Andale Mono", "Ubuntu Mono", monospace;
    --keyword: #ff7d67;

    --header-line: #333;

    --nav-width: 15em;
}

html {
    scroll-behavior: auto;
}

h1 {
    font-size: 2em;
    font-weight: normal;
    margin-top: 1.5em;
}

h2 {
    font-size: 1.5em;
    font-weight: normal;
}

h3 {
    font-weight: normal;
}

h4 {
    font-weight: normal;
}

h5 {
    font-weight: normal;
}

h6 {
    font-weight: normal;
}

h1 a, h2 a, h3 a, h4 a, h5 a, h6 a {
    opacity: 0;
    text-decoration: none
}

h1:hover a, h2:hover a, h3:hover a, h4:hover a, h5:hover a, h6:hover a {
    opacity: initial
}

h1.title {
    color: var(--accent);
    margin-bottom: 10px;
}

html, body {
    font-size: 18px;

    /* Reset to defaults */ 
    letter-spacing: normal;
    -webkit-font-smoothing: auto;
    -moz-osx-font-smoothing: auto;
    background-color: var(--bg);
    color: var(--text);
}

header ul {
    list-style-type: none;
    padding-left: 0px;
}

header a {
    white-space: nowrap;
}

body > header {
    height: 100%;
    width: var(--nav-width);
    padding-left: 40px;
    text-align: left;
    position: fixed;
    top: 0;
    left: 0;
    overflow-y: auto;
    background-color: var(--bg);
}

header ul li {
    display: list-item;
    margin-right: 0px;
}

body {
    display: block;
}

main {
    padding-top: 0px;
    padding-left: calc(var(--nav-width) + 20px);
    padding-right: 20px;
}

em {
    font-style: normal;
    color: #fb6767;
}

/* mobile */
@media screen and (max-width: 720px) {
    body {
        display: grid;
    }

    /* Make 2 column navs fit */
    table ul {
        padding-left: 20px;
    }
    table ul ul {
        padding-left: 0px;
    }
    table td {
        padding: 0.5rem 0 0.5rem 0;
    }

    body > header {
        position: static;
        padding-left: 0px;
        height: initial;
        width: initial;
        top: initial;
        left: initial;
        text-align: center;
        overflow-y: visible;
        background-color: var(--accent-bg);
    }

    main {
        padding-left: 0px;
        padding-right: 0px;
    }

    header ul {
        margin-top: 0px;
        margin-bottom: 0px;
    }

    header ul li {
        display: inline;
        margin-right: 5px;
    }
}

a.current {
    text-decoration: none;
}

h1 {
/*    color: var(--accent);*/
/*    font-weight: bold;*/
}

.markdown h2 {
    color: var(--header);
    font-weight: bold; 
    margin-top: 60px;
}

h3 {
    color: var(--header);
/*    font-weight: bold; */
    font-size: 1.2em;
    margin-top: 2.2em;

    padding: 0.5rem 1rem 0.7rem 0.75rem;
    border-bottom: 0.15rem solid var(--header-line);
    border-radius: 0rem;
}

main h2 > code {
    color: var(--header);
    font-size: 0.9em;
    background-color: transparent;
}

main h3 > code {
    color: var(--header);
    font-size: 0.9em;
    background-color: transparent;
}

.markdown table tr th {
    text-align: left;
    color: var(--text-light);
    font-weight: normal;
}

.markdown table tr th, .markdown table tr td {
    border: 3px solid #222;
}

.markdown table tr td:first-child code {
    font-size: 15px;
}

.book-search input {
    background-color: var(--bg);
    border: 3px solid #222;
}

.book-menu .book-brand a {
    color: var(--accent);
    font-weight: bold;
}

.book-menu a {
    color: var(--accent-light);
}
.book-menu a:hover {
    opacity: 1;
    color: var(--accent-light);
    text-decoration: underline;
}

.book-menu a.active {
    color: var(--accent);
    font-weight: bold;
    text-decoration: underline;
}

ul a {
    color: var(--accent-light);
}

a {
    color: var(--accent);
}

.markdown a:visited {
    color: var(--accent);
    text-decoration: underline;
}
.markdown a {
    color: var(--accent);
    text-decoration: underline;
}

:focus {
    outline-style: none;
}

/* inline code */
main code {
    font-size: 17px;
    background: none;
    color: var(--accent-light);
    padding: 2px 6px;
}

/* block code */
main pre code {
    font-size: 15px;
    color: var(--text);
    font-weight: normal;
    font-family: var(--mono-font);
}

pre {
/*    padding: 10px;*/
    font-size: 15px;
    border: 0px solid var(--border);
    background-color: #171717;
}

pre code.hljs {
    padding: 0px;
    white-space: pre-wrap;
}

.hljs {
/*    background-color: var(--accent-bg);*/
    background-color: transparent;
}

.hljs-params {
    color: #c9d1d9;
}

blockquote {
    margin: 20px 0 20px 0;
    font-style: normal;
    border-left: 3px solid var(--header-line);
    padding: 3px 0px 3px 15px;
    color: var(--text);
}

blockquote p:nth-child(2) {
    margin-top: 5px;
}

blockquote p {
    margin: 0px;
    padding: 0px;
}

p {
    margin-block-start: 1.3em;
    margin-block-end: 1.3em;
}

blockquote em {
    color: #fb6767;
}

table {
    font-size: 18px;
    width: auto;
    line-height: 1.5em;
    display: table;
    margin: 0 0;
}

table thead {
    border-bottom: 0.15rem solid var(--header-line);
    width: auto;
}

table th {
    border: 0px solid var(--border);
    width: auto;
    background-color: transparent;
}

table td {
    border: 0px solid var(--border);
    width: auto;
}

table tbody tr:nth-child(even) {
    background-color: #111;
}
</style>
</head>
<body id="table-of-contents">
<header>
    <h1 class="title">Cyber Docs</h1>
    <div class="sub-title">v0.4-dev 419-2a2298d</div>
    <ul>
        <li><a href="https://cyberscript.dev" target="_blank" rel="noopener">Homepage</a></li>
        <li><a href="https://cyberscript.dev/play.html" target="_blank" rel="noopener">Playground</a></li>
        <li><a href="https://github.com/fubark/cyber/edit/master/docs/docs.md" target="_blank" rel="noopener">Edit Docs</a></li>
    </ul>
    <div class="sub-title">Table of Contents</div>
    <ul>
        <li><a href="#introduction">Introduction.</a></li>
<li><a href="#syntax">Syntax.</a></li>
<li><a href="#basic-types">Basic Types.</a></li>
<li><a href="#type-declarations">Type Declarations.</a></li>
<li><a href="#c-types">C Types.</a></li>
<li><a href="#control-flow">Control Flow.</a></li>
<li><a href="#functions">Functions.</a></li>
<li><a href="#memory">Memory.</a></li>
<li><a href="#error-handling">Error Handling.</a></li>
<li><a href="#concurrency">Concurrency.</a></li>
<li><a href="#dynamic-typing">Dynamic Typing.</a></li>
<li><a href="#metaprogramming">Metaprogramming.</a></li>
<li><a href="#modules">Modules.</a></li>
<li><a href="#ffi">FFI.</a></li>
<li><a href="#libcyber">libcyber.</a></li>
<li><a href="#cli">CLI.</a></li>
    </ul>
</header>
<main>
    <!--This does not contain module docs. Use docs.md from releases instead or generate it by using docs/gen-docs.cy -->
<h1 id="introduction">Introduction. <a href="#introduction">#</a></h1>
<p>Cyber is a fast, efficient, and concurrent scripting language. The landing page is at <a href="https://cyberscript.dev" title="">cyberscript.dev</a> and contains performance metrics and release notes.</p>
<p>These docs provide a reference manual for the language. You can read it in order or jump around using the navigation. You may come across features that are marked <code>Incomplete</code> or <code>Planned</code>. This is because the docs are written as if all features have been completed already.</p>
<h2 id="type-system">Type System. <a href="#type-system">#</a></h2>
<p>Cyber is a statically typed language. However, dynamic typing is also supported. If you're coming from a language such as Python, JavaScript, or Lua, it can be easier to get started with <a href="#dynamic-typing" title="">Dynamic Typing</a>.</p>
<a href="#introduction">^topic</a>
<h2 id="hello-world">Hello World. <a href="#hello-world">#</a></h2>
<pre><code class="language-cy">use math

var worlds = {'World', '世界', 'दुनिया', 'mundo'}
worlds.append(math.random())
for worlds -> w:
    print "Hello, $(w)!"
</code></pre>
<a href="#introduction">^topic</a>
<h1 id="syntax">Syntax. <a href="#syntax">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#statements" title="">Statements.</a></li>
<li><a href="#blocks" title="">Blocks.</a></li>
<li><a href="#variables" title="">Variables.</a><ul>
<li><a href="#local-variables" title="">Local variables.</a></li>
<li><a href="#explicit-type-constraint" title="">Explicit type constraint.</a></li>
<li><a href="#variable-scopes" title="">Variable scopes.</a></li>
<li><a href="#static-variables" title="">Static variables.</a></li>
<li><a href="#context-variables" title="">Context variables.</a></li>
<li><a href="#extern-variables" title=""><code>extern</code> variables.</a></li>
<li><a href="#use-global" title=""><code>use $global</code></a></li>
</ul>
</li>
<li><a href="#reserved-identifiers" title="">Reserved identifiers.</a><ul>
<li><a href="#keywords" title="">Keywords.</a></li>
<li><a href="#contextual-keywords" title="">Contextual keywords.</a></li>
<li><a href="#literals" title="">Literals.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#operators" title="">Operators.</a><ul>
<li><a href="#arithmetic-operators" title="">Arithmetic operators.</a></li>
<li><a href="#comparison-operators" title="">Comparison operators.</a></li>
<li><a href="#logic-operators" title="">Logic operators.</a></li>
<li><a href="#bitwise-operators" title="">Bitwise operators.</a></li>
<li><a href="#operator-overloading" title="">Operator overloading.</a></li>
</ul>
</li>
<li><a href="#zero-values" title="">Zero values.</a></li>
<li><a href="#type-casting" title="">Type casting.</a></li>
<li><a href="#comments" title="">Comments.</a></li>
<li><a href="#cyon" title="">CYON.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Cyber's syntax is concise and easy to read.</p>
<h2 id="statements">Statements. <a href="#statements">#</a></h2>
<p>A statement ends with the new line:</p>
<pre><code class="language-cy">var a = 123
</code></pre>
<p>To wrap a statement to the next line, the last token before the new line must be an operator or a separator:</p>
<pre><code class="language-cy">var gameover = health <= 0 or
    player.collidesWith(spikes)

if year > 2020 and year <= 2030 and
    month > 0 and month <= 11:
    print 'Valid'
</code></pre>
<p>Any token inside a delimited syntax (such as parentheses or braces) can be wrapped to the next line:</p>
<pre><code class="language-cy">var sum = add(1, 2, 3, 4,
    100, 200, 300, 400)

var colors = {'red', 'blue', 'green',
    'purple', 'orange', 'yellow'}
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="blocks">Blocks. <a href="#blocks">#</a></h2>
<p>Some statements can start a new block with a colon.
The first statement in a new block must be indented further.
Spaces or tabs can be used for indentation but not both.</p>
<pre><code class="language-cy">-- This `if` statement begins a new block.
if true:
    var a = 234
</code></pre>
<p>Subsequent statements in the block must follow the same indentation.
The block ends when a statement recedes from this indentation:</p>
<pre><code class="language-cy">var items = {10, 20, 30}
for items -> it:
    if it == 20:
        print it
    print it      -- This is the first statement outside of the `if` block.
</code></pre>
<p>Compact blocks allow only one statement after the starting block:</p>
<pre><code class="language-cy">-- A single line block.
if true: print 123

if true: print 123
    -- This is an indentation error since the compact block is already consumed.
    print 234
</code></pre>
<p>Since blocks require at least one statement, use <code>pass</code> as a placeholder statement:</p>
<pre><code class="language-cy">func foo():
    pass
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="variables">Variables. <a href="#variables">#</a></h2>
<p>Variables allow values to be stored into named locations in memory.</p>
<p>Local variables and static variables are supported.</p>
<a href="#syntax">^topic</a>
<h3 id="local-variables">Local variables. <a href="#local-variables">#</a></h3>
<p>Local variables exist until the end of their scope.
They are declared and initialized using the <code>var</code> keyword:</p>
<pre><code class="language-cy">var a = 123
</code></pre>
<p>When declared without a type specifier next to the variable, the type is inferred from the right initializer. In the above example, the variable <code>a</code> is initialized with the type <code>int</code>.</p>
<p>Variables can be assigned afterwards using the <code>=</code> operator:</p>
<pre><code class="language-cy">a = 234
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="explicit-type-constraint">Explicit type constraint. <a href="#explicit-type-constraint">#</a></h3>
<p>When a type specifier is provided, the value assigned to the variable must satisfy the type constraint or a compile error is reported:</p>
<pre><code class="language-cy">var a float = 123.0

var b int = 123.0    --> CompileError. Expected `int`, got `float`.
</code></pre>
<p>Any operation afterwards that violates the type constraint of the variable will result in a compile error</p>
<pre><code class="language-cy">a = 'hello'          --> CompileError. Expected `float`, got `String`.
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="variable-scopes">Variable scopes. <a href="#variable-scopes">#</a></h3>
<p>Blocks create a new variable scope. Variables declared in the current scope will take precedence over any parent variables with the same name:</p>
<pre><code class="language-cy">func foo():
    var a = 234

    if true:
        var a = 345     -- New `a` declared.
        print a         --> 345

    print a             --> 234
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="static-variables">Static variables. <a href="#static-variables">#</a></h3>
<p><em>Static variables will likely be removed in favor of <a href="#context-variables" title="">context variables</a>, constants, and <a href="#extern-variables" title=""><code>extern</code> variables</a>.</em></p>
<p>Static variables live until the end of the script.
They act as global variables and are visible from anywhere in the script.</p>
<p>Static variables are declared with <code>var</code> like local variables, but a namespace must be provided before the variable name:</p>
<pre><code class="language-cy">var .a = 123

func foo():
    print a     --> 123
</code></pre>
<p>The <code>.</code> prefix is used to reference the current module's namespace.</p>
<p>A type specifier can be provided after the variable name, otherwise, it's inferred from the initializer:</p>
<pre><code class="language-cy">var .my_map any = Map{}
</code></pre>
<p>Since static variables are initialized outside of a fiber's execution flow, they can not reference any local variables:</p>
<pre><code class="language-cy">var .b = a   --> Compile error, initializer can not reference a local variable.

-- Main execution.
var a = 123
</code></pre>
<p>However, they can be reassigned after initialization:</p>
<pre><code class="language-cy">var .b = 0

var a = 123
b = a            -- Reassigning after initializing.
</code></pre>
<p>Static variable initializers have a natural order based on when it was encountered by the compiler.
In the case of <a href="#importing" title="">imported</a> variables, the order of the import would affect this order.
The following would print '123' before '234':</p>
<pre><code class="language-cy">var .a = print(123)
var .b = print(234)
</code></pre>
<p>When the initializers reference other static variables, those child references are initialized first in DFS order and supersede the natural ordering. The following initializes <code>b</code> before <code>a</code>.</p>
<pre><code class="language-cy">var .a = b + 321
var .b = 123

print a        --> 444
</code></pre>
<p>Circular references in initializers are not allowed.
When initialization encounters a reference that creates a circular dependency an error is reported.</p>
<pre><code class="language-cy">var .a = b
var .b = a     --> CompileError. Referencing `a` creates a circular dependency.
</code></pre>
<p>Sometimes, you may want to initialize a static variable by executing multiple statements in order.
For this use case, you can use a declaration block. <em>Planned Feature</em></p>
<pre><code class="language-cy">var .myImage =:
    var img = loadImage('me.png')
    img.resize(100, 100)
    img.filter(.blur, 5)
    break img
</code></pre>
<p>The final resulting value that is assigned to the static variable is provided by a <code>break</code> statement. If a <code>break</code> statement is not provided, <code>none</code> is assigned instead.</p>
<a href="#syntax">^topic</a>
<h3 id="context-variables">Context variables. <a href="#context-variables">#</a></h3>
<p>Context variables are bound to each virtual thread and are accessible anywhere on the call stack.
All fibers created in the same virtual thread reference the same context variables.</p>
<p>Context variables used in the program must be declared in the main source file with a default value: <em>Planned Feature</em></p>
<pre><code class="language-cy">-- main.cy

context MyInt = 123
context MyString = 'abc'

print MyInt        --> 123
print MyString     --> abc
</code></pre>
<p>To reference a context variable in a different source file, redeclare it with the same type:</p>
<pre><code class="language-cy">-- foo.cy

context MyInt int

func foo():
    print MyInt    --> 123
</code></pre>
<p>Since this is a redeclaration, an assignment statement is not allowed.</p>
<p>Some context variables such as <code>mem</code> for <a href="#memory-allocations" title="">memory allocations</a> are already declared in every program, so it only needs a redeclaration:</p>
<pre><code class="language-cy">context mem Memory

var a = mem.new(int)
a.* = 123
print a.*          --> 123
mem.free(a)
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="extern-variables"><code>extern</code> variables. <a href="#extern-variables">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#syntax">^topic</a>
<h3 id="use-global"><code>use $global</code> <a href="#use-global">#</a></h3>
<p>When <code>use $global</code> is declared in the module, it allows the use of undeclared variables:</p>
<pre><code class="language-cy">use $global

a = 123
print a    --> 123
</code></pre>
<p>Accessing an undeclared variable before it's initialized results in a runtime error:</p>
<pre><code class="language-cy">use $global

print a    --> panic: `a` is not defined in `$global`.
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="reserved-identifiers">Reserved identifiers. <a href="#reserved-identifiers">#</a></h2>
<a href="#syntax">^topic</a>
<h3 id="keywords">Keywords. <a href="#keywords">#</a></h3>
<p>There are <code>29</code> general keywords. This list categorizes them:</p>
<ul>
<li><a href="#control-flow" title="">Control Flow</a>: <code>if</code> <code>else</code> <code>switch</code> <code>case</code> <code>while</code> <code>for</code> <code>break</code> <code>continue</code> <code>pass</code></li>
<li><a href="#operators" title="">Operators</a>: <code>or</code> <code>and</code> <code>not</code></li>
<li><a href="#variables" title="">Variables</a>: <a href="#local-variables" title=""><code>var</code></a> <a href="#context-variables" title=""><code>context</code></a></li>
<li><a href="#functions" title="">Functions</a>: <code>func</code> <code>return</code></li>
<li><a href="#fibers" title="">Fibers</a>: <code>coinit</code> <code>coyield</code> <code>coresume</code></li>
<li><a href="#async" title="">Async</a>: <code>await</code></li>
<li><a href="#custom-types" title="">Types</a>: <code>type</code>  <code>as</code></li>
<li><a href="#type-embedding" title="">Type embedding</a>: <code>use</code></li>
<li><a href="#error-handling" title="">Error Handling</a>: <code>try</code> <code>catch</code> <code>throw</code></li>
<li><a href="#modules" title="">Modules</a>: <code>use</code> <code>mod</code></li>
<li><a href="#dynamic-typing" title="">Dynamic Typing</a>: <code>dyn</code></li>
</ul>
<a href="#syntax">^topic</a>
<h3 id="contextual-keywords">Contextual keywords. <a href="#contextual-keywords">#</a></h3>
<p>These keywords only have meaning in a certain context.</p>
<ul>
<li><a href="#methods" title="">Methods</a>: <code>self</code> <code>Self</code></li>
<li><a href="#custom-types" title="">Types</a>: <a href="#objects" title=""><code>object</code></a> <a href="#structs" title=""><code>struct</code></a> <a href="#c-structs" title=""><code>cstruct</code></a> <a href="#enums" title=""><code>enum</code></a> <a href="#traits" title=""><code>trait</code></a></li>
<li><a href="#caught-variable" title="">Catching Errors</a>: <code>caught</code></li>
<li>Function Return: <code>void</code></li>
</ul>
<a href="#syntax">^topic</a>
<h3 id="literals">Literals. <a href="#literals">#</a></h3>
<ul>
<li><a href="#booleans" title="">Boolean literal</a>: <code>true</code> <code>false</code></li>
<li><a href="#symbols" title="">Symbol literal</a>: <code>symbol</code></li>
<li><a href="#error-value" title="">Error literal</a>: <code>error</code></li>
<li>None: <code>none</code></li>
</ul>
<a href="#syntax">^topic</a>
<h2 id="operators">Operators. <a href="#operators">#</a></h2>
<p>Cyber supports the following operators. They are ordered from highest to lowest precedence.</p>
<table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><code><<</code> <code>>></code></td><td>Bitwise left shift, right shift.</td></tr><tr><td><code>&</code></td><td>Bitwise and.</td></tr><tr><td><code>|</code> <code>||</code></td><td>Bitwise or, exclusive or.</td></tr><tr><td><code>^</code></td><td>Power.</td></tr><tr><td><code>/</code> <code>%</code> <code>*</code></td><td>Division, modulus, multiplication.</td></tr><tr><td><code>+</code> <code>-</code></td><td>Addition, subtraction.</td></tr><tr><td><code>as</code></td><td>Type casting.</td></tr><tr><td><code>></code> <code>>=</code> <code><</code> <code><=</code> <code>!=</code> <code>==</code></td><td>Greater, greater or equal, less, less or equal, not equals, equals.</td></tr><tr><td><code>and</code></td><td>Logical and.</td></tr><tr><td><code>or</code></td><td>Logical or.</td></tr><tr><td><code>..</code> <code>-..</code></td><td>Range, reversed range.</td></tr></tbody></table><a href="#syntax">^topic</a>
<h3 id="arithmetic-operators">Arithmetic Operators. <a href="#arithmetic-operators">#</a></h3>
<p>The following arithmetic operators are supported for the <a href="#numbers" title="">numeric data types</a>.</p>
<pre><code class="language-cy">1 + 2     -- Addition, evaluates to 3.
100 - 10  -- Subtraction, evaluates to 90.
3 * 4     -- Multiplication, evaluates to 12.
20 / 5    -- Division, evaluates to 4.
2 ^ 4     -- Raise to the power, evaluates to 16.
12 % 5    -- Modulus remainder, evaluates to 2.
-(10)     -- Apply negative, evaluates to -10.
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="comparison-operators">Comparison Operators. <a href="#comparison-operators">#</a></h3>
<p>Cyber supports the following comparison operators.
By default, a comparison operator evaluates to a <a href="#booleans" title="">Boolean</a> value.</p>
<p>The equals operator returns true if the two values are equal. For primitive types, the comparison checks the types and the underlying value. For strings, the underlying bytes are compared for equality. For objects, the comparison checks that the two values reference the same object.</p>
<pre><code class="language-cy">1 == 1      -- Evaluates to `true`
1 == 2      -- Evaluates to `false`
1 == true   -- Evaluates to `false`

var a = 'abc'
a == 'abc'  -- Evaluates to `true`

a = {_}
var b = a
a == b      -- Evaluates to `true`
a == {_}    -- Evaluates to `false`
</code></pre>
<p>The not equals operator returns true if the two values are not equal.</p>
<pre><code class="language-cy">1 != 1      -- Evaluates to `false`
1 != 2      -- Evaluates to `true`
</code></pre>
<p>Number types have additional comparison operators.</p>
<pre><code class="language-cy">a > b    -- `true` if a is greater than b
a >= b   -- `true` if a is greater than or equal to b
a < b    -- `true` if a is less than b
a <= b   -- `true` if a is less than or equal to b
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="logic-operators">Logic Operators. <a href="#logic-operators">#</a></h3>
<p>The logical operators <code>and</code>, <code>or</code>, and <code>not</code> are supported.</p>
<p><code>and</code> evaluates to <code>true</code> if both operands are <code>true</code>. Otherwise, it evaluates to <code>false</code>. If the left operand is <code>false</code>, the evaluation of the right operand is skipped:</p>
<pre><code class="language-cy">true and true    --> true
true and false   --> false
false and true   --> false
false and false  --> false
</code></pre>
<p><code>or</code> evaluates to <code>true</code> if at least one of the operands is <code>true</code>. Otherwise, it evaluates to <code>false</code>. If the left operand is <code>true</code>, the evaluation of the right operand is skipped:</p>
<pre><code class="language-cy">true or true     --> true
true or false    --> true
false or true    --> true
false or false   --> false
</code></pre>
<p>The unary operator <code>not</code> performs negation on the boolean value. The unary operator <code>!</code> can also be used instead of <code>not</code>.</p>
<pre><code class="language-cy">not false     --> true
not true      --> false
!false        --> true
!true         --> false
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="bitwise-operators">Bitwise Operators. <a href="#bitwise-operators">#</a></h3>
<p>The following bitwise operators are supported for <code>int</code> number values.</p>
<pre><code class="language-cy">-- Bitwise and: any underlying bits that are set in both integers are set in the new integer.
a & b

-- Bitwise or: any underlying bits that are set in either integer a or integer b are set in the new integer.
a | b

-- Bitwise exclusive or: any underlying bits that are set in either integer a or integer b but not both are set in the new integer.
a || b

-- Bitwise right shift: a's bits are shifted b bits to the least significant end. This performs sign-extension on the 32-bit integer.
a >> b

-- Bitwise left shift: a's bits are shifted b bits to the most significant end. This does not perform sign-extension on the 32-bit integer.
a << b

-- Bitwise not: a's integer bits are flipped.
~a
</code></pre>
<a href="#syntax">^topic</a>
<h3 id="operator-overloading">Operator overloading. <a href="#operator-overloading">#</a></h3>
<p>See <a href="#operator-overloading-1" title="">Operator overloading</a> in Metaprogramming.</p>
<a href="#syntax">^topic</a>
<h2 id="zero-values">Zero values. <a href="#zero-values">#</a></h2>
<p>Uninitialized type fields currently default to their zero values. However, this implicit behavior will be removed in the future in favor of a default value clause. Zero values must then be expressed using the reserved <code>zero</code> literal.</p>
<p>The following shows the zero values of builtin or created types:</p>
<table><thead><tr><th>Type</th><th>Zero value</th></tr></thead><tbody><tr><td><code>boolean</code></td><td><code>false</code></td></tr><tr><td><code>int</code></td><td><code>0</code></td></tr><tr><td><code>float</code></td><td><code>0.0</code></td></tr><tr><td><code>String</code></td><td><code>''</code></td></tr><tr><td><code>List[T]</code></td><td><code>List[T]{}</code></td></tr><tr><td><code>Map</code></td><td><code>Map{}</code></td></tr><tr><td><code>type S</code></td><td><code>S{}</code></td></tr><tr><td><code>@host type S</code></td><td><code>S.$zero()</code></td></tr><tr><td><code>dyn</code></td><td><code>int(0)</code></td></tr><tr><td><code>any</code></td><td><code>int(0)</code></td></tr><tr><td><code>?S</code></td><td><code>Option[S].none</code></td></tr></tbody></table><a href="#syntax">^topic</a>
<h2 id="type-casting">Type casting. <a href="#type-casting">#</a></h2>
<p>The <code>as</code> keyword can be used to cast a value to a specific type. Casting lets the compiler know what the expected type is and does not perform any conversions.</p>
<p>If the compiler knows the cast will always fail at runtime, a compile error is returned instead.</p>
<pre><code class="language-cy">print('123' as int)       --> CompileError. Can not cast `String` to `int`.
</code></pre>
<p>If the cast fails at runtime, a panic is returned.</p>
<pre><code class="language-cy">var erased any = 123
add(1, erased as int)     --> Success.
print(erased as String)   --> panic: Can not cast `int` to `String`.

func add(a int, b int):
    return a + b
</code></pre>
<a href="#syntax">^topic</a>
<h2 id="comments">Comments. <a href="#comments">#</a></h2>
<p>A single line comment starts with two hyphens and ends at the end of the line.</p>
<pre><code class="language-cy">-- This is a comment.

var a = 123   -- This is a comment on the same line as a statement.
</code></pre>
<p>There will be multi-line comments in Cyber but the syntax has not been determined.</p>
<a href="#syntax">^topic</a>
<h2 id="cyon">CYON. <a href="#cyon">#</a></h2>
<p>CYON or the Cyber object notation is similar to JSON. The format uses the same literal value semantics as Cyber.</p>
<pre><code class="language-cy">{
    name  = 'John Doe',
    'age' = 25,

    -- This is a comment
    cities = {
        'New York',
        'San Francisco',
        'Tokyo',
    },
}
</code></pre>
<a href="#syntax">^topic</a>
<h1 id="basic-types">Basic Types. <a href="#basic-types">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#booleans" title="">Booleans.</a></li>
<li><a href="#numbers" title="">Numbers.</a><ul>
<li><a href="#integers" title="">Integers.</a></li>
<li><a href="#floats" title="">Floats.</a></li>
<li><a href="#big-numbers" title="">Big Numbers.</a></li>
</ul>
</li>
<li><a href="#strings" title="">Strings.</a><ul>
<li><a href="#raw-string-literal" title="">Raw string literal.</a></li>
<li><a href="#string-literal" title="">String literal.</a></li>
<li><a href="#escape-sequences" title="">Escape sequences.</a></li>
<li><a href="#string-indexing" title="">String indexing.</a></li>
<li><a href="#string-concatenation" title="">String concatenation.</a></li>
<li><a href="#string-interpolation" title="">String interpolation.</a></li>
<li><a href="#string-formatting" title="">String formatting.</a></li>
<li><a href="#line-join-literal" title="">Line-join literal.</a></li>
<li><a href="#mutable-strings" title="">Mutable strings.</a></li>
</ul>
</li>
<li><a href="#symbols" title="">Symbols.</a></li>
</ul>
</td>
<td valign="top">
<ul>
<li><a href="#optionals" title="">Optionals.</a><ul>
<li><a href="#wrap-value" title="">Wrap value.</a></li>
<li><a href="#wrap-none" title="">Wrap <code>none</code>.</a></li>
<li><a href="#unwrap-or-panic" title="">Unwrap or panic.</a></li>
<li><a href="#unwrap-or-default" title="">Unwrap or default.</a></li>
<li><a href="#optional-chaining" title="">Optional chaining.</a></li>
<li><a href="#if-unwrap" title=""><code>if</code> unwrap.</a></li>
<li><a href="#while-unwrap" title=""><code>while</code> unwrap.</a></li>
</ul>
</li>
<li><a href="#arrays" title="">Arrays.</a></li>
<li><a href="#lists" title="">Lists.</a></li>
<li><a href="#tables" title="">Tables.</a><ul>
<li><a href="#table-indexing" title="">Table indexing.</a></li>
<li><a href="#check-field-existence" title="">Check field existence.</a></li>
<li><a href="#prototypes" title="">Prototypes.</a></li>
</ul>
</li>
<li><a href="#maps" title="">Maps.</a><ul>
<li><a href="#map-indexing" title="">Map indexing.</a></li>
<li><a href="#map-operations" title="">Map operations.</a></li>
<li><a href="#map-block" title="">Map block.</a></li>
</ul>
</li>
<li><a href="#any" title=""><code>any</code>.</a></li>
<li><a href="#dyn" title=""><code>dyn</code>.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>In Cyber, there are value types and reference types.
This section will describe common builtin types.</p>
<h2 id="booleans">Booleans. <a href="#booleans">#</a></h2>
<p>Booleans can be <code>true</code> or <code>false</code>. See <a href="#type-bool" title=""><code>type bool</code></a>.</p>
<pre><code class="language-cy">var a = true
if true:
    print 'a is true'
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="numbers">Numbers. <a href="#numbers">#</a></h2>
<a href="#basic-types">^topic</a>
<h3 id="integers">Integers. <a href="#integers">#</a></h3>
<p><code>int</code> is the default integer type and is an alias for <code>int64</code>.
It has 64-bits representing integers in the range -(2<sup>63</sup>) to 2<sup>63</sup>-1.
Integer types use the two's complement format.</p>
<p>The following integer types are supported: <a href="#type-byte" title=""><code>byte</code></a>, <a href="#type-int8" title=""><code>int8</code></a>, <a href="#type-int16" title=""><code>int16</code></a>, <a href="#type-int32" title=""><code>int32</code></a>, <a href="#type-int64" title=""><code>int64</code></a>.
Integer types are named according to how many bits they occupy.</p>
<p>When a numeric literal is used and the type can not be inferred, it will default to the <code>int</code> type:</p>
<pre><code class="language-cy">var a = 123
</code></pre>
<p>Integer notations always produce an integer value:</p>
<pre><code class="language-cy">var a = 0xFF     -- hex.
a = 0o17         -- octal.
a = 0b1010       -- binary.
a = `🐶`         -- UTF-8 rune.
</code></pre>
<p>Arbitrary values can be converted to a <code>int</code> using the type as a function.</p>
<pre><code class="language-cy">var a = '123'
var b = int(a) 
</code></pre>
<p>In addition to arithmetic operations, integers can also perform <a href="#bitwise-operators" title="">bitwise operations</a>.</p>
<a href="#basic-types">^topic</a>
<h3 id="floats">Floats. <a href="#floats">#</a></h3>
<p><code>float</code> is the default floating point type. It has a (IEEE 754) 64-bit floating point format. See <a href="#type-float" title=""><code>type float</code></a>.</p>
<p>Although a <code>float</code> represents a decimal number, it can also represent integers between -(2<sup>53</sup>-1) and (2<sup>53</sup>-1). Any integers beyond the safe integer range is not guaranteed to have a unique representation.</p>
<p>A numeric literal can be used to create a <code>float</code> if the inferred type is a <code>float</code>:</p>
<pre><code class="language-cy">var a float = 123
</code></pre>
<p>Decimal and scientific notations always produce a <code>float</code> value:</p>
<pre><code class="language-cy">var a = 2.34567
var b = 123.0e4
</code></pre>
<p>Arbitrary values can be converted to a <code>float</code> using the type as a function.</p>
<pre><code class="language-cy">var a = '12.3'
var b = float(a) 
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="big-numbers">Big Numbers. <a href="#big-numbers">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#basic-types">^topic</a>
<h2 id="strings">Strings. <a href="#strings">#</a></h2>
<p>The <code>String</code> type represents a sequence of UTF-8 codepoints. Each code point is stored internally as 1-4 bytes. See <a href="#type-string" title=""><code>type String</code></a>.</p>
<p>Strings are not validated by default. If the codepoint is invalid at a particular index, the replacement character (0xFFFD) is returned instead.</p>
<p>Strings are <strong>immutable</strong>, so operations that do string manipulation return a new string. By default, short strings are interned to reduce memory footprint.</p>
<p>Under the hood, there are multiple string implementations to make operations faster by default using SIMD.</p>
<a href="#basic-types">^topic</a>
<h3 id="raw-string-literal">Raw string literal. <a href="#raw-string-literal">#</a></h3>
<p>A raw string doesn't allow any escape sequences or string interpolation.</p>
<p>Single quotes are used to delimit a single line literal:</p>
<pre><code class="language-cy">var fruit = 'apple'
var str = 'abc🦊xyz🐶'
</code></pre>
<p>Since raw strings interprets the sequence of characters as is, a single quote character can not be escaped:</p>
<pre><code class="language-cy">var fruit = 'Miso's apple'    -- ParseError.
</code></pre>
<p>Triple single quotes are used to delimit a multi-line literal. It also allows single quotes and double single quotes in the string:</p>
<pre><code class="language-cy">var fruit = '''Miso's apple'''
var greet = '''Hello
World'''
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="string-literal">String literal. <a href="#string-literal">#</a></h3>
<p>A string literal allows escape sequences and string interpolation.</p>
<p>Double quotes are used to delimit a single line literal:</p>
<pre><code class="language-cy">var fruit = "apple"
var sentence = "The $(fruit) is tasty."
var doc = "A double quote can be escaped: \""
</code></pre>
<p>Triple double quotes are used to delimit a multi-line literal:</p>
<pre><code class="language-cy">var title = "last"
var doc = """A double quote " doesn't need to be escaped."""
var str = """line a
line "b"
line $(title)
"""
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="escape-sequences">Escape sequences. <a href="#escape-sequences">#</a></h3>
<p>The following escape sequences are supported in string literals wrapped in double quotes:</p>
<table><thead><tr><th>Sequence</th><th>Code</th><th>Character</th></tr></thead><tbody><tr><td><code>\0</code></td><td>0x00</td><td>Null</td></tr><tr><td><code>\a</code></td><td>0x07</td><td>Terminal bell</td></tr><tr><td><code>\b</code></td><td>0x08</td><td>Backspace</td></tr><tr><td><code>\e</code></td><td>0x1b</td><td>Escape</td></tr><tr><td><code>\n</code></td><td>0x0a</td><td>Line feed</td></tr><tr><td><code>\r</code></td><td>0x0d</td><td>Carriage return</td></tr><tr><td><code>\t</code></td><td>0x09</td><td>Horizontal tab</td></tr><tr><td><code>\"</code></td><td>0x22</td><td>Double quote</td></tr><tr><td><code>\\</code></td><td>0x5c</td><td>Backslash</td></tr><tr><td><code>\x??</code></td><td>--</td><td>Hex number</td></tr></tbody></table><p>Example:</p>
<pre><code class="language-cy">print "\xF0\x9F\x90\xB6"    --> 🐶
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="string-indexing">String indexing. <a href="#string-indexing">#</a></h3>
<p>The index operator returns the rune starting at the given byte index:</p>
<pre><code class="language-cy">var a = 'abcxyz'
print a[1]          --> 98
print(a[1] == `b`)  --> true
</code></pre>
<p>If an index does not begin a sequence of valid UTF-8 bytes, the replacement character (0xFFFD, 65533) is returned:</p>
<pre><code class="language-cy">var a = '🐶abcxyz'
print a[1]          --> 65533
</code></pre>
<p>Since indexing operates at the byte level, it should not be relied upon for iterating runes or rune indexing.
However, if the string is known to only contain ASCII runes (each rune occupies one byte), indexing will return the expected rune.</p>
<p><code>String.seek</code> will always return the correct byte index for a rune index:</p>
<pre><code class="language-cy">var a = '🐶abcxyz'
print a.seek(2)         --> 5
print a[a.seek(2)]      --> 98 (`b`)
</code></pre>
<p>Similarily, slicing operates on byte indexes. Using the slice operator will return a view of the string at the given start and end (exclusive) indexes. The start index defaults to 0 and the end index defaults to the string's byte length:</p>
<pre><code class="language-cy">var str = 'abcxyz'
var sub = str[0..3]
print str[0..3]  --> abc
print str[..5]   --> abcxy
print str[1..]   --> bcxyz
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="string-concatenation">String concatenation. <a href="#string-concatenation">#</a></h3>
<p>Concatenate two strings together with the <code>+</code> operator or the method <code>concat</code>.</p>
<pre><code class="language-cy">var res = 'abc' + 'xyz'
res = res.concat('end')
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="string-interpolation">String interpolation. <a href="#string-interpolation">#</a></h3>
<p>Expressions can be embedded into string templates with <code>$()</code>:</p>
<pre><code class="language-cy">var name = 'Bob'
var points = 123
var str = "Scoreboard: $(name) $(points)"
</code></pre>
<p>String templates can not contain nested string templates.</p>
<a href="#basic-types">^topic</a>
<h3 id="string-formatting">String formatting. <a href="#string-formatting">#</a></h3>
<p>Values that can be formatted into a string will have a <code>fmt</code> method:</p>
<pre><code class="language-cy">var file = os.openFile('data.bin', .read)
var bytes = file.readAll()

-- Dump contents in hex.
print "$(bytes.fmt(.x))"
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="line-join-literal">Line-join literal. <a href="#line-join-literal">#</a></h3>
<p>The line-join literal joins string literals with the new line character <code>\n</code>. <em>Planned Feature</em></p>
<p>This has several properties:</p>
<ul>
<li>Ensures the use of a consistent line separator: <code>\n</code></li>
<li>Allows lines to have a mix of raw string or string literals.</li>
<li>Single quotes and double quotes do not need to be escaped.</li>
<li>Allows each line to be indented along with the surrounding syntax.</li>
<li>The starting whitespace for each line is made explicit.</li>
</ul>
<pre><code class="language-cy">var paragraph = {
    \'the line-join literal
    \'hello\nworld
    \"hello $(name)
    \'last line
    \'
}
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="mutable-strings">Mutable strings. <a href="#mutable-strings">#</a></h3>
<p>To mutate an existing string, use <a href="#mutstring" title="">type MutString</a>. <em>Planned Feature</em></p>
<a href="#basic-types">^topic</a>
<h2 id="optionals">Optionals. <a href="#optionals">#</a></h2>
<p>An Optional is a value type that provides <strong>null safety</strong> by forcing the inner value to be unwrapped before it can be used.</p>
<p>The <code>Option</code> template type is a choice type that either holds a <code>none</code> value or contains <code>some</code> value. The option template is defined as:</p>
<pre><code class="language-cy">type Option[T type] enum:
    case none
    case some T
</code></pre>
<p>A type prefixed with <code>?</code> is the idiomatic way to create an option type. The following String optional types are equivalent:</p>
<pre><code class="language-cy">Option[String]
?String
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="wrap-value">Wrap value. <a href="#wrap-value">#</a></h3>
<p>A value is automatically wrapped into the inferred optional's <code>some</code> case:</p>
<pre><code class="language-cy">var a ?String = 'abc'
print a     --> some(abc)'
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="wrap-none">Wrap <code>none</code>. <a href="#wrap-none">#</a></h3>
<p><code>none</code> is automatically initialized to the inferred optional's <code>none</code> case:</p>
<pre><code class="language-cy">var a ?String = none
print a     --> none
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="unwrap-or-panic">Unwrap or panic. <a href="#unwrap-or-panic">#</a></h3>
<p>The <code>.?</code> access operator is used to unwrap an optional. If the expression evaluates to the <code>none</code> case, the runtime panics:</p>
<pre><code class="language-cy">var opt ?int = 123
var v = opt.?
print v     --> 123
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="unwrap-or-default">Unwrap or default. <a href="#unwrap-or-default">#</a></h3>
<p>The <code>?else</code> control flow operator either returns the unwrapped value or a default value when the optional is <code>none</code>:</p>
<pre><code class="language-cy">var opt ?int = none
var v = opt ?else 123
print v     --> 123
</code></pre>
<p><code>?else</code> can be used in an assignment block: <em>Planned Feature</em></p>
<pre><code class="language-cy">var v = opt ?else:
    break 'empty'

var v = opt ?else:
    throw error.Missing
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="optional-chaining">Optional chaining. <a href="#optional-chaining">#</a></h3>
<p>Given the last member's type <code>T</code> in a chain of <code>?.</code> access operators, the chain's execution will either return <code>Option[T].none</code> on the first encounter of <code>none</code> or returns the last member as an <code>Option[T].some</code>: <em>Planned Feature</em></p>
<pre><code class="language-cy">print root?.a?.b?.c?.last
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="if-unwrap"><code>if</code> unwrap. <a href="#if-unwrap">#</a></h3>
<p>The <code>if</code> statement can be amended to unwrap an optional value using the capture <code>-></code> operator:</p>
<pre><code class="language-cy">var opt ?String = 'abc'
if opt -> v:
    print v     -- Prints 'abc'
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="while-unwrap"><code>while</code> unwrap. <a href="#while-unwrap">#</a></h3>
<p>The <code>while</code> statement can be amended to unwrap an optional value using the capture <code>-></code> operator.
The loop exits when <code>none</code> is encountered:</p>
<pre><code class="language-cy">var iter = dir.walk()
while iter.next() -> entry:
    print entry.name
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="arrays">Arrays. <a href="#arrays">#</a></h2>
<p>An array type is a value type and is denoted as <code>[N]T</code> where <code>N</code> is the size of the array and <code>T</code> is the element type.
See <a href="#type-array" title=""><code>type Array</code></a>.</p>
<p>Arrays are initialized with its type followed by the initializer literal:</p>
<pre><code class="language-cy">var a = [3]int{1, 2, 3}
</code></pre>
<p>The number of elements can be inferred using pseudo type <code>[.]T</code>: <em>Planned Feature</em></p>
<pre><code class="language-cy">var a = [.]int{1, 2, 3}
</code></pre>
<p>The array type can be inferred by the dot initializer literal:</p>
<pre><code class="language-cy">var a [3]int = .{1, 2, 3}
</code></pre>
<p>Arrays can be indexed:</p>
<pre><code class="language-cy">a[2] = 300
print a[2]    --> 300
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="lists">Lists. <a href="#lists">#</a></h2>
<p>Lists are a builtin type that holds an ordered collection of elements. Lists grow or shrink as you insert or remove elements. See <a href="#type-list" title=""><code>type List</code></a>.</p>
<p>The first element of the list starts at index 0.
Lists are initialized with elements in braces:</p>
<pre><code class="language-cy">var list = {1, 2, 3}
print list[0]    --> 1
</code></pre>
<p>The empty list is initialized with an underscore as the only element:</p>
<pre><code class="language-cy">var list = {_}
print list.len() --> 0
</code></pre>
<p>Lists can be sliced with the range <code>..</code> clause. The sliced list becomes a new list that you can modify without affecting the original list. The end index is non-inclusive.</p>
<pre><code class="language-cy">var list = {1, 2, 3, 4, 5}
print list[0..0]    --> {_}          
print list[0..3]    --> {1, 2, 3}
print list[3..]     --> {4, 5}
print list[..3]     --> {1, 2, 3}
</code></pre>
<p>The <code>+..</code> invokes the slice operator with an end position that is an increment from the start: <em>Planned Feature</em></p>
<pre><code class="language-cy">var list = {1, 2, 3, 4, 5}
print list[2+..2]   --> {3, 4}
</code></pre>
<p>List operations.</p>
<pre><code class="language-cy">var list = {234}

-- Append a value.
list.append(123)

-- Inserting a value at an index.
list.insert(1, 345)

-- Get the length.
print list.len()  -- Prints '2'

-- Sort the list in place.
list.sort((a, b) => a < b)

-- Iterating a list.
for list -> it:
    print it

-- Remove an element at a specific index.
list.remove(1)
</code></pre>
<p>Since <code>List</code> is a generic type, an explicit List type can be attached to the initializer:</p>
<pre><code class="language-cy">var a = List[int]{1, 2, 3}
</code></pre>
<p>When the intializer is only prefixed with a dot, it will infer the List type constraint:</p>
<pre><code class="language-cy">var a List[int] = .{1, 2, 3}
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="tables">Tables. <a href="#tables">#</a></h2>
<p>A <code>Table</code> is a versatile object that can have an arbitrary set of fields.</p>
<p>By default, the record literal initializes a <code>Table</code>:</p>
<pre><code class="language-cy">var o = {}

o = {a=123}
print o.a          --> 123
</code></pre>
<p>A <code>Table</code> can be initialized explicitly using its type name:</p>
<pre><code class="language-cy">var o = Table{a=123}
</code></pre>
<p>Any field can be assigned a value.
However, accessing a field before it's initialized results in a panic:</p>
<pre><code class="language-cy">o.my_field = 234
print o.my_field   --> 234

print o.foo        --> panic: The field `foo` was not initialized.
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="table-indexing">Table indexing. <a href="#table-indexing">#</a></h3>
<p>Indexing can be used to access a dynamic field or an arbitrary key:</p>
<pre><code class="language-cy">var o = {name='Nova'}
var field = 'name'
print o[field]     --> Nova

o[10] = [1, 2, 3]
print o[10]        --> List (3)
</code></pre>
<p>If the key is not an identifier string, the value can only be obtained through indexing.</p>
<a href="#basic-types">^topic</a>
<h3 id="check-field-existence">Check field existence. <a href="#check-field-existence">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#basic-types">^topic</a>
<h3 id="prototypes">Prototypes. <a href="#prototypes">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#basic-types">^topic</a>
<h2 id="maps">Maps. <a href="#maps">#</a></h2>
<p>Maps are a builtin type that store key value pairs in dictionaries. See <a href="#type-map" title=""><code>type Map</code></a>.</p>
<p>Maps are initialized with the <code>Map</code> type and a record literal:</p>
<pre><code class="language-cy">var map = Map{a=123, b=() => 5}
</code></pre>
<p>The empty record literal creates an empty map:</p>
<pre><code class="language-cy">var empty = Map{}
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="map-indexing">Map indexing. <a href="#map-indexing">#</a></h3>
<p>Get a value from the map using the index operator:</p>
<pre><code class="language-cy">print map['a']
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="map-operations">Map operations. <a href="#map-operations">#</a></h3>
<pre><code class="language-cy">var map = Map{}

-- Set a key value pair.
map[123] = 234

-- Get the size of the map.
print map.size()

-- Remove an entry by key.
map.remove(123)

-- Iterating a map.
for map -> {val, key}:
    print "$(key) -> $(val)"
</code></pre>
<a href="#basic-types">^topic</a>
<h3 id="map-block">Map block. <a href="#map-block">#</a></h3>
<p>Entries can also follow a collection literal block.
This gives structure to the entries and has
the added benefit of allowing multi-line lambdas.
<em>Most likely this will not be implemented in favor of a builder syntax</em></p>
<pre><code class="language-cy">var colors = {}:
    .red   = 0xFF0000
    .green = 0x00FF00
    .blue  = 0x0000FF
    .dump  = func (c):
        print c.red
        print c.green
        print c.blue

    -- Nested map.
    .darker = {}: 
        .red   = 0xAA0000
        .green = 0x00AA00
        .blue  = 0x0000AA
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="symbols">Symbols. <a href="#symbols">#</a></h2>
<p>Symbol literals begin with <code>symbol.</code>, followed by an identifier.
Each symbol has a global unique ID.</p>
<pre><code class="language-cy">var currency = symbol.usd
print currency == .usd   --> true
print int(currency)      --> <unique ID>
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="any"><code>any</code>. <a href="#any">#</a></h2>
<p>Unlike <code>dyn</code>, <code>any</code> is statically typed and performs type checks at compile-time.
<code>any</code> type can hold any value, but copying it to narrowed type destination will result in a compile error:</p>
<pre><code class="language-cy">func square(i int):
    return i * i

var a any = 123
a = {'a', 'list'}         --> Valid assignment to a value with a different type.
a = 10

print square(a)           --> CompileError. Expected `int`, got `any`.
</code></pre>
<p><code>a</code> must be explicitly casted to satisfy the type constraint:</p>
<pre><code class="language-cy">print square(a as int)    --> 100
</code></pre>
<a href="#basic-types">^topic</a>
<h2 id="dyn"><code>dyn</code>. <a href="#dyn">#</a></h2>
<p>The dynamic type defers type checking to runtime. However, it also tracks its own <strong>recent type</strong> in order to surface errors at compile-time. See <a href="#dynamic-typing" title="">Dynamic Typing</a>.</p>
<a href="#basic-types">^topic</a>
<h1 id="type-declarations">Type Declarations. <a href="#type-declarations">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#objects" title="">Objects.</a><ul>
<li><a href="#instantiate" title="">Instantiate.</a></li>
<li><a href="#field-visibility" title="">Field visibility.</a></li>
<li><a href="#default-field-values" title="">Default field values.</a></li>
<li><a href="#circular-references" title="">Circular references.</a></li>
<li><a href="#unnamed-object" title="">Unnamed object.</a></li>
<li><a href="#methods" title="">Methods.</a></li>
<li><a href="#type-functions" title="">Type functions.</a></li>
<li><a href="#type-variables" title="">Type variables.</a></li>
<li><a href="#type-embedding" title="">Type embedding.</a></li>
</ul>
</li>
<li><a href="#structs" title="">Structs.</a><ul>
<li><a href="#declare-struct" title="">Declare struct.</a></li>
<li><a href="#copy-structs" title="">Copy structs.</a></li>
</ul>
</li>
<li><a href="#tuples" title="">Tuples.</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#enums" title="">Enums.</a></li>
<li><a href="#choices" title="">Choices.</a><ul>
<li><a href="#initialize-choice" title="">Initialize choice.</a></li>
<li><a href="#choice-switch" title="">Choice <code>switch</code>.</a></li>
<li><a href="#unwrap-choice" title="">Unwrap choice.</a></li>
</ul>
</li>
<li><a href="#type-aliases" title="">Type aliases.</a></li>
<li><a href="#distinct-types" title="">Distinct types.</a></li>
<li><a href="#traits" title="">Traits.</a></li>
<li><a href="#type-templates" title="">Type templates.</a><ul>
<li><a href="#expand-type-template" title="">Expand type template.</a></li>
<li><a href="#type-specialization" title="">Type specialization.</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="objects">Objects. <a href="#objects">#</a></h2>
<p>An object type contains field and function members. New instances can be created from them similar to a struct or class in other languages. Unlike classes, there is no builtin concept of inheritance but a similar effect can be achieved using composition and embedding.</p>
<p>Object types are declared with <code>type object</code>. The <code>object</code> keyword is optional when using a <code>type</code> declaration. These two declarations are equivalent:</p>
<pre><code class="language-cy">type A object:
    my_field int

type A:
    my_field int
</code></pre>
<p>Fields must be declared at the top of the <code>type</code> block with their names and type specifiers:</p>
<pre><code class="language-cy">type Node:
    value int
    next  ?Node
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="instantiate">Instantiate. <a href="#instantiate">#</a></h3>
<p>New object instances are created using a record literal with a leading type name:</p>
<pre><code class="language-cy">var node = Node{value=123, next=none}
print node.value       -- Prints "123"
</code></pre>
<p>A dot record literal can also initialize to the inferred object type:</p>
<pre><code class="language-cy">var node Node = .{value=234, next=none}
print node.value       -- Prints "234"
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="field-visibility">Field visibility. <a href="#field-visibility">#</a></h2>
<p>All fields have public visibility. However, when a field is declared with a <code>-</code> prefix, it suggests that it should not be made available to an editor's autocomplete:</p>
<pre><code class="language-cy">type Info:
    a       int
    -b      int
    -secret String
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="default-field-values">Default field values. <a href="#default-field-values">#</a></h3>
<p>When a field is omitted in the record literal, it gets initialized to its <a href="#zero-values" title="">zero value</a>:</p>
<pre><code class="language-cy">var node Node = .{value=234}
print node.next    --> Option.none

type Student:
    name String
    age  int
    gpa  float

var s = Student{}
print s.name       -->
print s.age        --> 0
print s.gpa        --> 0.0
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="circular-references">Circular references. <a href="#circular-references">#</a></h3>
<p>Circular type references are allowed if the object can be initialized:</p>
<pre><code class="language-cy">type Node:
    val  any
    next ?Node

var n = Node{}    -- Initializes.
</code></pre>
<p>In this example, <code>next</code> has an optional <code>?Node</code> type so it can be initialized to <code>none</code> when creating a new <code>Node</code> object.</p>
<p>The following example will fail because this version of <code>Node</code> can not be initialized:</p>
<pre><code class="language-cy">type Node:
    val  any
    next Node

var n = Node{}    -- CompileError. Can not zero initialize `next`
                   -- because of circular dependency.
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="unnamed-object">Unnamed object. <a href="#unnamed-object">#</a></h3>
<p>Unnamed object types can be declared and used without an explicit <code>type</code> declaration:</p>
<pre><code class="language-cy">type Node:
    value object:
        a  int
        b  float
    next  ?Node

var node = Node{
    value = .{a=123, b=100.0},
    next  = none,
}
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="methods">Methods. <a href="#methods">#</a></h3>
<p>Methods are functions that are invoked with a parent instance using the <code>.</code> operator.
When the first parameter of a function contains <code>self</code>, it's declared as a method of the parent type:</p>
<pre><code class="language-cy">type Node:
    value int
    next  ?Node

    func inc(self, n):
        self.value += n

    func incAndPrint(self):
        self.inc(321)
        print value

var n = Node{value=123, next=none}
n.incAndPrint()         -- Prints "444"
</code></pre>
<p><code>self</code> is then used to reference members of the parent instance.</p>
<p>Methods can be declared outside of the type declaration as a flat declaration:</p>
<pre><code class="language-cy">func Node.getNext(self):
    return self.next
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="type-functions">Type functions. <a href="#type-functions">#</a></h3>
<p>Type functions can be declared within the type block without a <code>self</code> param:</p>
<pre><code class="language-cy">type Node:
    value int
    next  ?Node

    func new():
        return Node{value=123, next=none}

var n = Node.new()
</code></pre>
<p>Type functions can also be declared outside of the type block using a flat declaration:</p>
<pre><code class="language-cy">type Node:
    value int
    next  ?Node

func Node.new():
    return Node{value=123, next=none}

var n = Node.new()
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="type-variables">Type variables. <a href="#type-variables">#</a></h3>
<p>Similarily, type variables are declared outside of the <code>type</code> block:</p>
<pre><code class="language-cy">-- Declare inside the `Node` namespace.
var Node.DefaultValue = 100

print Node.DefaultValue    -- Prints "100"
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="type-embedding">Type embedding. <a href="#type-embedding">#</a></h3>
<p>Type embedding facilitates type composition by using the namespace of a child field's type: <em>Planned Feature</em></p>
<pre><code class="language-cy">type Base:
    a int

    func double(self) int:
        return a * 2

type Container:
    b use Base

var c = Container{b = Base{a=123}}
print c.a         --> 123
print c.double()  --> 246
</code></pre>
<p>Note that embedding a type does not declare extra fields or methods in the containing type. It simply augments the type's using namespace by binding the embedding field.</p>
<p>If there is a member name conflict, the containing type's member has a higher precedence:</p>
<pre><code class="language-cy">type Container:
    a int
    b use Base

var c = Container{a=999, b = Base{a=123}}
print c.a         --> 999
print c.double()  --> 246
</code></pre>
<p>Since the embedding field is named, it can be used just like any other field:</p>
<pre><code class="language-cy">print c.b.a       --> 123
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="structs">Structs. <a href="#structs">#</a></h2>
<p>Struct types can contain field and method members just like object types, but their instances are copied by value rather than by reference. In that sense, they behave like primitive data types.</p>
<p>Unlike objects, structs are value types and do not have a reference count. They can be safely referenced with the <code>ref</code> modifier and their lifetime can be managed with single ownership semantics. Unsafe pointers can not reference structs by default, but there may be an unsafe builtin to allow it anyway.</p>
<a href="#type-declarations">^topic</a>
<h3 id="declare-struct">Declare struct. <a href="#declare-struct">#</a></h3>
<p>Struct types are created using the <code>type struct</code> declaration:</p>
<pre><code class="language-cy">type Vec2 struct:
    x float
    y float

var v = Vec2{x=30, y=40}
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="copy-structs">Copy structs. <a href="#copy-structs">#</a></h3>
<p>Since structs are copied by value, assigning a struct to another variable creates a new struct:</p>
<pre><code class="language-cy">var v = Vec2{x=30, y=40}
var w = v
v.x = 100
print w.x    -- Prints '30'
print v.x    -- Prints '100'
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="tuples">Tuples. <a href="#tuples">#</a></h2>
<p>Tuples can be declared using parentheses to wrap member fields:</p>
<pre><code class="language-cy">type Vec2 struct(x float, y float)
</code></pre>
<p>If the fields share the same type, they can be declared in a field group:</p>
<pre><code class="language-cy">type Vec3 struct(x, y, z float)
</code></pre>
<p>Function declarations can still be declared under the type:</p>
<pre><code class="language-cy">type Vec2 struct(x float, y float):
    func scale(self, s float):
        self.x *= s
        self.y *= s
</code></pre>
<p>Tuples can be initialized with member values corresponding to the order they were declared:</p>
<pre><code class="language-cy">var v = Vec2{3, 4}
</code></pre>
<p>The initializer can also be inferred from the target type:</p>
<pre><code class="language-cy">var v Vec2 = .{3, 4}
</code></pre>
<p>Tuples can still be initialized with explicit field names:</p>
<pre><code class="language-cy">var v = Vec2{x=3, y=4}
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="enums">Enums. <a href="#enums">#</a></h2>
<p>A new enum type can be declared with the <code>type enum</code> declaration.
An enum value can only be one of the unique symbols declared in the enum type.
By default, the symbols generate unique ids starting from 0.</p>
<pre><code class="language-cy">type Fruit enum:
    case apple
    case orange
    case banana
    case kiwi

var fruit = Fruit.kiwi
print fruit       -- 'Fruit.kiwi'
print int(fruit)  -- '3'
</code></pre>
<p>When the type of the value is known to be an enum, it can be assigned using a symbol literal.</p>
<pre><code class="language-cy">var fruit = Fruit.kiwi
fruit = .orange
print(fruit == Fruit.orange)   -- 'true'
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="choices">Choices. <a href="#choices">#</a></h2>
<p>Choices are enums with payloads (also known as sum types or tagged unions). An enum declaration becomes a choice type if one of the cases has a payload type specifier:</p>
<pre><code class="language-cy">type Shape enum:
    case rectangle Rectangle
    case circle    object:
        radius float
    case triangle  object:
        base   float
        height float
    case line      float
    case point 

type Rectangle:
    width  float
    height float
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="initialize-choice">Initialize choice. <a href="#initialize-choice">#</a></h3>
<p>The general way to initialize a choice is to invoke the initializer with the payload as the argument:</p>
<pre><code class="language-cy">var rect = Rectangle{width=10, height=20}
var s = Shape.rectangle(rect)

s = Shape.line(20)
</code></pre>
<p>If the payload is a record-like type, the choice can be initialized with a record literal:</p>
<pre><code class="language-cy">var s = Shape.rectangle{width=10, height=20}
</code></pre>
<p>A choice without a payload is initialized like an enum member:</p>
<pre><code class="language-cy">var s = Shape.point
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="choice-switch">Choice <code>switch</code>. <a href="#choice-switch">#</a></h3>
<p><code>case</code> clauses can match choices and capture the payload:</p>
<pre><code class="language-cy">switch s
case .rectangle -> r:
    print "$(r.width) $(r.height)"
case .circle -> c:
    print "$(c.radius)"
case .triangle -> t:
    print "$(t.base) $(t.height)"
case .line -> len:
    print "$(len)"
case .point:
    print "a point"
else:
    print "Unsupported."
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="unwrap-choice">Unwrap choice. <a href="#unwrap-choice">#</a></h3>
<p>A choice can be accessed by specifying the unwrap operator <code>.!</code> before the tagged member name. This will either return the payload or panic at runtime:</p>
<pre><code class="language-cy">var s = Shape{line=20}
print s.!line     --> 20
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="type-aliases">Type aliases. <a href="#type-aliases">#</a></h2>
<p>A type alias refers to a different target type.
Once declared, the alias and the target type can be used interchangeably.</p>
<p>A type alias declaration is denoted as <code>type A -> T</code> where <code>A</code> is the alias type of <code>T</code>:</p>
<pre><code class="language-cy">type Vec2:
    x float
    y float

type Pos2 -> Vec2

var pos = Pos2{x=3, y=4}
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="distinct-types">Distinct types. <a href="#distinct-types">#</a></h2>
<p>A distinct type creates a new type by copying a target type.</p>
<p>It's declared with <code>type</code> name declaration followed by the target type specifier:</p>
<pre><code class="language-cy">type Vec2:
    x float
    y float

type Pos2 Vec2

var pos = Pos2{x=3, y=4}
</code></pre>
<p>Functions can be declared under the new type's namespace:</p>
<pre><code class="language-">use math

type Pos2 Vec2:
    func blockDist(self, o Pos2):
        var dx = math.abs(o.x - x)
        var dy = math.abs(o.y - y)
        return dx + dy

var pos = Pos2{x=3, y=4}
var dst = Pos2{x=4, y=5}
print pos.blockDist(dst)     --> 2
</code></pre>
<p>Note that functions declared from the target type do not carry over to the new type.</p>
<p>Unlike a type alias, the new type and the target type can not be used interchangeably since they are different types. However, instances of the new type can be casted to the target type, and vice versa: <em>Planned Feature</em></p>
<pre><code class="language-cy">type Pos2 Vec2

var a = Pos2{x=3, y=4}

var b Vec2 = a as Vec2
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="traits">Traits. <a href="#traits">#</a></h2>
<p>A trait type defines a common interface for implementing types. A trait type is declared with the <code>trait</code> keyword:</p>
<pre><code class="language-cy">type Shape trait:
    func area(self) float
</code></pre>
<p>Types can implement a trait using the <code>with</code> keyword:</p>
<pre><code class="language-cy">type Circle:
    with Shape
    radius float

    func area(self) float:
        return 3.14 * self.radius^2

type Rectangle:
    with Shape
    width  float
    height float

    func area(self) float:
        return self.width * self.height
</code></pre>
<p>A type that intends to implement a trait but does not satisfy the trait's interface results in a compile error.</p>
<p>Implementing types become assignable to the trait type:</p>
<pre><code class="language-cy">var s Shape = Circle{radius=2}
print s.area()         --> 12.57

s = Rectangle{width=4, height=5}
print s.area()         --> 20
</code></pre>
<a href="#type-declarations">^topic</a>
<h2 id="type-templates">Type templates. <a href="#type-templates">#</a></h2>
<p>Type declarations can include template parameters to create a type template:</p>
<pre><code class="language-cy">type MyContainer[T type]:
    id    int
    value T

    func get(self) T:
        return self.value
</code></pre>
<a href="#type-declarations">^topic</a>
<h3 id="expand-type-template">Expand type template. <a href="#expand-type-template">#</a></h3>
<p>When the type template is invoked with template argument(s), a special version of the type is generated.</p>
<p>In this example, <code>String</code> can be used as an argument since it satisfies the <code>type</code> parameter constraint:</p>
<pre><code class="language-cy">var a MyContainer[String] = .{id=123, value='abc'}
print a.get()      -- Prints 'abc'
</code></pre>
<p>Note that invoking the template again with the same argument(s) returns the same generated type. In other words, the generated type is always memoized from the input parameters.</p>
<a href="#type-declarations">^topic</a>
<h3 id="type-specialization">Type specialization. <a href="#type-specialization">#</a></h3>
<p><a href="#value-templates" title="">Value templates</a> can be used to specialize type templates:</p>
<pre><code class="language-cy">def List[T type] type:
    if T == dyn:
        return DynList
    else:
        return GenList[T]

var a = List[int]{1, 2, 3}
</code></pre>
<a href="#type-declarations">^topic</a>
<h1 id="c-types">C Types. <a href="#c-types">#</a></h1>
<ul>
<li><a href="#c-primitives" title="">C primitives.</a></li>
<li><a href="#c-structs" title="">C structs.</a><ul>
<li><a href="#c-struct-methods" title="">C struct methods.</a></li>
<li><a href="#c-struct-reference" title="">C struct reference.</a></li>
</ul>
</li>
<li><a href="#pointers" title="">Pointers.</a><ul>
<li><a href="#dereferencing-pointers" title="">Dereferencing pointers.</a></li>
<li><a href="#pointer-indexing" title="">Pointer indexing.</a></li>
<li><a href="#pointer-arithmetic" title="">Pointer arithmetic.</a></li>
<li><a href="#pointer-casting" title="">Pointer casting.</a></li>
<li><a href="#pointer-slicing" title="">Pointer slicing.</a></li>
<li><a href="#pointer-conversions" title="">Pointer conversions.</a></li>
</ul>
</li>
<li><a href="#pointer-slices" title="">Pointer slices.</a></li>
<li><a href="#union-types" title="">Union types.</a></li>
</ul>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>C types interop with C-ABI types and are used to represent external or manual memory.
Using C types is considered unsafe, but runtime safety checks can be inserted to make it safer at the cost of runtime performance.</p>
<h2 id="c-primitives">C primitives. <a href="#c-primitives">#</a></h2>
<p>This table shows the size and type compatibility of Cyber and C types:</p>
<table><thead><tr><th>Cyber</th><th>C</th><th>Size (bits)</th></tr></thead><tbody><tr><td>void</td><td>void</td><td>0, used as *void</td></tr><tr><td>int8</td><td>int8_t</td><td>8</td></tr><tr><td>byte</td><td>uint8_t</td><td>8</td></tr><tr><td>c_char</td><td>char</td><td>8</td></tr><tr><td>int16</td><td>int16_t</td><td>16</td></tr><tr><td>c_short</td><td>short</td><td>16*</td></tr><tr><td>c_uint16</td><td>uint16_t</td><td>16</td></tr><tr><td>c_ushort</td><td>unsigned short</td><td>16*</td></tr><tr><td>int32</td><td>int32_t</td><td>32</td></tr><tr><td>c_int</td><td>int</td><td>32*</td></tr><tr><td>c_uint32</td><td>uint32_t</td><td>32</td></tr><tr><td>c_uint</td><td>unsigned int</td><td>32*</td></tr><tr><td>int, int64</td><td>int64_t</td><td>64</td></tr><tr><td>c_long</td><td>long</td><td>64*</td></tr><tr><td>c_uint64</td><td>uint64_t</td><td>64</td></tr><tr><td>c_ulong</td><td>unsigned long</td><td>64*</td></tr><tr><td>c_longlong</td><td>long long</td><td>64*</td></tr><tr><td>c_ulonglong</td><td>unsigned long long</td><td>64*</td></tr><tr><td>float32</td><td>float</td><td>32</td></tr><tr><td>float, float64</td><td>double</td><td>64</td></tr><tr><td>c_longdouble</td><td>long double</td><td>80*</td></tr><tr><td>*T, pointer[T]</td><td>T*</td><td>64*</td></tr></tbody></table><p>* Varies depending on C compiler and architecture. Pointers may occupy an extra word size for runtime memory checks.</p>
<a href="#c-types">^topic</a>
<h2 id="c-structs">C structs. <a href="#c-structs">#</a></h2>
<p><code>C structs</code> are unsafe since they can be referenced by unsafe <a href="#pointers" title="">pointers</a>. The underlying memory could be corrupted or invalidated before use.
In contrast, <a href="#structs" title="">structs</a> can be safely used since they can only be instantiated in safe memory.</p>
<p><code>C structs</code> can be declared with the <code>cstruct</code> keyword:</p>
<pre><code class="language-cy">type Data cstruct:
    x   float
    y   float
    ptr *int
    str [*]byte
</code></pre>
<p>A <code>C struct</code> may contain:</p>
<ul>
<li>C types.</li>
<li>Primitive types.</li>
<li>Container types that contain a compatible element type. This includes <code>enums</code>, <code>choices</code>, and <code>optionals</code>.</li>
</ul>
<p>It may not contain <code>structs</code> or <code>objects</code>.</p>
<a href="#c-types">^topic</a>
<h3 id="c-struct-methods">C struct methods. <a href="#c-struct-methods">#</a></h3>
<p><code>C structs</code> can be declared with methods:</p>
<pre><code class="language-cy">type Vec2 cstruct:
    x float
    y float

    func add(self, o Vec2):
        return Vec2{
            x = self.x+o.x,
            y = self.y+o.y,
        }

var v = Vec2{x=1, y=2}
print v.add(Vec2{x=2, y=1})   --> Vec2{x=3, y=3}
</code></pre>
<p>In this example <code>add</code> passes the receiver by value.</p>
<p>In order to pass the receiver by reference, <code>self</code> must be annotated with <code>*</code>:</p>
<pre><code class="language-cy">type Vec2 cstruct:
    x float
    y float

    func add(*self, o Vec2):
        self.x += o.x
        self.y += o.y

var v = Vec2{x=1, y=2}
v.add(Vec2{x=2, y=1})
print v                 --> Vec2{x=3, y=3}
</code></pre>
<a href="#c-types">^topic</a>
<h3 id="c-struct-reference">C struct reference. <a href="#c-struct-reference">#</a></h3>
<p>The <code>*</code> operator is used to obtain the pointer to a <code>C struct</code> value:</p>
<pre><code class="language-cy">type Vec2 cstruct:
    x float
    y float

var v = Vec2{x=1, y=2}
var ref = *v
ref.x = 4

print v                 --> Vec2{x=4, y=2}
</code></pre>
<p>The reference is a <a href="#pointers" title="">pointer</a> type that points to the <code>C struct</code>:</p>
<pre><code class="language-">func scale(a *Vec2, n float):
    a.x *= n
    a.y *= n

add(*v, 10)
print v                 --> Vec2{x=40, y=20}
</code></pre>
<a href="#c-types">^topic</a>
<h2 id="pointers">Pointers. <a href="#pointers">#</a></h2>
<p>A <code>pointer</code> is a reference to a memory location. Its type is denoted as <code>*T</code> where <code>T</code> is the type that the pointer references in memory:</p>
<pre><code class="language-cy">func setName(p *Person, name [*]byte):
    p.name = name

var p = Person{}
setName(*p, 'Spock')
</code></pre>
<p>Depending on the target architecture, the alignment of the pointer will either be at least 8 bytes on a 64-bit machine or 4 bytes on a 32-bit machine. Aligned pointers will be supported in a future version.</p>
<p>Pointers are unsafe since they can reference corrupted or invalidated memory.
When runtime memory checks are enabled, pointers will occupy an extra word size in order to set traps and prevent unsafe uses of pointers. See <a href="#runtime-memory-checks" title="">Memory / Runtime memory checks</a>.</p>
<p>A pointer can be created with an explicit address using <code>pointer</code>.</p>
<pre><code class="language-cy">var ptr = pointer(void, 0xDEADBEEF)
print ptr.value()     --'3735928559'
</code></pre>
<a href="#c-types">^topic</a>
<h3 id="dereferencing-pointers">Dereferencing pointers. <a href="#dereferencing-pointers">#</a></h3>
<p>Pointers are dereferenced using the accessor operator <code>.*</code>:</p>
<pre><code class="language-cy">var a = 123
var ptr = *a
print ptr.*      --> 123

ptr.* = 10
print a          --> 10
</code></pre>
<a href="#c-types">^topic</a>
<h3 id="pointer-indexing">Pointer indexing. <a href="#pointer-indexing">#</a></h3>
<p>The index operator is used to read or write to a particular element:</p>
<pre><code class="language-cy">var a = mem.alloc(int, 10)
a[5] = 123
print a[5]       --> 123
</code></pre>
<p>Negative indexing will locate the element before the pointer's address.</p>
<a href="#c-types">^topic</a>
<h3 id="pointer-arithmetic">Pointer arithmetic. <a href="#pointer-arithmetic">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#c-types">^topic</a>
<h3 id="pointer-casting">Pointer casting. <a href="#pointer-casting">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#c-types">^topic</a>
<h3 id="pointer-slicing">Pointer slicing. <a href="#pointer-slicing">#</a></h3>
<p>The slice operator will produce a new slice of type <code>[*]T</code> from a <code>*T</code> pointer type:</p>
<pre><code class="language-cy">var ints = mem.alloc(int, 10)
var slice = ints[0..5]
print typeof(slice)    --> []int
</code></pre>
<a href="#c-types">^topic</a>
<h3 id="pointer-conversions">Pointer conversions. <a href="#pointer-conversions">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#c-types">^topic</a>
<h2 id="pointer-slices">Pointer slices. <a href="#pointer-slices">#</a></h2>
<p>Slices are pointers with a length field. They are denoted as <code>[*]T</code> where T is the element type.</p>
<p>A slice can be created by taking the pointer of an array: <em>Planned feature</em></p>
<pre><code class="language-cy">var arr = [3]int{1, 2, 3}
var s = *arr
</code></pre>
<p>Read and write an element with the index operator:</p>
<pre><code class="language-cy">print s[0]        --> 1
s[1] = 123
print s[1]        --> 123
</code></pre>
<p>Slices provide bounds checking when runtime safety is enabled: <em>Planned feature</em></p>
<pre><code class="language-cy">print s[100]      --> Panic. Out of bounds.
</code></pre>
<p>Slice operations can be applied: <em>Planned feature</em></p>
<pre><code class="language-cy">print s[0..2]     --> {1, 2}
</code></pre>
<a href="#c-types">^topic</a>
<h2 id="union-types">Union types. <a href="#union-types">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#c-types">^topic</a>
<h1 id="control-flow">Control Flow. <a href="#control-flow">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#branching" title="">Branching.</a><ul>
<li><a href="#if-statement" title=""><code>if</code> statement.</a></li>
<li><a href="#if-expression" title=""><code>if</code> expression.</a></li>
<li><a href="#andor" title="">and/or.</a></li>
</ul>
</li>
<li><a href="#iterations" title="">Iterations.</a><ul>
<li><a href="#infinite-while" title="">Infinite <code>while</code>.</a></li>
<li><a href="#conditional-while" title="">Conditional <code>while</code>.</a></li>
<li><a href="#for-range" title=""><code>for</code> range.</a></li>
<li><a href="#for-each" title=""><code>for</code> each.</a></li>
<li><a href="#for-each-with-index" title=""><code>for</code> each with index.</a></li>
<li><a href="#exit-loop" title="">Exit loop.</a></li>
<li><a href="#next-iteration" title="">Next iteration.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#switch-matching" title=""><code>switch</code> matching.</a><ul>
<li><a href="#switch-assignment" title=""><code>switch</code> assignment.</a></li>
<li><a href="#switch-break" title=""><code>switch</code> break.</a></li>
</ul>
</li>
<li><a href="#trycatch" title="">Try/Catch.</a></li>
<li><a href="#deferred-execution" title="">Deferred Execution.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Cyber provides the common constructs to branch and enter loops.</p>
<h2 id="branching">Branching. <a href="#branching">#</a></h2>
<a href="#control-flow">^topic</a>
<h3 id="if-statement"><code>if</code> statement. <a href="#if-statement">#</a></h3>
<p>Use <code>if</code> and <code>else</code> statements to branch the execution of your code depending on conditions. The <code>else</code> clause can contain a condition which is only evaluated if the previous if or conditional else clause was <code>false</code>.</p>
<pre><code class="language-cy">var a = 10
if a == 10:
    print 'a is 10'
else a == 20:
    print 'a is 20'
else:
    print 'neither 10 nor 20'
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="if-expression"><code>if</code> expression. <a href="#if-expression">#</a></h3>
<p>An <code>if</code> expression evaluates a condition in parentheses and returns either the true value or false value.
Unlike the <code>if</code> statement, the <code>if</code> expression can not contain <code>else</code> conditional cases:</p>
<pre><code class="language-cy">var a = 10
var str = if (a == 10) 'red' else 'blue'
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="andor"><code>and</code>/<code>or</code> <a href="#andor">#</a></h3>
<p>Use <code>and</code> and <code>or</code> logical operators to combine conditions:</p>
<pre><code class="language-cy">var a = 10
if a > 5 and a < 15:
    print 'a is between 5 and 15'
if a == 20 or a == 10: 
    print 'a is 10 or 20'
</code></pre>
<a href="#control-flow">^topic</a>
<h2 id="iterations">Iterations. <a href="#iterations">#</a></h2>
<a href="#control-flow">^topic</a>
<h3 id="infinite-while">Infinite <code>while</code>. <a href="#infinite-while">#</a></h3>
<p>The <code>while</code> keyword starts an infinite loop which continues to run the code in the block until a <code>break</code> or <code>return</code> is reached.</p>
<pre><code class="language-cy">var count = 0
while:
    if count > 100:
        break
    count += 1
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="conditional-while">Conditional <code>while</code>. <a href="#conditional-while">#</a></h3>
<p>When the <code>while</code> clause contains a condition, the loop continues to run until the condition is evaluated to <code>false</code>:</p>
<pre><code class="language-cy">var running = true
var count = 0
while running:
    if count > 100:
        running = false
    count += 1
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="for-range"><code>for</code> range. <a href="#for-range">#</a></h3>
<p><code>for</code> loops can iterate over a range that starts at an <code>int</code> (inclusive) to a target <code>int</code> (exclusive).
The capture operator <code>-></code> is used to capture the loop's counter variable:</p>
<pre><code class="language-cy">for 0..4:
    performAction() 

for 0..100 -> i:
    print i    -- 0, 1, 2, ... , 99
</code></pre>
<p>To decrement the counter instead, use <code>-..</code>:</p>
<pre><code class="language-cy">for 100-..0 -> i:
    print i    -- 100, 99, 98, ... , 1
</code></pre>
<p>When the range operator <code>..</code> is replaced with <code>..=</code>, the target <code>int</code> is inclusive: <em>Planned Feature</em></p>
<pre><code class="language-cy">for 0..=100 -> i:
    print i    -- 0, 1, 2, ... , 100
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="for-each"><code>for</code> each. <a href="#for-each">#</a></h3>
<p>The <code>for</code> clause can iterate over any type that implements the <code>Iterable</code> trait. An Iterable contains an <code>iterator()</code> method which returns an <code>Iterator</code> object. The for loop continually invokes the Iterator's <code>next()</code> method until <code>none</code> is returned.</p>
<p>Lists can be iterated since they implement the Iterable trait. The capture operator <code>-></code> is used to capture the value returned from an iterator's <code>next()</code>:</p>
<pre><code class="language-cy">var list = {1, 2, 3, 4, 5}

for list -> n:
    print n
</code></pre>
<p>Maps can be iterated. <code>next()</code> returns a key and value tuple:</p>
<pre><code class="language-cy">var map = Map{a=123, b=234}

for map -> entry:
    print entry[0]
    print entry[1]
</code></pre>
<p>Use the destructure syntax to extract the key and value into two separate variables:</p>
<pre><code class="language-cy">for map -> {key, val}:
    print "key $(key) -> value $(val)"
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="for-each-with-index"><code>for</code> each with index. <a href="#for-each-with-index">#</a></h3>
<p>A counting index can be declared after the each variable. The count starts at 0 for the first value:</p>
<pre><code class="language-cy">var list = {1, 2, 3, 4, 5}

for list -> val, i:
    print "index $(i), value $(val)"
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="exit-loop">Exit loop. <a href="#exit-loop">#</a></h3>
<p>Use <code>break</code> to exit a loop. This loop stops printing once <code>i</code> reaches 4:</p>
<pre><code class="language-cy">for 0..10 -> i:
    if i == 4:
        break
    print i
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="next-iteration">Next iteration. <a href="#next-iteration">#</a></h3>
<p>Use <code>continue</code> to skip the rest of the loop and go to the next iteration.
This loop prints 0 through 9 but skips 4:</p>
<pre><code class="language-cy">for 0..10 -> i:
    if i == 4:
        continue
    print i
</code></pre>
<a href="#control-flow">^topic</a>
<h2 id="switch-matching"><code>switch</code> matching. <a href="#switch-matching">#</a></h2>
<p>The <code>switch</code> statement branches to a case block from a matching case condition. The expression that is matched against comes after switch statement. Multiple cases can be grouped together using a comma separator. An optional <code>else</code> fallback case is executed when no other cases were matched.
<em>Incomplete: Not all types can be used in the case conditions such as ranges.</em></p>
<pre><code class="language-cy">var val = 1000
switch val
case 0..100:
    print 'at or between 0 and 99'
case 100:
    print 'val is 100'
case 200:
    print 'val is 200'
case 300, 400:
    print 'combined case'
else:
    print "val is $(val)"
</code></pre>
<p>The switch statement requires at least one <code>case</code> block or an <code>else</code> block.
When the switch statement begins a new block, the case statements must be indented:</p>
<pre><code class="language-cy">switch val:
    case 0: print 'a'
    case 1: print 'b'
    else: print 'c'
</code></pre>
<a href="#control-flow">^topic</a>
<h3 id="switch-assignment"><code>switch</code> assignment. <a href="#switch-assignment">#</a></h3>
<p>Although <code>switch</code> can not be used freely as an expression, it can be assigned to a left variable or destination:</p>
<pre><code class="language-cy">var shu = switch pepper:
    case 'bell'     => 0
    case 'anaheim'  => 500
    case 'jalapeño' => 2000
    case 'serrano'  => 10000
</code></pre>
<p>When declaring an assignable switch, the cases must have a return value using the syntax <code>case {cond} => {expr}</code> or <code>else => {expr}</code>.</p>
<a href="#control-flow">^topic</a>
<h3 id="switch-break"><code>switch</code> break. <a href="#switch-break">#</a></h3>
<p>A <code>break</code> statement exits the current case block and resumes execution after the end of the switch statement: <em>Planned Feature</em></p>
<pre><code class="language-cy">switch value
case 0..5:
    print value
    if value == 3:
        break case
    print value    -- Skips second print if `value` is 3.
</code></pre>
<a href="#control-flow">^topic</a>
<h2 id="trycatch">Try/Catch. <a href="#trycatch">#</a></h2>
<p>The <code>try catch</code> statement, <code>try else</code> and <code>try</code> expressions provide a way to catch a throwing error and resume execution in a different branch. Learn more about <a href="#error-handling" title="">Error Handling</a>.</p>
<a href="#control-flow">^topic</a>
<h2 id="deferred-execution">Deferred Execution. <a href="#deferred-execution">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#control-flow">^topic</a>
<h1 id="functions">Functions. <a href="#functions">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#static-functions" title="">Static functions.</a></li>
<li><a href="#function-overloading" title="">Function overloading.</a></li>
<li><a href="#lambdas" title="">Lambdas.</a></li>
<li><a href="#closures" title="">Closures.</a></li>
<li><a href="#function-types" title="">Function types.</a></li>
<li><a href="#extern-functions" title=""><code>extern</code> functions.</a></li>
<li><a href="#parameter-groups" title="">Parameter groups.</a></li>
<li><a href="#named-parameters" title="">Named parameters.</a></li>
<li><a href="#variadic-parameters" title="">Variadic parameters.</a></li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#function-calls" title="">Function calls.</a><ul>
<li><a href="#shorthand-syntax" title="">Shorthand syntax.</a></li>
<li><a href="#call-block-syntax" title="">Call block syntax.</a></li>
<li><a href="#piping" title="">Piping.</a></li>
<li><a href="#compile-time-call" title="">Compile-time call.</a></li>
</ul>
</li>
<li><a href="#function-templates" title="">Function templates.</a><ul>
<li><a href="#explicit-template-call" title="">Explicit template call.</a></li>
<li><a href="#expand-function" title="">Expand function.</a></li>
<li><a href="#infer-param-type" title="">Infer param type.</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>In Cyber, there are first-class functions (or function values) and static functions.</p>
<h2 id="static-functions">Static functions. <a href="#static-functions">#</a></h2>
<p>Functions are declared with the <code>func</code> keyword and must have a name.</p>
<pre><code class="language-cy">use math

func dist(x0 float, y0 float, x1 float, y1 float) float:
    var dx = x0-x1
    var dy = y0-y1
    return math.sqrt(dx^2 + dy^2)
</code></pre>
<p>Functions can be invoked with arguments:</p>
<pre><code class="language-cy">print dist(0, 0, 10, 20)
</code></pre>
<p>Functions are initially static, but they can be passed around as a lambda or assigned to a variable:</p>
<pre><code class="language-cy">-- Assigning to a local variable.
var bar = dist

func squareDist(dist dyn, size float) float:
    return dist(0.0, 0.0, size, size)
    
-- Passing `dist` as an argument.
print squareDist(dist, 30.0)
</code></pre>
<p>Functions can only return one value. However, the value can be destructured: <em>Planned Feature</em></p>
<pre><code class="language-cy">use {cos, sin} 'math'

func compute(rad float) [2]float:
    return .{cos(rad), sin(rad)}

var {x, y} = compute(pi)
</code></pre>
<a href="#functions">^topic</a>
<h2 id="function-overloading">Function overloading. <a href="#function-overloading">#</a></h2>
<p>Functions can be overloaded by their type signature:</p>
<pre><code class="language-cy">func foo() int:
    return 2 + 2

func foo(n int) int:
    return 10 + n

func foo(n int, m int) int:
    return n * m

print foo()         --> 4
print foo(2)        --> 12
print foo(20, 5)    --> 100
</code></pre>
<a href="#functions">^topic</a>
<h2 id="lambdas">Lambdas. <a href="#lambdas">#</a></h2>
<p>Lambdas or function values can be assigned to variables or passed as arguments into other constructs.</p>
<p>When a lambda only returns an expression, it can be declared with a simplified syntax.</p>
<pre><code class="language-cy">-- Passing simple lambda as an argument.
foo(word => toUpper(word))

-- A simple lambda with multiple arguments.
foo((word, prefix) => prefix + toUpper(word))

-- Assigning a simple lambda.
canvas.onUpdate = delta_ms => print delta_ms
</code></pre>
<p>Lambdas that need a block of statements can be declared with the <code>func</code> keyword without a name.</p>
<pre><code class="language-cy">-- Assigning lambda block to a variable.
var add = func (a int, b int) int:
    return a + b

-- Passing a lambda block as an argument.
canvas.onUpdate():
    ..func (delta_ms):
        print delta_ms
</code></pre>
<p>Passing a lambda block as a call argument is only possible in a call block. <em>Planned Feature</em> See <a href="#function-calls" title="">Function calls</a>.</p>
<a href="#functions">^topic</a>
<h2 id="closures">Closures. <a href="#closures">#</a></h2>
<p>Lambdas can capture local variables from parent blocks. This example shows the lambda <code>f</code> capturing <code>a</code> from the main scope: <em>Incomplete, only variables one parent block away can be captured.</em></p>
<pre><code class="language-cy">var a = 1
var f = func() int:
    return a + 2
print f()         --> 3
</code></pre>
<p>The following lambda expression captures <code>a</code> from the function <code>add</code>:</p>
<pre><code class="language-cy">func add():
    var a = 123
    return b => a + b
var addTo = add()
print addTo(10)   --> 133
</code></pre>
<p>Like static variables, static functions can not reference local variables outside of their scope:</p>
<pre><code class="language-cy">var a = 1
func foo():
    print a       --> CompileError: Undeclared variable `a`.
</code></pre>
<a href="#functions">^topic</a>
<h2 id="extern-functions"><code>extern</code> functions. <a href="#extern-functions">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#functions">^topic</a>
<h2 id="function-types">Function types. <a href="#function-types">#</a></h2>
<p>A function type is denoted as <code>func(P1, P2, ...) R</code> where <code>P</code>s are parameter types and <code>R</code> is the return type in addition to any function modifiers:</p>
<pre><code class="language-cy">type AddFn -> func(int, int) int
</code></pre>
<p>Function types can include optional parameter names:</p>
<pre><code class="language-cy">type AddFn -> func(a int, b int) int
</code></pre>
<p>If one parameter has a name, the other parameters must also have names.
Parameter names do not alter the function signature and only serve to document the function type.</p>
<p>Only static functions can be assigned to a function type:</p>
<pre><code class="language-cy">func add(a int, b int) int:
    return a + b

var fn AddFn = add
fn(10, 20)         --> 30
</code></pre>
<p>Similarily, a function union type is denoted as <code>Func(P1, P2, ...) R</code> and can store static functions, lambdas, and closures:</p>
<pre><code class="language-cy">var c = 5
func addClosure(a int, b int) int:
    return a + b + c

var fn Func(int, int) int = add
fn(10, 20)         --> 30
fn = addClosure 
fn(10, 20)         --> 35
</code></pre>
<p>Function types declared in template parameters represent <strong>function symbol</strong> types.
A function symbol can only be used at compile-time. It can be expanded to a runtime function:</p>
<pre><code class="language-cy">type IntMap[K type, HASH func(K) int]
    ints [*]int

    -- Probing omitted.
    func get(self, key K) int:
        var slot = HASH(key) % self.ints.len
        return self.ints[slot]

func my_str_hash(s String) int:
    return s.len()

var m = IntMap[String, my_str_hash]{}
</code></pre>
<a href="#functions">^topic</a>
<h2 id="parameter-groups">Parameter groups. <a href="#parameter-groups">#</a></h2>
<p>When multiple parameters share the same type they can be declared together in a sequence:</p>
<pre><code class="language-cy">func sum(a, b, c int) int
    return a + b + c
</code></pre>
<a href="#functions">^topic</a>
<h2 id="named-parameters">Named parameters. <a href="#named-parameters">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#functions">^topic</a>
<h2 id="variadic-parameters">Variadic parameters. <a href="#variadic-parameters">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#functions">^topic</a>
<h2 id="function-calls">Function calls. <a href="#function-calls">#</a></h2>
<p>The straightforward way to call a function is to use parentheses.</p>
<pre><code class="language-cy">var d = dist(100, 100, 200, 200)
</code></pre>
<p>You can call functions with named parameters.</p>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><pre><code class="language-cy">var d = dist(x0=10, x1=20, y0=30, y1=40)
</code></pre>
<a href="#functions">^topic</a>
<h3 id="shorthand-syntax">Shorthand syntax. <a href="#shorthand-syntax">#</a></h3>
<p>Functions can be invoked without parentheses. This only works for calls that take at least one argument. Named arguments are not allowed and nested function calls must use parentheses:</p>
<pre><code class="language-cy">-- Calls the function `dist`.
var d = dist 100, 100, 200, 200

func foo():       
    return 4

var r = foo       -- Returns the function itself as a value.
                     -- Does not call the function `random`.
r = foo()         -- Calls the function `random`.
</code></pre>
<a href="#functions">^topic</a>
<h3 id="call-block-syntax">Call block syntax. <a href="#call-block-syntax">#</a></h3>
<p>The call block appends a lambda to a call expression's last argument:</p>
<pre><code class="language-cy">func Button(name String, size int, on_click func() void) ButtonConfig:
    return .{
        name = name,
        size = size,
        on_click = on_click,
    }

Button('Count', 10, ():
    print 'on click'
</code></pre>
<a href="#functions">^topic</a>
<h3 id="piping">Piping. <a href="#piping">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#functions">^topic</a>
<h3 id="compile-time-call">Compile-time call. <a href="#compile-time-call">#</a></h3>
<p>Any function can be invoked at compile-time using <code>#</code> before the arguments:</p>
<pre><code class="language-cy">func fib(n int) int:
    if n < 2:
        return n
    return fib(n - 1) + fib(n - 2)

var res = fib#(30)
print res         --> 832040
</code></pre>
<p>The result of the function call is used instead of emitting a runtime function call.
The call arguments must be compile-time compatible values.</p>
<p>There is no need for <code>#</code> if the caller is already in a compile-time context: <em>Compile-time if is planned.</em></p>
<pre><code class="language-cy">#if fib(30) == 832040:
    print 'Correct result.'
</code></pre>
<a href="#functions">^topic</a>
<h2 id="function-templates">Function templates. <a href="#function-templates">#</a></h2>
<p>Function declarations can include template parameters to create a function template:</p>
<pre><code class="language-cy">func add[T](T type, a T, b T) T:
    return a + b
</code></pre>
<p>Only the template parameter names are declared.
Their types are then inferred from the function signature.</p>
<a href="#functions">^topic</a>
<h3 id="explicit-template-call">Explicit template call. <a href="#explicit-template-call">#</a></h3>
<p>When the function is invoked with template argument(s), a new runtime function is generated and used:</p>
<pre><code class="language-cy">print add(int, 1, 2)    --> 3
print add(float, 1, 2)  --> 3.0
</code></pre>
<p>Note that invoking the function again with the same template argument(s) uses the same generated function. In other words, the generated function is always memoized from the template arguments.</p>
<a href="#functions">^topic</a>
<h3 id="expand-function">Expand function. <a href="#expand-function">#</a></h3>
<p>The function template can be explicitly expanded to a runtime function:</p>
<pre><code class="language-cy">var addInt = add[int]
print addInt(1, 2)      --> 3
</code></pre>
<a href="#functions">^topic</a>
<h3 id="infer-param-type">Infer param type. <a href="#infer-param-type">#</a></h3>
<p>When a template parameter is first encountered in a function parameter's type specifier, it's inferred from the argument's type:</p>
<pre><code class="language-cy">func add[T](a T, b T) T:
    return a + b

print add(1, 2)         --> 3
print add(1.0, 2.0)     --> 3.0
</code></pre>
<p>In the above example, <code>add[int]</code> and <code>add[float]</code> were inferred from the function calls:</p>
<p>Nested template parameters can also be inferred:</p>
<pre><code class="language-cy">func set[K, V](m Map[K, V], key K, val V):
    m.set(key, val)
</code></pre>
<a href="#functions">^topic</a>
<h1 id="modules">Modules. <a href="#modules">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#importing" title="">Importing.</a><ul>
<li><a href="#import-file" title="">Import file.</a></li>
<li><a href="#import-url" title="">Import URL.</a></li>
<li><a href="#import-all" title="">Import all.</a></li>
<li><a href="#main-module" title="">Main module.</a></li>
<li><a href="#circular-imports" title="">Circular imports.</a></li>
<li><a href="#destructure-import" title="">Destructure import.</a></li>
</ul>
</li>
<li><a href="#exporting" title="">Exporting.</a></li>
<li><a href="#module-uri" title="">Module URI.</a></li>
<li><a href="#symbol-visibility" title="">Symbol visibility.</a></li>
<li><a href="#symbol-alias" title="">Symbol alias.</a></li>
<li><a href="#builtin-modules" title="">Builtin modules.</a></li>
<li><a href="#mod-core" title=""><code>mod core</code></a><ul>
<li><a href="#type-bool" title=""><code>type bool</code></a></li>
<li><a href="#type-error" title=""><code>type error</code></a></li>
<li><a href="#type-int" title=""><code>type int</code></a></li>
<li><a href="#type-float" title=""><code>type float</code></a></li>
<li><a href="#type-list" title=""><code>type List</code></a></li>
<li><a href="#type-listiterator" title=""><code>type ListIterator</code></a></li>
<li><a href="#type-tuple" title=""><code>type Tuple</code></a></li>
<li><a href="#type-table" title=""><code>type Table</code></a></li>
<li><a href="#type-map" title=""><code>type Map</code></a></li>
<li><a href="#type-mapiterator" title=""><code>type MapIterator</code></a></li>
<li><a href="#type-string" title=""><code>type String</code></a></li>
<li><a href="#type-array" title=""><code>type Array</code></a></li>
<li><a href="#type-arrayiterator" title=""><code>type ArrayIterator</code></a></li>
<li><a href="#type-pointer" title=""><code>type pointer</code></a></li>
<li><a href="#type-fiber" title=""><code>type Fiber</code></a></li>
<li><a href="#type-metatype" title=""><code>type metatype</code></a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#mod-cy" title=""><code>mod cy</code></a></li>
<li><a href="#mod-math" title=""><code>mod math</code></a></li>
<li><a href="#std-modules" title="">Std modules.</a></li>
<li><a href="#mod-cli" title=""><code>mod cli</code></a></li>
<li><a href="#mod-os" title=""><code>mod os</code></a><ul>
<li><a href="#type-file" title=""><code>type File</code></a></li>
<li><a href="#type-dir" title=""><code>type Dir</code></a></li>
<li><a href="#type-diriterator" title=""><code>type DirIterator</code></a></li>
<li><a href="#type-ffi" title=""><code>type FFI</code></a></li>
<li><a href="#type-carray" title=""><code>type CArray</code></a></li>
<li><a href="#type-cdimarray" title=""><code>type CDimArray</code></a></li>
<li><a href="#map-direntry" title=""><code>Map DirEntry</code></a></li>
<li><a href="#map-dirwalkentry" title=""><code>Map DirWalkEntry</code></a></li>
<li><a href="#table-argoption" title=""><code>Table ArgOption</code></a></li>
</ul>
</li>
<li><a href="#mod-test" title=""><code>mod test</code></a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Modules have their own namespace and contain accessible static symbols. By default, importing another Cyber script returns a module with its declared symbols.</p>
<h2 id="importing">Importing. <a href="#importing">#</a></h2>
<p>When a <code>use</code> declaration contains only a single identifier, it creates a local alias to a module using the identifier as the module specifier. Cyber's CLI comes with some builtin modules like <code>math</code> and <code>test</code>.</p>
<pre><code class="language-cy">use test
test.eq(123, 123)

use math
print math.cos(0)
</code></pre>
<p>The explicit import syntax requires an alias name followed by a module specifier as a raw string:</p>
<pre><code class="language-cy">use m 'math'
print m.random()
</code></pre>
<p>When Cyber is embedded into a host application, the module resolver and loader can be overridden using <a href="#libcyber" title="">libcyber</a>.</p>
<a href="#modules">^topic</a>
<h3 id="import-file">Import file. <a href="#import-file">#</a></h3>
<p>File modules can be imported:</p>
<pre><code class="language-cy">-- Importing a module from the local directory.
use b 'bar.cy'
print b.myFunc()
print b.myVar
</code></pre>
<a href="#modules">^topic</a>
<h3 id="import-url">Import URL. <a href="#import-url">#</a></h3>
<p>Modules can be imported over the Internet:</p>
<pre><code class="language-cy">-- Importing a module from a CDN.
use rl 'https://mycdn.com/raylib'
</code></pre>
<p>When importing using a URL without a file name, Cyber's CLI will look for a <code>mod.cy</code> from the path instead.</p>
<a href="#modules">^topic</a>
<h3 id="import-all">Import all. <a href="#import-all">#</a></h3>
<p>If the alias name is the wildcard character, all symbols from the module are imported into the using namespace: <em>This feature is experimental and may be removed in a future version.</em></p>
<pre><code class="language-cy">use * 'math'
print random()
</code></pre>
<a href="#modules">^topic</a>
<h3 id="main-module">Main module. <a href="#main-module">#</a></h3>
<p>Only the main module can have top-level statements that aren't static declarations.
An imported module containing top-level statements returns an error:</p>
<pre><code class="language-cy">-- main.cy
use a 'foo.cy'
print a.foo

-- foo.cy
use 'bar.cy'
var .foo = 123
print foo         -- Error: Top-level statement not allowed.
</code></pre>
<a href="#modules">^topic</a>
<h3 id="circular-imports">Circular imports. <a href="#circular-imports">#</a></h3>
<p>Circular imports are allowed. In the following example, <code>main.cy</code> and <code>foo.cy</code> import each other without any problems.</p>
<pre><code class="language-cy">-- main.cy
use foo 'foo.cy'

func printB():
    foo.printC()

foo.printA()

-- foo.cy
use main 'main.cy'

func printA():
    main.printB()

func printC():
    print 'done'
</code></pre>
<p>Static variable declarations from imports can have circular references. Read more about this in <a href="#static-variables" title="">Static variables</a>.</p>
<a href="#modules">^topic</a>
<h3 id="destructure-import">Destructure import. <a href="#destructure-import">#</a></h3>
<p>Modules can also be destructured using the following syntax:</p>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><pre><code class="language-cy">use { cos, pi } 'math'
print cos(pi)
</code></pre>
<a href="#modules">^topic</a>
<h2 id="exporting">Exporting. <a href="#exporting">#</a></h2>
<p>All symbols are exported when the script's module is loaded. However, symbols can be declared with a <a href="#symbol-visibility" title="">hidden</a> modifier.</p>
<pre><code class="language-cy">func foo():         -- Exported static function.
    print 123

var .bar = 234      -- Exported static variable.

type Thing:  -- Exported type.
    var a float
</code></pre>
<a href="#modules">^topic</a>
<h2 id="module-uri">Module URI. <a href="#module-uri">#</a></h2>
<p>To get the absolute path of the current module, reference the compile-time constant <code>#modUri</code>.
This can be used with <code>os.dirName</code> to get the current module directory.</p>
<pre><code class="language-cy">print #modUri              -- Prints '/some/path/foo.cy'

use os
print os.dirName(#modUri)  -- Prints '/some/path'
</code></pre>
<a href="#modules">^topic</a>
<h2 id="symbol-visibility">Symbol visibility. <a href="#symbol-visibility">#</a></h2>
<p>All symbols have public visibility. However, when a symbol is declared with a <code>-</code> prefix, it suggests that it should not be made available to an editor's autocomplete:</p>
<pre><code class="language-cy">-type Foo:
    a int
    b int

-func add(a int, b int) int:
    return a + b
</code></pre>
<p>Furthermore, the symbol is excluded when its module is included using <code>use *</code>.</p>
<a href="#modules">^topic</a>
<h2 id="symbol-alias">Symbol alias. <a href="#symbol-alias">#</a></h2>
<p><code>use</code> can be used to create an alias to another symbol:</p>
<pre><code class="language-cy">use eng 'lib/engine.cy'
use Vec2 -> eng.Vector2
</code></pre>
<a href="#modules">^topic</a>
<h2 id="builtin-modules">Builtin modules. <a href="#builtin-modules">#</a></h2>
<p>Builtin modules are the bare minimum that comes with Cyber. The <a href="#embedding" title="">embeddable library</a> contains these modules and nothing more. They include:</p>
<ul>
<li><a href="#mod-core" title="">core</a>: Commonly used utilities.</li>
<li><a href="#mod-cy" title="">cy</a>: Cyber related functions.</li>
<li><a href="#mod-math" title="">math</a>: Math constants and functions.</li>
</ul>
<a href="#modules">^topic</a>
<h2 id="mod-core"><code>mod core</code> <a href="#mod-core">#</a></h2>
<p>The <code>core</code> module contains functions related to Cyber and common utilities. It is automatically imported into each script's namespace.</p>
<p>Sample usage:</p>
<pre><code class="language-cy">-- `print` and `typeof` are available without imports.
print 'hello'
print typeof('my str').id()
</code></pre>
<p><a href="#modules" title="">^topic</a></p>
<!-- core.start -->
<blockquote><p><code>func allTypes() List[type]</code></p>
</blockquote><blockquote><p><code>func bitcast(D type, val S) D</code></p>
</blockquote><blockquote><p><code>func copy(val T) T</code></p>
<p>Copies a primitive value or creates a shallow copy of an object value.</p>
</blockquote><blockquote><p><code>func choicetag(choice T) T.Tag</code></p>
<p>Returns the tag of a choice.  TODO: This will be moved to <code>T.tag()</code>.</p>
</blockquote><blockquote><p><code>func dump(val any) void</code></p>
<p>Dumps a detailed description of a value.</p>
</blockquote><blockquote><p><code>func eprint(str any) void</code></p>
<p>Prints a value to the error stream. The host determines how it is printed.</p>
</blockquote><blockquote><p><code>func errorReport() String</code></p>
</blockquote><blockquote><p><code>func getObjectRc(val any) int</code></p>
<p>Returns the current reference count of an object.</p>
</blockquote><blockquote><p><code>func is(a any, b any) bool</code></p>
<p>Returns whether two values refer to the same instance.</p>
</blockquote><blockquote><p><code>func isAlpha(val int) bool</code></p>
<p>Returns whether a rune is an alphabetic letter.</p>
</blockquote><blockquote><p><code>func isDigit(val int) bool</code></p>
<p>Returns whether a rune is a digit.</p>
</blockquote><blockquote><p><code>func isNone(val any) bool</code></p>
<p>Returns whether a boxed value is the <code>none</code> case of a generic <code>Option(T)</code> type.  This is temporary and may be removed in a future release.</p>
</blockquote><blockquote><p><code>func must(val any) any</code></p>
<p>If <code>val</code> is an error, <code>panic(val)</code> is invoked. Otherwise, <code>val</code> is returned.</p>
</blockquote><blockquote><p><code>func panic(err any) dyn</code></p>
<p>Stop execution in the current fiber and starts unwinding the call stack. See <a href="#unexpected-errors" title="">Unexpected Errors</a>.</p>
</blockquote><blockquote><p><code>func performGC() Map</code></p>
<p>Runs the garbage collector once to detect reference cycles and abandoned objects.  Returns the statistics of the run in a map value.</p>
</blockquote><blockquote><p><code>func ptrcast(D type, val S) *D</code></p>
</blockquote><blockquote><p><code>func print(str any) void</code></p>
<p>Prints a value. The host determines how it is printed.</p>
</blockquote><blockquote><p><code>func queueTask(fn <func_type>) void</code></p>
<p>Queues a callback function as an async task.</p>
</blockquote><blockquote><p><code>func refcast(T type, ptr *T) <ref></code></p>
</blockquote><blockquote><p><code>func runestr(val int) String</code></p>
<p>Converts a rune to a string.</p>
</blockquote><blockquote><p><code>func sizeof(T type) int</code></p>
</blockquote><blockquote><p><code>func sizeof_(type_id int) int</code></p>
</blockquote><blockquote><p><code>func typeOf(t ExprType) type</code></p>
<p>Returns the type of an expression.</p>
</blockquote><blockquote><p><code>func typeInfo(T type) TypeInfo</code></p>
<p>Returns info about a type.</p>
</blockquote><blockquote><p><code>func typeid(T type) int</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-void"><code>type void</code> <a href="#type-void">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-bool"><code>type bool</code> <a href="#type-bool">#</a></h3>
<blockquote><p><code>func bool.$call(val any) bool</code></p>
<p>Converts any value to either <code>true</code> or <code>false</code>.  Integers and floats equal to 0 return false.  Empty strings return false.  Otherwise, returns true.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-symbol"><code>type symbol</code> <a href="#type-symbol">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-error"><code>type error</code> <a href="#type-error">#</a></h3>
<blockquote><p><code>func sym(self) symbol</code></p>
<p>Return the underlying <code>symbol</code>.</p>
</blockquote><blockquote><p><code>func error.$call(val any) error</code></p>
<p>Create an error from symbol.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-byte"><code>type byte</code> <a href="#type-byte">#</a></h3>
<blockquote><p><code>func $prefix~(self) byte</code></p>
</blockquote><blockquote><p><code>func $infix<(self, o byte) bool</code></p>
</blockquote><blockquote><p><code>func $infix<=(self, o byte) bool</code></p>
</blockquote><blockquote><p><code>func $infix>(self, o byte) bool</code></p>
</blockquote><blockquote><p><code>func $infix>=(self, o byte) bool</code></p>
</blockquote><blockquote><p><code>func $infix+(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix-(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix*(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix/(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix%(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix^(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix&(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix|(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix||(self, o byte) byte</code></p>
</blockquote><blockquote><p><code>func $infix<<(self, o int) byte</code></p>
</blockquote><blockquote><p><code>func $infix>>(self, o int) byte</code></p>
</blockquote><blockquote><p><code>func fmt(self, format NumberFormat) String</code></p>
<p>Formats the byte using a NumberFormat.</p>
</blockquote><blockquote><p><code>func fmt(self, format NumberFormat, config Table) String</code></p>
<p><code>opts.pad</code> provides the ASCII rune that is used for padding with a string length of <code>config.width</code>.</p>
</blockquote><blockquote><p><code>func $call(b byte) byte</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-int"><code>type int</code> <a href="#type-int">#</a></h3>
<blockquote><p><code>func $prefix~(self) int</code></p>
</blockquote><blockquote><p><code>func $prefix-(self) int</code></p>
</blockquote><blockquote><p><code>func $infix<(self, o int) bool</code></p>
</blockquote><blockquote><p><code>func $infix<=(self, o int) bool</code></p>
</blockquote><blockquote><p><code>func $infix>(self, o int) bool</code></p>
</blockquote><blockquote><p><code>func $infix>=(self, o int) bool</code></p>
</blockquote><blockquote><p><code>func $infix+(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix-(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix*(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix/(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix%(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix^(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix&(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix|(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix||(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix<<(self, o int) int</code></p>
</blockquote><blockquote><p><code>func $infix>>(self, o int) int</code></p>
</blockquote><blockquote><p><code>func fmt(self, format NumberFormat) String</code></p>
<p>Formats the integer using a NumberFormat.</p>
</blockquote><blockquote><p><code>func fmt(self, format NumberFormat, config Table) String</code></p>
<p><code>opts.pad</code> provides the ASCII rune that is used for padding with a string length of <code>config.width</code>.</p>
</blockquote><blockquote><p><code>func int.$call(val any) int</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-float"><code>type float</code> <a href="#type-float">#</a></h3>
<blockquote><p><code>func $prefix-(self) float</code></p>
</blockquote><blockquote><p><code>func $infix<(self, o float) bool</code></p>
</blockquote><blockquote><p><code>func $infix<=(self, o float) bool</code></p>
</blockquote><blockquote><p><code>func $infix>(self, o float) bool</code></p>
</blockquote><blockquote><p><code>func $infix>=(self, o float) bool</code></p>
</blockquote><blockquote><p><code>func $infix+(self, o float) float</code></p>
</blockquote><blockquote><p><code>func $infix-(self, o float) float</code></p>
</blockquote><blockquote><p><code>func $infix*(self, o float) float</code></p>
</blockquote><blockquote><p><code>func $infix/(self, o float) float</code></p>
</blockquote><blockquote><p><code>func $infix%(self, o float) float</code></p>
</blockquote><blockquote><p><code>func $infix^(self, o float) float</code></p>
</blockquote><blockquote><p><code>func float.$call(val any) float</code></p>
<p>Converts the value to a <code>float</code>. Panics if type conversion fails.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-placeholder2"><code>type placeholder2</code> <a href="#type-placeholder2">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-placeholder3"><code>type placeholder3</code> <a href="#type-placeholder3">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-taglit"><code>type taglit</code> <a href="#type-taglit">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-dyn"><code>type dyn</code> <a href="#type-dyn">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-any"><code>type any</code> <a href="#type-any">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-type"><code>type type</code> <a href="#type-type">#</a></h3>
<blockquote><p><code>func id(self) int</code></p>
<p>Returns a unique ID for this type.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-intinfo"><code>type IntInfo</code> <a href="#type-intinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-floatinfo"><code>type FloatInfo</code> <a href="#type-floatinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-hostobjectinfo"><code>type HostObjectInfo</code> <a href="#type-hostobjectinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-objectinfo"><code>type ObjectInfo</code> <a href="#type-objectinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-objectfield"><code>type ObjectField</code> <a href="#type-objectfield">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-enuminfo"><code>type EnumInfo</code> <a href="#type-enuminfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-enumcase"><code>type EnumCase</code> <a href="#type-enumcase">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-choiceinfo"><code>type ChoiceInfo</code> <a href="#type-choiceinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-choicecase"><code>type ChoiceCase</code> <a href="#type-choicecase">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-funcinfo"><code>type FuncInfo</code> <a href="#type-funcinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-funcparam"><code>type FuncParam</code> <a href="#type-funcparam">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-arrayinfo"><code>type ArrayInfo</code> <a href="#type-arrayinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-structinfo"><code>type StructInfo</code> <a href="#type-structinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-structfield"><code>type StructField</code> <a href="#type-structfield">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-traitinfo"><code>type TraitInfo</code> <a href="#type-traitinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-pointerinfo"><code>type PointerInfo</code> <a href="#type-pointerinfo">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-optioninfo"><code>type OptionInfo</code> <a href="#type-optioninfo">#</a></h3>
<blockquote><p><code>func type.$call(val any) type</code></p>
<p>Return the type of a value.  See <code>typeof</code> to obtain the type of an expression at compile-time.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-list"><code>type List</code> <a href="#type-list">#</a></h3>
<blockquote><p><code>func $index(self, idx int) T</code></p>
</blockquote><blockquote><p><code>func $index(self, range Range) List[T]</code></p>
</blockquote><blockquote><p><code>func $setIndex(self, idx int, val T) void</code></p>
</blockquote><blockquote><p><code>func append(self, val T) void</code></p>
<p>Appends a value to the end of the list.</p>
</blockquote><blockquote><p><code>func appendAll(self, list List[T]) void</code></p>
<p>Appends the elements of another list to the end of this list.</p>
</blockquote><blockquote><p><code>func insert(self, idx int, val T) void</code></p>
<p>Inserts a value at index <code>idx</code>.</p>
</blockquote><blockquote><p><code>func iterator(self) ListIterator[T]</code></p>
<p>Returns a new iterator over the list elements.</p>
</blockquote><blockquote><p><code>func join(self, sep String) String</code></p>
<p>Returns a new string that joins the elements with <code>separator</code>.</p>
</blockquote><blockquote><p><code>func len(self) int</code></p>
<p>Returns the number of elements in the list.</p>
</blockquote><blockquote><p><code>func remove(self, idx int) void</code></p>
<p>Removes an element at index <code>idx</code>.</p>
</blockquote><blockquote><p><code>func resize(self, size int) void</code></p>
<p>Resizes the list to <code>len</code> elements. If the new size is bigger, <code>none</code> values  are appended to the list. If the new size is smaller, elements at the end of the list are removed.</p>
</blockquote><blockquote><p><code>func resize_(self, elem_t int, size int) void</code></p>
</blockquote><blockquote><p><code>func sort(self, lessFn <func_type>) void</code></p>
<p>Sorts the list with the given <code>less</code> function.  If element <code>a</code> should be ordered before <code>b</code>, the function should return <code>true</code> otherwise <code>false</code>.</p>
</blockquote><blockquote><p><code>func List.fill(val T, n int) List[T]</code></p>
<p>Creates a list with initial capacity of <code>n</code> and values set to <code>val</code>.  If the value is an object, it is shallow copied <code>n</code> times.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-listiterator"><code>type ListIterator</code> <a href="#type-listiterator">#</a></h3>
<blockquote><p><code>func next(self) ?T</code></p>
</blockquote><blockquote><p><code>func next_(self, ret_t int) ?T</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-tuple"><code>type Tuple</code> <a href="#type-tuple">#</a></h3>
<blockquote><p><code>func $index(self, idx int) any</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-funcsig"><code>type FuncSig</code> <a href="#type-funcsig">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-funcptr_t"><code>type funcptr_t</code> <a href="#type-funcptr_t">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-funcunion_t"><code>type funcunion_t</code> <a href="#type-funcunion_t">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-func"><code>type Func</code> <a href="#type-func">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-funcsym_t"><code>type funcsym_t</code> <a href="#type-funcsym_t">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-table"><code>type Table</code> <a href="#type-table">#</a></h3>
<blockquote><p><code>func $initPair(self, key String, value any) void</code></p>
</blockquote><blockquote><p><code>func $get(self, name String) dyn</code></p>
</blockquote><blockquote><p><code>func $set(self, name String, value any) </code></p>
</blockquote><blockquote><p><code>func $index(self, key any) dyn</code></p>
</blockquote><blockquote><p><code>func $setIndex(self, key any, value any) void</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-map"><code>type Map</code> <a href="#type-map">#</a></h3>
<blockquote><p><code>func $initPair(self, key any, value any) void</code></p>
</blockquote><blockquote><p><code>func $index(self, key any) dyn</code></p>
</blockquote><blockquote><p><code>func $setIndex(self, key any, val any) void</code></p>
</blockquote><blockquote><p><code>func contains(self, key any) bool</code></p>
<p>Returns whether there is a value mapped to <code>key</code>.</p>
</blockquote><blockquote><p><code>func get(self, key any) ?any</code></p>
<p>Returns value mapped to <code>key</code> or returns <code>none</code>.</p>
</blockquote><blockquote><p><code>func remove(self, key any) bool</code></p>
<p>Removes the element with the given key <code>key</code>.</p>
</blockquote><blockquote><p><code>func size(self) int</code></p>
<p>Returns the number of key-value pairs in the map.</p>
</blockquote><blockquote><p><code>func iterator(self) MapIterator</code></p>
<p>Returns a new iterator over the map elements.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-mapiterator"><code>type MapIterator</code> <a href="#type-mapiterator">#</a></h3>
<blockquote><p><code>func next(self) ?any</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-string"><code>type String</code> <a href="#type-string">#</a></h3>
<blockquote><p><code>func $index(self, idx int) int</code></p>
<p>Returns the rune at byte index <code>idx</code>. The replacement character (0xFFFD) is returned for an invalid UTF-8 rune.</p>
</blockquote><blockquote><p><code>func $index(self, range Range) String</code></p>
<p>Returns a slice into this string from a <code>Range</code> with <code>start</code> (inclusive) to <code>end</code> (exclusive) byte indexes.</p>
</blockquote><blockquote><p><code>func $infix+(self, o any) String</code></p>
<p>Returns a new string that concats this string and <code>str</code>.</p>
</blockquote><blockquote><p><code>func concat(self, o String) String</code></p>
<p>Returns a new string that concats this string and <code>str</code>.</p>
</blockquote><blockquote><p><code>func count(self) int</code></p>
<p>Returns the number of runes in the string.</p>
</blockquote><blockquote><p><code>func endsWith(self, suffix String) bool</code></p>
<p>Returns whether the string ends with <code>suffix</code>.</p>
</blockquote><blockquote><p><code>func find(self, needle String) ?int</code></p>
<p>Returns the first byte index of substring <code>needle</code> in the string or <code>none</code> if not found. SIMD enabled.</p>
</blockquote><blockquote><p><code>func findAnyByte(self, set List[byte]) ?int</code></p>
<p>Returns the first index of any byte in <code>set</code> or <code>none</code> if not found.</p>
</blockquote><blockquote><p><code>func findAnyRune(self, runes List[int]) ?int</code></p>
<p>Returns the first byte index of any rune in <code>runes</code> or <code>none</code> if not found. SIMD enabled.</p>
</blockquote><blockquote><p><code>func findByte(self, b byte) ?int</code></p>
<p>Returns the first index of <code>byte</code> in the array or <code>none</code> if not found.</p>
</blockquote><blockquote><p><code>func findRune(self, rune int) ?int</code></p>
<p>Returns the first byte index of a rune <code>needle</code> in the string or <code>none</code> if not found. SIMD enabled.</p>
</blockquote><blockquote><p><code>func fmtBytes(self, format NumberFormat) String</code></p>
<p>Formats each byte in the string using a NumberFormat.  Each byte is zero padded.</p>
</blockquote><blockquote><p><code>func getByte(self, idx int) byte</code></p>
<p>Returns the byte value (0-255) at the given index <code>idx</code>.</p>
</blockquote><blockquote><p><code>func getInt(self, idx int, endian symbol) int</code></p>
<p>Returns the int value of the 6 bytes starting from <code>idx</code> with the given endianness (.little or .big).</p>
</blockquote><blockquote><p><code>func getInt32(self, idx int, endian symbol) int</code></p>
<p>Returns the int value of the 4 bytes starting from <code>idx</code> with the given endianness (.little or .big).</p>
</blockquote><blockquote><p><code>func insert(self, idx int, str String) String</code></p>
<p>Returns a new string with <code>str</code> inserted at byte index <code>idx</code>.</p>
</blockquote><blockquote><p><code>func insertByte(self, idx int, byte int) String</code></p>
<p>Returns a new array with <code>byte</code> inserted at index <code>idx</code>.</p>
</blockquote><blockquote><p><code>func isAscii(self) bool</code></p>
<p>Returns whether the string contains all ASCII runes.</p>
</blockquote><blockquote><p><code>func len(self) int</code></p>
<p>Returns the byte length of the string. See <code>count()</code> to obtain the number of runes.</p>
</blockquote><blockquote><p><code>func less(self, other String) bool</code></p>
<p>Returns whether this string is lexicographically before <code>other</code>.</p>
</blockquote><blockquote><p><code>func lower(self) String</code></p>
<p>Returns this string in lowercase.</p>
</blockquote><blockquote><p><code>func replace(self, needle String, replacement String) String</code></p>
<p>Returns a new string with all occurrences of <code>needle</code> replaced with <code>replacement</code>.</p>
</blockquote><blockquote><p><code>func repeat(self, n int) String</code></p>
<p>Returns a new string with this string repeated <code>n</code> times.</p>
</blockquote><blockquote><p><code>func seek(self, idx int) int</code></p>
<p>Returns the starting byte index for the rune index <code>idx</code>.</p>
</blockquote><blockquote><p><code>func sliceAt(self, idx int) String</code></p>
<p>Returns the UTF-8 rune starting at byte index <code>idx</code> as a string.</p>
</blockquote><blockquote><p><code>func split(self, sep String) List[String]</code></p>
<p>Returns a list of UTF-8 strings split at occurrences of <code>sep</code>.</p>
</blockquote><blockquote><p><code>func startsWith(self, prefix String) bool</code></p>
<p>Returns whether the string starts with <code>prefix</code>.</p>
</blockquote><blockquote><p><code>func trim(self, mode symbol, delims String) String</code></p>
<p>Returns the string with ends trimmed from runes in <code>delims</code>. <code>mode</code> can be .left, .right, or .ends.</p>
</blockquote><blockquote><p><code>func upper(self) String</code></p>
<p>Returns this string in uppercase.</p>
</blockquote><blockquote><p><code>func String.$call(val any) String</code></p>
<p>Converts a value to a string.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-array_t"><code>type array_t</code> <a href="#type-array_t">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-array"><code>type Array</code> <a href="#type-array">#</a></h3>
<blockquote><p><code>func $index(self, idx int) <ref></code></p>
</blockquote><blockquote><p><code>func iterator(self) RefSliceIterator[T]</code></p>
<p>Returns a new iterator over the array.</p>
</blockquote><blockquote><p><code>func len(self) int</code></p>
<p>Returns the number of elements in the array.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-pointer"><code>type pointer</code> <a href="#type-pointer">#</a></h3>
<blockquote><p><code>func $index(self, idx int) *T</code></p>
</blockquote><blockquote><p><code>func $index(self, range Range) [*]T</code></p>
</blockquote><blockquote><p><code>func $setIndex(self, idx int, val T) void</code></p>
</blockquote><blockquote><p><code>func addr(self) int</code></p>
<p>When pointer runtime safety is enabled, this returns the raw pointer address as an <code>int64</code>.   Otherwise, the pointer itself is bitcasted to an <code>int64</code>.</p>
</blockquote><blockquote><p><code>func asObject(self) any</code></p>
<p>Casts the pointer to a Cyber object. The object is retained before it's returned.</p>
</blockquote><blockquote><p><code>func fromCstr(self, offset int) String</code></p>
<p>Returns a <code>String</code> from a null terminated C string.</p>
</blockquote><blockquote><p><code>func get(self, offset int, ctype symbol) dyn</code></p>
<p>Dereferences the pointer at a byte offset and returns the C value converted to Cyber.</p>
</blockquote><blockquote><p><code>func getString(self, offset int, len int) String</code></p>
<p>Returns a <code>String</code> with a copy of the byte data starting from an offset to the specified length.</p>
</blockquote><blockquote><p><code>func set(self, offset int, ctype symbol, val any) void</code></p>
<p>Converts the value to a compatible C value and writes it to a byte offset from this pointer.</p>
</blockquote><blockquote><p><code>func pointer.$call(T type, addr int) *T</code></p>
<p>Converts an <code>int</code> to a <code>pointer</code> value.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-externfunc"><code>type ExternFunc</code> <a href="#type-externfunc">#</a></h3>
<blockquote><p><code>func addr(self) int</code></p>
<p>Returns the memory address as an <code>int</code>. The value may be negative since it's  bitcasted from an unsigned 48-bit integer but it retains the original pointer bits.</p>
</blockquote><blockquote><p><code>func ptr(self) *void</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-fiber"><code>type Fiber</code> <a href="#type-fiber">#</a></h3>
<blockquote><p><code>func status(self) symbol</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-range"><code>type Range</code> <a href="#type-range">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-tccstate"><code>type TccState</code> <a href="#type-tccstate">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-future"><code>type Future</code> <a href="#type-future">#</a></h3>
<blockquote><p><code>func Future.complete(val T) Future[T]</code></p>
<p>Returns a <code>Future[T]</code> that has a completed value.</p>
</blockquote><blockquote><p><code>func Future.new(T type) Future[T]</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-futureresolver"><code>type FutureResolver</code> <a href="#type-futureresolver">#</a></h3>
<blockquote><p><code>func complete(self, val T) void</code></p>
</blockquote><blockquote><p><code>func future(self) Future[T]</code></p>
</blockquote><blockquote><p><code>func FutureResolver.new(T type) FutureResolver[T]</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-ref"><code>type Ref</code> <a href="#type-ref">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-refslice"><code>type RefSlice</code> <a href="#type-refslice">#</a></h3>
<blockquote><p><code>func $index(self, idx int) <ref></code></p>
</blockquote><blockquote><p><code>func $index(self, range Range) <ref_slice></code></p>
</blockquote><blockquote><p><code>func $setIndex(self, idx int, val T) void</code></p>
</blockquote><blockquote><p><code>func iterator(self) RefSliceIterator[T]</code></p>
</blockquote><blockquote><p><code>func len(self) int</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-refsliceiterator"><code>type RefSliceIterator</code> <a href="#type-refsliceiterator">#</a></h3>
<blockquote><p><code>func next(self) ?T</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-ptrslice"><code>type PtrSlice</code> <a href="#type-ptrslice">#</a></h3>
<blockquote><p><code>func $index(self, idx int) *T</code></p>
</blockquote><blockquote><p><code>func $index(self, range Range) [*]T</code></p>
</blockquote><blockquote><p><code>func $setIndex(self, idx int, val T) void</code></p>
</blockquote><blockquote><p><code>func endsWith(self, suffix [*]T) bool</code></p>
<p>Returns whether the array ends with <code>suffix</code>.</p>
</blockquote><blockquote><p><code>func findScalar(self, needle T) ?int</code></p>
<p>Returns the first index of <code>needle</code> in the slice or <code>none</code> if not found.</p>
</blockquote><blockquote><p><code>func iterator(self) PtrSliceIterator[T]</code></p>
</blockquote><blockquote><p><code>func len(self) int</code></p>
</blockquote><blockquote><p><code>func startsWith(self, prefix [*]T) bool</code></p>
<p>Returns whether the array starts with <code>prefix</code>.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-ptrsliceiterator"><code>type PtrSliceIterator</code> <a href="#type-ptrsliceiterator">#</a></h3>
<blockquote><p><code>func next(self) ?T</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-imemory-trait"><code>type IMemory trait</code> <a href="#type-imemory-trait">#</a></h3>
<blockquote><p><code>func alloc(self, len int) [*]byte</code></p>
</blockquote><blockquote><p><code>func free(self, buf [*]byte) void</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-memory"><code>type Memory</code> <a href="#type-memory">#</a></h3>
<blockquote><p><code>func Memory.new(self, T type) *T</code></p>
</blockquote><blockquote><p><code>func Memory.alloc(self, T type, n int) [*]T</code></p>
</blockquote><blockquote><p><code>func Memory.free(self, ptr *T) </code></p>
</blockquote><blockquote><p><code>func Memory.free_(self, slice [*]T) </code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-defaultmemory"><code>type DefaultMemory</code> <a href="#type-defaultmemory">#</a></h3>
<blockquote><p><code>func alloc(self, len int) [*]byte</code></p>
</blockquote><blockquote><p><code>func free(self, buf [*]byte) void</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-exprtype"><code>type ExprType</code> <a href="#type-exprtype">#</a></h3>
<blockquote><p><code>func getType(self) type</code></p>
</blockquote><!-- core.end -->
<a href="#modules">^topic</a>
<h2 id="mod-cy"><code>mod cy</code> <a href="#mod-cy">#</a></h2>
<p>The <code>cy</code> module contains functions related to the Cyber language.</p>
<p>Sample usage:</p>
<pre><code class="language-cy">use cy
print cy.toCyon([1, 2, 3])
</code></pre>
<p><a href="#modules" title="">^topic</a></p>
<!-- cy.start -->
<blockquote><p><code>var Success int</code></p>
</blockquote><blockquote><p><code>var Await int</code></p>
</blockquote><blockquote><p><code>var ErrorCompile int</code></p>
</blockquote><blockquote><p><code>var ErrorPanic int</code></p>
</blockquote><blockquote><p><code>var TypeVoid int</code></p>
</blockquote><blockquote><p><code>func eval(src String) any</code></p>
<p>Evaluates source code in an isolated VM.  If the last statement is an expression, a primitive or a String can be returned.</p>
</blockquote><blockquote><p><code>func parse(src String) Map</code></p>
<p>Parses Cyber source string into a structured map object.  Currently, only metadata about static declarations is made available but this will be extended to include an AST.</p>
</blockquote><blockquote><p><code>func parseCyon(src String) any</code></p>
<p>Parses a CYON string into a value.</p>
</blockquote><blockquote><p><code>func repl(read_line any) void</code></p>
<p>Starts an isolated REPL session.  The callback <code>read_line(prefix String) String</code> is responsible for obtaining the input.</p>
</blockquote><blockquote><p><code>func toCyon(val any) String</code></p>
<p>Encodes a value to CYON string.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-evalconfig"><code>type EvalConfig</code> <a href="#type-evalconfig">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-evalresult"><code>type EvalResult</code> <a href="#type-evalresult">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-value"><code>type Value</code> <a href="#type-value">#</a></h3>
<blockquote><p><code>func dump(self) String</code></p>
</blockquote><blockquote><p><code>func getTypeId(self) int</code></p>
</blockquote><blockquote><p><code>func toHost(self) any</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-vm"><code>type VM</code> <a href="#type-vm">#</a></h3>
<blockquote><p><code>func eval(self, code String) EvalResult</code></p>
</blockquote><blockquote><p><code>func eval(self, uri String, code String, config EvalConfig) EvalResult</code></p>
</blockquote><blockquote><p><code>func getErrorSummary(self) String</code></p>
</blockquote><blockquote><p><code>func getPanicSummary(self) String</code></p>
</blockquote><blockquote><p><code>func VM.new() VM</code></p>
<p>Create an isolated VM.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-repl"><code>type REPL</code> <a href="#type-repl">#</a></h3>
<blockquote><p><code>func printIntro(self) </code></p>
</blockquote><blockquote><p><code>func read(self, read_line dyn) ?String</code></p>
</blockquote><blockquote><p><code>func evalPrint(self, code String) void</code></p>
</blockquote><blockquote><p><code>func getPrefix(self) String</code></p>
</blockquote><blockquote><p><code>func REPL.new() REPL</code></p>
</blockquote><!-- cy.end -->
<a href="#modules">^topic</a>
<h2 id="mod-math"><code>mod math</code> <a href="#mod-math">#</a></h2>
<p>The math module contains commonly used math constants and functions.</p>
<p>Sample usage:</p>
<pre><code class="language-cy">use math

var r = 10.0
print(math.pi * r^2)
</code></pre>
<p><a href="#modules" title="">^topic</a></p>
<!-- math.start -->
<blockquote><p><code>var e float</code></p>
<p>Euler's number and the base of natural logarithms; approximately 2.718.</p>
</blockquote><blockquote><p><code>var inf float</code></p>
<p>Infinity.</p>
</blockquote><blockquote><p><code>var log10e float</code></p>
<p>Base-10 logarithm of E; approximately 0.434.</p>
</blockquote><blockquote><p><code>var log2e float</code></p>
<p>Base-2 logarithm of E; approximately 1.443.</p>
</blockquote><blockquote><p><code>var ln10 float</code></p>
<p>Natural logarithm of 10; approximately 2.303.</p>
</blockquote><blockquote><p><code>var ln2 float</code></p>
<p>Natural logarithm of 2; approximately 0.693.</p>
</blockquote><blockquote><p><code>var maxSafeInt float</code></p>
<p>The maximum integer value that can be safely represented as a float. 2^53-1 or 9007199254740991.</p>
</blockquote><blockquote><p><code>var minSafeInt float</code></p>
<p>The minumum integer value that can be safely represented as a float. -(2^53-1) or -9007199254740991.</p>
</blockquote><blockquote><p><code>var nan float</code></p>
<p>Not a number. Note that nan == nan.  However, if a nan came from an arithmetic operation, the comparison is undefined.  Use <code>isNaN</code> instead.</p>
</blockquote><blockquote><p><code>var neginf float</code></p>
<p>Negative infinity.</p>
</blockquote><blockquote><p><code>var pi float</code></p>
<p>Ratio of a circle's circumference to its diameter; approximately 3.14159.</p>
</blockquote><blockquote><p><code>var sqrt1_2 float</code></p>
<p>Square root of ½; approximately 0.707.</p>
</blockquote><blockquote><p><code>var sqrt2 float</code></p>
<p>Square root of 2; approximately 1.414.</p>
</blockquote><blockquote><p><code>func abs(a float) float</code></p>
<p>Returns the absolute value of x.</p>
</blockquote><blockquote><p><code>func acos(a float) float</code></p>
<p>Returns the arccosine of x.</p>
</blockquote><blockquote><p><code>func acosh(a float) float</code></p>
<p>Returns the hyperbolic arccosine of x.</p>
</blockquote><blockquote><p><code>func asin(a float) float</code></p>
<p>Returns the arcsine of x.</p>
</blockquote><blockquote><p><code>func asinh(a float) float</code></p>
<p>Returns the hyperbolic arcsine of a number.</p>
</blockquote><blockquote><p><code>func atan(a float) float</code></p>
<p>Returns the arctangent of x.</p>
</blockquote><blockquote><p><code>func atan2(a float, b float) float</code></p>
<p>Returns the arctangent of the quotient of its arguments.</p>
</blockquote><blockquote><p><code>func atanh(a float) float</code></p>
<p>Returns the hyperbolic arctangent of x.</p>
</blockquote><blockquote><p><code>func cbrt(a float) float</code></p>
<p>Returns the cube root of x.</p>
</blockquote><blockquote><p><code>func ceil(a float) float</code></p>
<p>Returns the smallest integer greater than or equal to x.</p>
</blockquote><blockquote><p><code>func clz32(a float) float</code></p>
<p>Returns the number of leading zero bits of the 32-bit integer x.</p>
</blockquote><blockquote><p><code>func cos(a float) float</code></p>
<p>Returns the cosine of x.</p>
</blockquote><blockquote><p><code>func cosh(a float) float</code></p>
<p>Returns the hyperbolic cosine of x.</p>
</blockquote><blockquote><p><code>func exp(a float) float</code></p>
<p>Returns e^x, where x is the argument, and e is Euler's number (2.718…, the base of the natural logarithm).</p>
</blockquote><blockquote><p><code>func expm1(a float) float</code></p>
<p>Returns subtracting 1 from exp(x).</p>
</blockquote><blockquote><p><code>func floor(a float) float</code></p>
<p>Returns the largest integer less than or equal to x.</p>
</blockquote><blockquote><p><code>func frac(a float) float</code></p>
<p>Returns the fractional or decimal part of a float value.</p>
</blockquote><blockquote><p><code>func hypot(a float, b float) float</code></p>
<p>Returns the square root of the sum of squares of its arguments.</p>
</blockquote><blockquote><p><code>func isInt(a float) bool</code></p>
<p>Returns true if the float has no fractional part, otherwise false.</p>
</blockquote><blockquote><p><code>func isNaN(a float) bool</code></p>
<p>Returns whether x is not a number.</p>
</blockquote><blockquote><p><code>func ln(a float) float</code></p>
<p>Returns the natural logarithm (㏒e; also, ㏑) of x.</p>
</blockquote><blockquote><p><code>func log(a float, b float) float</code></p>
<p>Returns the logarithm of y with base x.</p>
</blockquote><blockquote><p><code>func log10(a float) float</code></p>
<p>Returns the base-10 logarithm of x.</p>
</blockquote><blockquote><p><code>func log1p(a float) float</code></p>
<p>Returns the natural logarithm (㏒e; also ㏑) of 1 + x for the number x.</p>
</blockquote><blockquote><p><code>func log2(a float) float</code></p>
<p>Returns the base-2 logarithm of x.</p>
</blockquote><blockquote><p><code>func max(a float, b float) float</code></p>
<p>Returns the largest of two numbers.</p>
</blockquote><blockquote><p><code>func min(a float, b float) float</code></p>
<p>Returns the smallest of two numbers.</p>
</blockquote><blockquote><p><code>func mul32(a float, b float) float</code></p>
<p>Returns the result of the 32-bit integer multiplication of x and y. Integer overflow is allowed.</p>
</blockquote><blockquote><p><code>func pow(a float, b float) float</code></p>
<p>Returns base x to the exponent power y (that is, x^y).</p>
</blockquote><blockquote><p><code>func random() float</code></p>
<p>Returns a pseudo-random number between 0 and 1.</p>
</blockquote><blockquote><p><code>func round(a float) float</code></p>
<p>Returns the value of the number x rounded to the nearest integer.</p>
</blockquote><blockquote><p><code>func sign(a float) float</code></p>
<p>Returns the sign of the x, indicating whether x is positive, negative, or zero.</p>
</blockquote><blockquote><p><code>func sin(a float) float</code></p>
<p>Returns the sine of x.</p>
</blockquote><blockquote><p><code>func sinh(a float) float</code></p>
<p>Returns the hyperbolic sine of x.</p>
</blockquote><blockquote><p><code>func sqrt(a float) float</code></p>
<p>Returns the positive square root of x.</p>
</blockquote><blockquote><p><code>func tan(a float) float</code></p>
<p>Returns the tangent of x.</p>
</blockquote><blockquote><p><code>func tanh(a float) float</code></p>
<p>Returns the hyperbolic tangent of x.</p>
</blockquote><blockquote><p><code>func trunc(a float) float</code></p>
<p>Returns the integer portion of x, removing any fractional digits.</p>
</blockquote><!-- math.end -->
<a href="#modules">^topic</a>
<h2 id="std-modules">Std modules. <a href="#std-modules">#</a></h2>
<p>Std modules come with Cyber's CLI. They include:</p>
<ul>
<li><a href="#mod-cli" title="">cli</a>: Related to the command line.</li>
<li><a href="#mod-os" title="">os</a>: System level functions.</li>
<li><a href="#mod-test" title="">test</a>: Utilities for testing.</li>
</ul>
<a href="#modules">^topic</a>
<h2 id="mod-cli"><code>mod cli</code> <a href="#mod-cli">#</a></h2>
<p>The <code>cli</code> module contains functions related to the command line.</p>
<p>Sample usage:</p>
<pre><code class="language-cy">use cli
cli.repl()
</code></pre>
<p><a href="#modules" title="">^topic</a></p>
<!-- cli.start -->
<blockquote><p><code>func repl() void</code></p>
<p>Starts an isolated REPL session.  Invokes <code>cy.repl(replReadLine)</code>.</p>
</blockquote><blockquote><p><code>func replReadLine(prefix String) String</code></p>
<p>Default implementation to read a line from the CLI for a REPL.</p>
</blockquote><!-- cli.end -->
<a href="#modules">^topic</a>
<h2 id="mod-os"><code>mod os</code> <a href="#mod-os">#</a></h2>
<p>Cyber's os module contains system level functions. It's still undecided as to how much should be included here so it's incomplete. You can still access os and libc functions yourself using Cyber's FFI or embedding API.</p>
<p>Sample usage:</p>
<pre><code class="language-cy">use os

var map = os.getEnvAll()
for map -> {k, v}:
    print "$(k) -> $(v)"
</code></pre>
<p><a href="#modules" title="">^topic</a></p>
<!-- os.start -->
<blockquote><p><code>var cpu String</code></p>
<p>The current cpu arch's tag name.</p>
</blockquote><blockquote><p><code>var endian symbol</code></p>
<p>The current arch's endianness: .little, .big</p>
</blockquote><blockquote><p><code>var stderr File</code></p>
<p>Standard error file descriptor.</p>
</blockquote><blockquote><p><code>var stdin File</code></p>
<p>Standard input file descriptor.</p>
</blockquote><blockquote><p><code>var stdout File</code></p>
<p>Standard output file descriptor.</p>
</blockquote><blockquote><p><code>var system String</code></p>
<p>The current operating system's tag name.</p>
</blockquote><blockquote><p><code>var vecBitSize int</code></p>
<p>Default SIMD vector bit size.</p>
</blockquote><blockquote><p><code>func access(path String, mode symbol) void</code></p>
<p>Attempts to access a file at the given <code>path</code> with the <code>.read</code>, <code>.write</code>, or <code>.readWrite</code> mode.  Throws an error if unsuccessful.</p>
</blockquote><blockquote><p><code>func args() List[String]</code></p>
<p>Returns the command line arguments in a <code>List[String]</code>.</p>
</blockquote><blockquote><p><code>func cacheUrl(url String) String</code></p>
<p>Returns the path of a locally cached file of <code>url</code>.  If no such file exists locally, it's fetched from <code>url</code>.</p>
</blockquote><blockquote><p><code>func copyFile(srcPath String, dstPath String) void</code></p>
<p>Copies a file to a destination path.</p>
</blockquote><blockquote><p><code>func createDir(path String) void</code></p>
<p>Creates the directory at <code>path</code>. Returns <code>true</code> if successful.</p>
</blockquote><blockquote><p><code>func createFile(path String, truncate bool) File</code></p>
<p>Creates and opens the file at <code>path</code>. If <code>truncate</code> is true, an existing file will be truncated.</p>
</blockquote><blockquote><p><code>func cstr(s String) *void</code></p>
<p>Returns a null terminated C string.</p>
</blockquote><blockquote><p><code>func cwd() String</code></p>
<p>Returns the current working directory.</p>
</blockquote><blockquote><p><code>func dirName(path String) ?String</code></p>
<p>Returns the given path with its last component removed.</p>
</blockquote><blockquote><p><code>func execCmd(args List[String]) Map</code></p>
<p>Runs a shell command and returns the stdout/stderr.</p>
</blockquote><blockquote><p><code>func exePath() String</code></p>
<p>Returns the current executable's path.</p>
</blockquote><blockquote><p><code>func exit(status int) void</code></p>
<p>Exits the program with a status code.</p>
</blockquote><blockquote><p><code>func fetchUrl(url String) String</code></p>
<p>Fetches the contents at <code>url</code> using the HTTP GET request method.</p>
</blockquote><blockquote><p><code>func free(ptr *void) void</code></p>
<p>Frees the memory located at <code>ptr</code>.</p>
</blockquote><blockquote><p><code>func getEnv(key String) ?String</code></p>
<p>Returns an environment variable by key.</p>
</blockquote><blockquote><p><code>func getEnvAll() Map</code></p>
<p>Returns all environment variables as a <code>Map</code>.</p>
</blockquote><blockquote><p><code>func malloc(size int) *void</code></p>
<p>Allocates <code>size</code> bytes of memory and returns a pointer.</p>
</blockquote><blockquote><p><code>func milliTime() float</code></p>
<p>Return the calendar timestamp, in milliseconds, relative to UTC 1970-01-01.  For an high resolution timestamp, use <code>now()</code>.</p>
</blockquote><blockquote><p><code>func newFFI() FFI</code></p>
<p>Returns a new FFI context for declaring C mappings and binding a dynamic library.</p>
</blockquote><blockquote><p><code>func now() float</code></p>
<p>Returns the current time (in high resolution seconds) since an arbitrary point in time.</p>
</blockquote><blockquote><p><code>func openDir(path String) Dir</code></p>
<p>Invokes <code>openDir(path, false)</code>.</p>
</blockquote><blockquote><p><code>func openDir(path String, iterable bool) Dir</code></p>
<p>Opens a directory at the given <code>path</code>. <code>iterable</code> indicates that the directory's entries can be iterated.</p>
</blockquote><blockquote><p><code>func openFile(path String, mode symbol) File</code></p>
<p>Opens a file at the given <code>path</code> with the <code>.read</code>, <code>.write</code>, or <code>.readWrite</code> mode.</p>
</blockquote><blockquote><p><code>func parseArgs(options List[dyn]) Table</code></p>
<p>Given expected <code>ArgOption</code>s, returns a <code>Table</code> of the options and a <code>rest</code> entry which contains the non-option arguments.</p>
</blockquote><blockquote><p><code>func readAll() String</code></p>
<p>Reads stdin to the EOF as a UTF-8 string.  To return the bytes instead, use <code>stdin.readAll()</code>.</p>
</blockquote><blockquote><p><code>func readFile(path String) String</code></p>
<p>Reads the file contents from <code>path</code> as a UTF-8 string.  To return the bytes instead, use <code>File.readAll()</code>.</p>
</blockquote><blockquote><p><code>func readLine() String</code></p>
<p>Reads stdin until a new line as a <code>String</code>. This is intended to read user input from the command line.  For bulk reads from stdin, use <code>stdin</code>.</p>
</blockquote><blockquote><p><code>func realPath(path String) String</code></p>
<p>Returns the absolute path of the given path.</p>
</blockquote><blockquote><p><code>func removeDir(path String) void</code></p>
<p>Removes an empty directory at <code>path</code>. Returns <code>true</code> if successful.</p>
</blockquote><blockquote><p><code>func removeFile(path String) void</code></p>
<p>Removes the file at <code>path</code>. Returns <code>true</code> if successful.</p>
</blockquote><blockquote><p><code>func setEnv(key String, val String) void</code></p>
<p>Sets an environment variable by key.</p>
</blockquote><blockquote><p><code>func sleep(ms float) void</code></p>
<p>Pauses the current thread for given milliseconds.</p>
</blockquote><blockquote><p><code>func unsetEnv(key String) void</code></p>
<p>Removes an environment variable by key.</p>
</blockquote><blockquote><p><code>func writeFile(path String, contents String) void</code></p>
<p>Writes <code>contents</code> as a string or bytes to a file.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-file"><code>type File</code> <a href="#type-file">#</a></h3>
<blockquote><p><code>func close(self) void</code></p>
<p>Closes the file handle. File ops invoked afterwards will return <code>error.Closed</code>.</p>
</blockquote><blockquote><p><code>func iterator(self) File</code></p>
</blockquote><blockquote><p><code>func next(self) String</code></p>
</blockquote><blockquote><p><code>func read(self, n int) String</code></p>
<p>Reads at most <code>n</code> bytes as an <code>Array</code>. <code>n</code> must be at least 1.  A result with length 0 indicates the end of file was reached.</p>
</blockquote><blockquote><p><code>func readAll(self) String</code></p>
<p>Reads to the end of the file and returns the content as an <code>Array</code>.</p>
</blockquote><blockquote><p><code>func seek(self, n int) void</code></p>
<p>Seeks the read/write position to <code>pos</code> bytes from the start. Negative <code>pos</code> is invalid.</p>
</blockquote><blockquote><p><code>func seekFromCur(self, n int) void</code></p>
<p>Seeks the read/write position by <code>pos</code> bytes from the current position.</p>
</blockquote><blockquote><p><code>func seekFromEnd(self, n int) void</code></p>
<p>Seeks the read/write position by <code>pos</code> bytes from the end. Positive <code>pos</code> is invalid.</p>
</blockquote><blockquote><p><code>func stat(self) Map</code></p>
<p>Returns info about the file as a <code>Map</code>.</p>
</blockquote><blockquote><p><code>func streamLines(self) File</code></p>
<p>Equivalent to <code>streamLines(4096)</code>.</p>
</blockquote><blockquote><p><code>func streamLines(self, bufSize int) File</code></p>
<p>Returns an iterable that streams lines ending in <code>\n</code>, <code>\r</code>, <code>\r\n</code>, or the <code>EOF</code>.  The lines returned include the new line character(s).  A buffer size of <code>bufSize</code> bytes is allocated for reading.  If <code>\r</code> is found at the end of the read buffer, the line is returned instead of  waiting to see if the next read has a connecting <code>\n</code>.</p>
</blockquote><blockquote><p><code>func write(self, val String) int</code></p>
<p>Writes a <code>String</code> at the current file position.  The number of bytes written is returned.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-dir"><code>type Dir</code> <a href="#type-dir">#</a></h3>
<blockquote><p><code>func iterator(self) DirIterator</code></p>
<p>Returns a new iterator over the directory entries.  If this directory was not opened with the iterable flag, <code>error.NotAllowed</code> is returned instead.</p>
</blockquote><blockquote><p><code>func stat(self) Map</code></p>
<p>Returns info about the file as a <code>Map</code>.</p>
</blockquote><blockquote><p><code>func walk(self) DirIterator</code></p>
<p>Returns a new iterator over the directory recursive entries.  If this directory was not opened with the iterable flag, <code>error.NotAllowed</code> is returned instead.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-diriterator"><code>type DirIterator</code> <a href="#type-diriterator">#</a></h3>
<blockquote><p><code>func next(self) ?Map</code></p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-ffi"><code>type FFI</code> <a href="#type-ffi">#</a></h3>
<blockquote><p><code>func bindCallback(self, fn any, params List[dyn], ret symbol) ExternFunc</code></p>
<p>Creates an <code>ExternFunc</code> that contains a C function pointer with the given signature.  The extern function is a wrapper that calls the provided user function.  Once created, the extern function is retained and managed by the FFI context.</p>
</blockquote><blockquote><p><code>func bindLib(self, path ?String) any</code></p>
<p>Calls <code>bindLib(path, [:])</code>.</p>
</blockquote><blockquote><p><code>func bindLib(self, path ?String, config Table) any</code></p>
<p>Creates a handle to a dynamic library and functions declared from <code>cfunc</code>.  By default, an anonymous object is returned with the C-functions binded as the object's methods.  If <code>config</code> contains <code>gen_table: true</code>, a <code>Table</code> is returned instead with C-functions  binded as function values.</p>
</blockquote><blockquote><p><code>func bindObjPtr(self, obj any) *void</code></p>
<p>Returns a Cyber object's pointer. Operations on the pointer is unsafe,  but it can be useful when passing it to C as an opaque pointer.  The object is also retained and managed by the FFI context.</p>
</blockquote><blockquote><p><code>func cbind(self, mt type, fields List[dyn]) void</code></p>
<p>Binds a Cyber type to a C struct.</p>
</blockquote><blockquote><p><code>func cfunc(self, name String, params List[dyn], ret any) void</code></p>
<p>Declares a C function which will get binded to the library handle created from <code>bindLib</code>.</p>
</blockquote><blockquote><p><code>func new(self, ctype symbol) *void</code></p>
<p>Allocates memory for a C struct or primitive with the given C type specifier.  A <code>pointer</code> to the allocated memory is returned.  Eventually this will return a <code>cpointer</code> instead which will be more idiomatic to use.</p>
</blockquote><blockquote><p><code>func unbindObjPtr(self, obj any) void</code></p>
<p>Releases the object from the FFI context.  External code should no longer use the object's pointer since it's not guaranteed to exist  or point to the correct object.</p>
</blockquote><a href="#modules">^topic</a>
<h3 id="type-carray"><code>type CArray</code> <a href="#type-carray">#</a></h3>
<a href="#modules">^topic</a>
<h3 id="type-cdimarray"><code>type CDimArray</code> <a href="#type-cdimarray">#</a></h3>
<!-- os.end -->
<a href="#modules">^topic</a>
<h3 id="map-direntry"><code>Map DirEntry</code> <a href="#map-direntry">#</a></h3>
<table><thead><tr><th>key</th><th>summary</th></tr></thead><tbody><tr><td><code>'name' -> Array</code></td><td>The name of the file or directory.</td></tr><tr><td><code>'type' -> #file | #dir | #unknown</code></td><td>The type of the entry.</td></tr></tbody></table><a href="#modules">^topic</a>
<h3 id="map-dirwalkentry"><code>Map DirWalkEntry</code> <a href="#map-dirwalkentry">#</a></h3>
<table><thead><tr><th>key</th><th>summary</th></tr></thead><tbody><tr><td><code>'name' -> Array</code></td><td>The name of the file or directory.</td></tr><tr><td><code>'path' -> Array</code></td><td>The path of the file or directory relative to the walker's root directory.</td></tr><tr><td><code>'type' -> #file | #dir | #unknown</code></td><td>The type of the entry.</td></tr></tbody></table><a href="#modules">^topic</a>
<h3 id="table-argoption"><code>Table ArgOption</code> <a href="#table-argoption">#</a></h3>
<table><thead><tr><th>key</th><th>summary</th></tr></thead><tbody><tr><td><code>'name' -> String</code></td><td>The name of the option to match excluding the hyphen prefix. eg. <code>-path</code></td></tr><tr><td><code>'type' -> metatype(String | float | boolean)</code></td><td>Parse as given value type.</td></tr><tr><td><code>'default' -> any</code></td><td>Optional: Default value if option is missing. <code>none</code> is used if this is not provided.</td></tr></tbody></table><a href="#modules">^topic</a>
<h2 id="mod-test"><code>mod test</code> <a href="#mod-test">#</a></h2>
<p>The <code>test</code> module contains utilities for testing.</p>
<p>Sample usage:</p>
<pre><code class="language-cy">use t 'test'

var a = 123 + 321
t.eq(a, 444)
</code></pre>
<p><a href="#modules" title="">^topic</a></p>
<!-- test.start -->
<blockquote><p><code>func assert(pred bool) void</code></p>
<p>Panics if <code>pred</code> is <code>false</code>.</p>
</blockquote><blockquote><p><code>func eq(a T, b T) bool</code></p>
<p>Returns whether two values are equal.  Panics with <code>error.AssertError</code> if types or values do not match up.</p>
</blockquote><blockquote><p><code>func eqList(a List[T], b List[T]) bool</code></p>
<p>Returns <code>true</code> if two lists have the same size and the elements are equal  as if <code>eq</code> was called on those corresponding elements.</p>
</blockquote><blockquote><p><code>func eqSlice(a <ref_slice>, b <ref_slice>) bool</code></p>
<p>Returns <code>true</code> if two slices have the same size and the elements are equal  as if <code>eq</code> was called on those corresponding elements.</p>
</blockquote><blockquote><p><code>func eqNear(a T, b T) bool</code></p>
<p>Returns <code>true</code> if two numbers are near each other within epsilon 1e-5.</p>
</blockquote><blockquote><p><code>func fail() </code></p>
</blockquote><blockquote><p><code>func fail(msg String) </code></p>
</blockquote><blockquote><p><code>func throws(fn any, err error) </code></p>
<p>Asserts that an error was thrown when invoking a function.</p>
</blockquote><!-- test.end -->
<a href="#modules">^topic</a>
<h1 id="ffi">FFI. <a href="#ffi">#</a></h1>
<ul>
<li><a href="#ffi-context" title="">FFI context.</a></li>
<li><a href="#declare-functions" title="">Declare functions.</a></li>
<li><a href="#bind-library" title="">Bind library.</a><ul>
<li><a href="#search-path" title="">Search path.</a></li>
<li><a href="#configuration" title="">Configuration.</a></li>
<li><a href="#finalizer" title="">Finalizer.</a></li>
</ul>
</li>
<li><a href="#mappings" title="">Mappings.</a></li>
<li><a href="#bind-to-cyber-type" title="">Bind to Cyber type.</a></li>
<li><a href="#cbindgency" title="">cbindgen.cy</a></li>
</ul>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Cyber supports binding to an existing C ABI compatible library at runtime.
This allows you to call into dynamic libraries created in C or other languages.
Cyber uses <code>libtcc</code> to JIT compile the bindings so function calls are fast.
The example shown below can be found in <a href="https://github.com/fubark/cyber/blob/master/examples/ffi.cy" title="">Examples</a>.</p>
<h2 id="ffi-context">FFI context. <a href="#ffi-context">#</a></h2>
<p>An FFI context contains declarations that map C to Cyber. Afterwards, it allows you to bind to a dynamic library or create interoperable objects. To create a new <code>FFI</code> context:</p>
<pre><code class="language-cy">use os

var ffi = os.newFFI()
</code></pre>
<a href="#ffi">^topic</a>
<h2 id="declare-functions">Declare functions. <a href="#declare-functions">#</a></h2>
<p>Functions from a library are first declared using <code>cfunc</code> which accepts C types in the form of symbols. In a future update they will accept C syntax instead.</p>
<pre><code class="language-cy">ffi.cfunc('add', {.int, .int}, .int)
</code></pre>
<p>The first argument refers to the symbol's name in the dynamic library.
The second argument contains the function's parameter types and finally the last argument is the function's return type.</p>
<p>The example above maps to this C function:</p>
<pre><code class="language-c">int add(int a, int b) {
    return a + b;
}
</code></pre>
<a href="#ffi">^topic</a>
<h2 id="bind-library">Bind library. <a href="#bind-library">#</a></h2>
<p><code>bindLib</code> accepts the path to the library and returns a object which can be used to invoke the functions declared from <code>cfunc</code>:</p>
<pre><code class="language-cy">dyn lib = ffi.bindLib('./mylib.so')
lib.add(123, 321)
</code></pre>
<p>Note that <code>dyn</code> is used to allow <code>lib</code> to be used dynamically since the type is unknown at compile-time.</p>
<a href="#ffi">^topic</a>
<h3 id="search-path">Search path. <a href="#search-path">#</a></h3>
<p>If the path argument to <code>bindLib</code> is just a filename, the search steps for the library is specific to the operating system. Provide an absolute (eg. '/foo/mylib.so') or relative (eg. './mylib.so') path to load from a direct location instead. When the path argument is <code>none</code>, it loads the currently running executable as a library allowing you to bind exported functions from the Cyber CLI or your own application/runtime.</p>
<a href="#ffi">^topic</a>
<h3 id="configuration">Configuration. <a href="#configuration">#</a></h3>
<p>By default <code>bindLib</code> returns an anonymous object with the binded C-functions as methods. This is convenient for invoking functions using the method call syntax. If a config is passed into <code>bindLib</code> as the second argument, <code>gen_table=true</code> makes <code>bindLib</code> return a table instead with the binded C-functions as Cyber functions.</p>
<a href="#ffi">^topic</a>
<h3 id="finalizer">Finalizer. <a href="#finalizer">#</a></h3>
<p>The resulting object of <code>bindLib</code> holds a reference to an internal TCCState which owns the loaded JIT code.
Once the object is released by ARC, the TCCState is also released which removes the JIT code from memory.</p>
<a href="#ffi">^topic</a>
<h2 id="mappings">Mappings. <a href="#mappings">#</a></h2>
<p>When using <code>cfunc</code> or <code>cbind</code> declarations, <a href="#symbols" title="">symbols</a> are used to represent default type mappings from Cyber to C and back:</p>
<blockquote><p><em>Incomplete: This is not the final API for dynamically loading and interfacing with C libraries. The plan is to parse a subset of C headers to bind to Cyber types and functions.</em></p>
</blockquote><table><thead><tr><th>Binding</th><th>Cyber</th><th>C</th></tr></thead><tbody><tr><td>.bool</td><td>bool</td><td>bool</td></tr><tr><td>.char</td><td>int</td><td>int8_t, signed char</td></tr><tr><td>.uchar</td><td>int</td><td>uint8_t, unsigned char</td></tr><tr><td>.short</td><td>int</td><td>int16_t, short</td></tr><tr><td>.ushort</td><td>int</td><td>uint16_t, unsigned short</td></tr><tr><td>.int</td><td>int</td><td>int32_t, int</td></tr><tr><td>.uint</td><td>int</td><td>uint32_t, unsigned int</td></tr><tr><td>.long</td><td>int</td><td>int64_t, long long</td></tr><tr><td>.ulong</td><td>int</td><td>uint64_t, unsigned long long</td></tr><tr><td>.usize</td><td>int</td><td>size_t, uintptr_t</td></tr><tr><td>.float</td><td>float</td><td>float</td></tr><tr><td>.double</td><td>float</td><td>double</td></tr><tr><td>(1) .charPtr</td><td>*void</td><td>char*</td></tr><tr><td>.voidPtr</td><td>*void</td><td>void*</td></tr><tr><td>(2) type {S}</td><td>type {S}</td><td>struct</td></tr></tbody></table><ol>
<li>Use <code>os.cstr()</code> and <code>pointer.fromCstr()</code> to convert between a Cyber string and a null terminated C string.</li>
<li>The mapping from a Cyber object type <code>S</code> and the C-struct can be declared with <code>cbind</code>.</li>
</ol>
<a href="#ffi">^topic</a>
<h2 id="bind-to-cyber-type">Bind to Cyber type. <a href="#bind-to-cyber-type">#</a></h2>
<p><code>cbind</code> is used to bind a C struct to a Cyber object type. Once declared, the Cyber type can be used as a binding type in function declarations:</p>
<pre><code class="language-cy">use os

type MyObject:
    a float
    b *void
    c bool

ffi.cbind(MyObject, {.float, .voidPtr, .bool})
ffi.cfunc('foo', {MyObject}, MyObject)
dyn lib = ffi.bindLib('./mylib.so')

var res = lib.foo(MyObject{a=123.0, b=os.cstr('foo'), c=true})
</code></pre>
<p>The example above maps to these C declarations in <code>mylib.so</code>:</p>
<pre><code class="language-c">typedef struct MyObject {
    double a;
    char* b;
    bool c;
} MyObject;

MyObject foo(MyObject o) {
    // Do something.
}
</code></pre>
<p><code>cbind</code> also generates <code>ptrTo[Type]</code> as a helper function to dereference an opaque ptr to a new Cyber object:</p>
<pre><code class="language-cy">ffi.cfunc('foo', {MyObject}, .voidPtr)
dyn lib = ffi.bindLib('./mylib.so')

var ptr = lib.foo(MyObject{a=123, b=os.cstr('foo'), c=true})
var res = lib.ptrToMyObject(ptr)
</code></pre>
<a href="#ffi">^topic</a>
<h2 id="cbindgency">cbindgen.cy <a href="#cbindgency">#</a></h2>
<p><a href="https://github.com/fubark/cyber/blob/master/src/tools/cbindgen.cy" title="">cbindgen.cy</a> is a Cyber script that automatically generates bindings given a C header file. Some example bindings that were generated include: <a href="https://github.com/fubark/ray-cyber" title="">Raylib</a> and <a href="https://github.com/fubark/cyber/blob/master/src/tools/llvm.cy" title="">LLVM</a>.</p>
<a href="#ffi">^topic</a>
<h1 id="error-handling">Error Handling. <a href="#error-handling">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#error-value" title="">Error value.</a><ul>
<li><a href="#error-literal" title=""><code>error</code> literal.</a></li>
<li><a href="#error-payload" title=""><code>error</code> payload.</a></li>
<li><a href="#error-set-type" title=""><code>error</code> set type.</a></li>
</ul>
</li>
<li><a href="#throwing-errors" title="">Throwing errors.</a></li>
<li><a href="#catching-errors" title="">Catching errors.</a><ul>
<li><a href="#try-block" title=""><code>try</code> block.</a></li>
<li><a href="#caught-variable" title=""><code>caught</code> variable.</a></li>
<li><a href="#catch-matching" title=""><code>catch</code> matching.</a></li>
<li><a href="#try-expression" title=""><code>try</code> expression.</a></li>
<li><a href="#value-or-error" title="">Value or error.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#semantic-checks" title="">Semantic checks.</a><ul>
<li><a href="#throws-modifier" title="">Throws modifier.</a></li>
<li><a href="#throws-check" title="">Throws check.</a></li>
</ul>
</li>
<li><a href="#stack-trace" title="">Stack trace.</a></li>
<li><a href="#unexpected-errors" title="">Unexpected errors.</a><ul>
<li><a href="#panics" title="">Panics.</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Cyber provides a throw/catch mechanism to handle expected errors. For unexpected errors, panics can be used as a fail-fast mechanism to abort the currently running fiber.</p>
<h2 id="error-value">Error value. <a href="#error-value">#</a></h2>
<a href="#error-handling">^topic</a>
<h3 id="error-literal"><code>error</code> literal. <a href="#error-literal">#</a></h3>
<p>An <code>error</code> value contains a <code>symbol</code>. They can be created without a declaration using the error literal:</p>
<pre><code class="language-cy">var err = error.Oops
</code></pre>
<p>Use <code>sym()</code> to obtain the underlying symbol:</p>
<pre><code class="language-cy">print err.sym()   -- Prints ".Oops"
</code></pre>
<p>Since <code>error</code> is a primitive value, it can be compared using the <code>==</code> operator.</p>
<pre><code class="language-cy">if err == error.Oops:
    handleOops()

-- Alternatively.
if err.sym() == .Oops:
    handleOops()
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="error-payload"><code>error</code> payload. <a href="#error-payload">#</a></h3>
<p>An payload value can be attached when throwing an error value. <em>Planned Feature</em></p>
<a href="#error-handling">^topic</a>
<h3 id="error-set-type"><code>error</code> set type. <a href="#error-set-type">#</a></h3>
<p>Error set types enumerate error values that belong to the same group of errors: <em>Planned Feature</em></p>
<pre><code class="language-cy">type MyError error:
    case boom
    case badArgument
    case nameTooLong

var err = MyError.nameTooLong
</code></pre>
<a href="#error-handling">^topic</a>
<h2 id="throwing-errors">Throwing errors. <a href="#throwing-errors">#</a></h2>
<p>Use the <code>throw</code> keyword to throw errors.
A thrown error continues to bubble up the call stack until it is caught by a <code>try</code> block or <code>try</code> expression.</p>
<pre><code class="language-cy">func fail():
    throw error.Oops      -- Throws an error with the symbol `#Oops`

func fail2():
    throw 123             -- panic: Can only throw an `error` value.
</code></pre>
<p><code>throw</code> can also be used as an expression.</p>
<pre><code class="language-cy">func fail():
    var a = false or throw error.False
</code></pre>
<a href="#error-handling">^topic</a>
<h2 id="catching-errors">Catching errors. <a href="#catching-errors">#</a></h2>
<a href="#error-handling">^topic</a>
<h3 id="try-block"><code>try</code> block. <a href="#try-block">#</a></h3>
<p>The <code>try</code> block catches thrown errors and resumes execution in a followup <code>catch</code> block:</p>
<pre><code class="language-cy">try:
    funcThatCanFail()
catch err:
    print err      -- 'error.Failed'
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="caught-variable"><code>caught</code> variable. <a href="#caught-variable">#</a></h3>
<p>The contextual <code>caught</code> variable is used to reference the caught error: <em>Planned Feature</em></p>
<pre><code class="language-cy">try:
    funcThatCanFail()
catch:
    print caught   -- 'error.Failed'
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="catch-matching"><code>catch</code> matching. <a href="#catch-matching">#</a></h3>
<p>An inner <code>catch</code> block contains a matching clause: <em>Planned Feature</em></p>
<pre><code class="language-cy">try:
    funcThatCanFail()
catch error.BadDay:
    eatSnack()
catch:
    print caught
</code></pre>
<p>Error sets can be matched: <em>Planned Feature</em></p>
<pre><code class="language-cy">try:
    funcThatCanFail()
catch MyError.Boom:
    print 'Kaboom!'
catch:
    print caught
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="try-expression"><code>try</code> expression. <a href="#try-expression">#</a></h3>
<p>The <code>try</code> expression either returns a non-error result or the default value from the <code>catch</code> clause:</p>
<pre><code class="language-cy">var res = try funcThatCanFail() catch 123
print res         -- '123'
</code></pre>
<p>Since errors bubble up automatically, any errors thrown from sub-expressions are also caught:</p>
<pre><code class="language-cy">var res = try happyFunc(funcThatCanFail()) catch 123
print res         -- '123'
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="value-or-error">Value or error. <a href="#value-or-error">#</a></h3>
<p>When the <code>catch</code> clause is omitted, the <code>try</code> expression will return either the value or the error:</p>
<pre><code class="language-cy">var res = try funcThatCanFail()
if res == error.Failed:
    print 'Result is an error.'
</code></pre>
<a href="#error-handling">^topic</a>
<h2 id="semantic-checks">Semantic checks. <a href="#semantic-checks">#</a></h2>
<a href="#error-handling">^topic</a>
<h3 id="throws-modifier">Throws modifier. <a href="#throws-modifier">#</a></h3>
<p>The throws modifier <code>!</code> indicates that a function contains a throwing expression that was not caught with <code>try catch</code>.</p>
<p>The modifier is attached to the function return type as a prefix:</p>
<pre><code class="language-cy">func foo() !void:
    throw error.Failure
</code></pre>
<p>This declaration indicates the function can either return an <code>int</code> type or throw an error:</p>
<pre><code class="language-cy">func result(cond bool) !int:
    if cond:
        return 123
    else:
        throw error.Failure
</code></pre>
<a href="#error-handling">^topic</a>
<h3 id="throws-check">Throws check. <a href="#throws-check">#</a></h3>
<p>The compiler requires a throws modifier if the function contains an uncaught throwing expression: <em>Planned Feature</em></p>
<pre><code class="language-cy">func foo(a int) int:
    if a == 10:
        throw error.Failure   --> CompileError.
    else:
        return a * 2

--> CompileError. Uncaught throwing expression.
--> `foo` requires the `!` throws modifier or
--> the expression must be caught with `try`.
</code></pre>
<a href="#error-handling">^topic</a>
<h2 id="stack-trace">Stack trace. <a href="#stack-trace">#</a></h2>
<p>When an uncaught error bubbles up to the top, its stack trace from the <code>throw</code> callsite is dumped to the console. The builtin <code>errorTrace()</code> and <code>errorReport()</code> are used to obtain the stack trace info.</p>
<pre><code class="language-cy">try:
    funcThatCanFail()
catch:
    -- Prints the stack trace summary of the caught error.
    print errorReport()

    -- Provides structured info about the stack trace.
    var info = errorTrace()
    print info.frames.len()
</code></pre>
<a href="#error-handling">^topic</a>
<h2 id="unexpected-errors">Unexpected errors. <a href="#unexpected-errors">#</a></h2>
<p>An unexpected error is an error that is not meant to be handled at runtime.</p>
<a href="#error-handling">^topic</a>
<h3 id="panics">Panics. <a href="#panics">#</a></h3>
<p>The builtin <code>panic</code> is used as a fail-fast mechanism to quickly exit the current fiber with an error payload:</p>
<pre><code class="language-cy">func kaboom():
    panic(error.danger)

kaboom()     -- Script ends and prints the stack trace.
</code></pre>
<p>Panics can not be caught using <code>try catch</code>. Once <code>panic</code> is invoked, the current fiber stops execution and begins to unwind its call stack. Once the error is propagated to the root, the fiber ends and transitions to a panic state. If the main fiber ends this way, the VM begins to shutdown. Otherwise, execution resumes on the next fiber which allows recovery from a panic.</p>
<a href="#error-handling">^topic</a>
<h1 id="concurrency">Concurrency. <a href="#concurrency">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#async" title="">Async.</a><ul>
<li><a href="#futures" title="">Futures.</a></li>
<li><a href="#await" title=""><code>await</code>.</a></li>
<li><a href="#colorless-async" title="">Colorless async.</a></li>
<li><a href="#future-chains" title="">Future chains.</a></li>
<li><a href="#resolving-futures" title="">Resolving futures.</a></li>
<li><a href="#structured-concurrency" title="">Structured concurrency.</a></li>
<li><a href="#finish-policy" title="">Finish policies.</a></li>
<li><a href="#task-cancellation" title="">Task cancellation.</a></li>
<li><a href="#threads" title="">Threads.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#fibers" title="">Fibers.</a><ul>
<li><a href="#creating-fibers" title="">Creating fibers.</a></li>
<li><a href="#passing-arguments" title="">Passing arguments.</a></li>
<li><a href="#reset-state" title="">Reset state.</a></li>
<li><a href="#rebinding-arguments" title="">Rebinding arguments.</a></li>
<li><a href="#fiber-block" title="">Fiber block.</a></li>
<li><a href="#pause-and-resume" title="">Pause and resume.</a></li>
<li><a href="#fiber-state" title="">Fiber state.</a></li>
</ul>
</li>
<li><a href="#gas-mileage" title="">Gas mileage.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Cyber supports asynchronous and cooperative concurrency.</p>
<h2 id="async">Async. <a href="#async">#</a></h2>
<p>Cyber supports asynchronous execution which provides preemptive concurrency.
Tasks can be scheduled over a single thread. <em>Multi-threaded execution is planned.</em></p>
<a href="#concurrency">^topic</a>
<h3 id="futures">Futures. <a href="#futures">#</a></h3>
<p>A <code>Future</code> is a promise that some work will either complete or fail at some point in the future.
This abstraction allows the current thread to continue execution without waiting for the completion of the future.</p>
<p>The asynchronous work encapsulated by the future has the opportunity to run in parallel.
For example, I/O bound work can be delegated to the operating system and CPU bound work can be run across multiple threads.
Some work may simply run on the same thread.</p>
<p>If an API function is meant to do work asynchronously, it would return a <code>Future</code>:</p>
<pre><code class="language-cy">use aio

var f = aio.delay(1000)
print f          --> Future(void)
</code></pre>
<p>Futures can hold a result value when they are completed:</p>
<pre><code class="language-cy">use aio

var f = aio.readFile('foo.txt')
print f          --> Future(String)
</code></pre>
<p>Futures can be created with a completed value:</p>
<pre><code class="language-cy">var f = Future.complete(100)
print f          --> Future(int)
print f.get().?  --> 100
</code></pre>
<p>Future are also created when composing them together.</p>
<a href="#concurrency">^topic</a>
<h3 id="await"><code>await</code>. <a href="#await">#</a></h3>
<p>The <code>await</code> expression asynchronously waits for a <code>Future</code> to resolve.
It guarantees that the current execution flow will not resume until the future is completed.
Once resumed, the expression evaluates to the completed result:</p>
<pre><code class="language-cy">use aio

var res = await aio.readFile('foo.txt')
print res        --> bar
</code></pre>
<p>In the above example, the file contents of <code>foo.txt</code> is "bar".</p>
<p><code>await</code> suspends the current fiber so the scheduler can execute tasks in its ready queue.
When the future resolves, the suspended task is moved to the ready queue waiting to resume execution.</p>
<p>Performing <code>await</code> on other values besides a <code>Future</code> type will evaluate to the value and will not perform any waiting:</p>
<pre><code class="language-cy">var v = await 123
print v          --> 123
</code></pre>
<a href="#concurrency">^topic</a>
<h3 id="colorless-async">Colorless async. <a href="#colorless-async">#</a></h3>
<p><code>await</code> can be used in any function.
This means that async functions are colorless and don't require a special function modifier.</p>
<a href="#concurrency">^topic</a>
<h3 id="future-chains">Future chains. <a href="#future-chains">#</a></h3>
<p><code>Future.then</code> is used to attach a callback that will only be invoked when the future completes, thereby creating an asynchronous chain: <em>Planned Feature</em></p>
<pre><code class="language-cy">use aio

var f = aio.readFile('foo.txt').then() -> res:
    print res    --> bar

print f          --> Future(void)
</code></pre>
<p>By default <code>Future.then</code> evaluates to a new <code>Future(void)</code> and represents the completion of the callback.
A callback that returns a result requires a generic parameter or inferred from the lambda: <em>Planned Feature</em></p>
<pre><code class="language-cy">var f = aio.readFile('foo.txt').then() -> res:
    return res.len()

print f          --> Future(int)
print await f    --> 3
</code></pre>
<p>Similarily, <code>Future.catch</code> attaches a callback that will only be invoked when the future fails: <em>Planned Feature</em></p>
<pre><code class="language-cy">var f = aio.readFile('foo.txt').catch() -> err:
    print err    --> error.FileNotFound
</code></pre>
<a href="#concurrency">^topic</a>
<h3 id="resolving-futures">Resolving futures. <a href="#resolving-futures">#</a></h3>
<p><code>FutureResolver</code> produces a completable <code>Future</code>. In the following example, a future is completed with the <code>FutureResolver</code> after a queued task runs:</p>
<pre><code class="language-cy">var r = FutureResolver[int].new()

queueTask():
    r.complete(234)

var v = await r.future()
print v
</code></pre>
<a href="#concurrency">^topic</a>
<h3 id="structured-concurrency">Structured concurrency. <a href="#structured-concurrency">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><p>Asychronous tasks must be created with an <code>Async</code> context which groups together related tasks.
This gives tasks well-defined lifetimes and allows policies to be applied to a task group.</p>
<p>Every program begins by pushing a new <code>Async.waitAll</code> context to the <code>async</code> context variable.
<code>waitAll</code> is a <a href="#finish-policies" title="">finish policy</a> that waits for all tasks to complete before it marks its finish task as completed.
In the following example, the created tasks are attached to the current <code>Async</code> context:</p>
<pre><code class="language-cy">use aio

aio.delay(1000)
addMoreTasks()
</code></pre>
<p>Since the program did not explicitly wait for the completion of the current <code>Async</code> context, execution will end before 1 second has elapsed.</p>
<p>To wait for all the tasks to complete, the program can wait for the <code>Async</code> context to finish:</p>
<pre><code class="language-cy">use aio

context async Async

aio.delay(1000)
addMoreTasks()

await async.finish()
</code></pre>
<p>The context variable <code>async</code> is declared to access the current <code>Async</code> context.
<code>finish</code> applies the finish policy <code>waitAll</code> which completes when all tasks under the async context have been completed.</p>
<p>After invoking <code>finish</code>, new tasks can no longer be created under the async context.
Doing so would result in a runtime error.
A future is returned to indicate the completion of the finish task.</p>
<p>Explicitly invoking <code>finish</code> isn't idiomatic and was only demonstrated to show how an async context works. The same feat can be achieved with helpers that can wrap a block of related async logic:</p>
<pre><code class="language-cy">use aio

await Async.block(.waitAll):
    aio.delay(1000)
    addMoreTasks()
</code></pre>
<p><code>Async.block</code> begins by creating a new async context and pushing the context to <code>async</code>.
The callback is then invoked which creates a new task under the <code>async</code> context.
Once the callback returns, the <code>async</code> context and the result of <code>Async.finish</code> is returned.</p>
<a href="#concurrency">^topic</a>
<h3 id="finish-policies">Finish policies. <a href="#finish-policies">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#concurrency">^topic</a>
<h3 id="task-cancellation">Task cancellation. <a href="#task-cancellation">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#concurrency">^topic</a>
<h3 id="threads">Threads. <a href="#threads">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#concurrency">^topic</a>
<h2 id="fibers">Fibers. <a href="#fibers">#</a></h2>
<p>A fiber represents a separate execution context as a first-class value. It contains it's own call stack and program counter. Fibers by themselves do not enable parallelism.</p>
<a href="#concurrency">^topic</a>
<h3 id="creating-fibers">Creating fibers. <a href="#creating-fibers">#</a></h3>
<p>The <code>coinit</code> keyword creates and returns a new fiber using a function as the entry point:</p>
<pre><code class="language-cy">var count = 0

var foo = func ():
    count += 1
    coyield
    count += 1

var task = coinit(foo)

print count          -- '0'
coresume task
print count          -- '1'
coresume task
print count          -- '2'
</code></pre>
<p>A fiber does not start execution until <code>coresume</code> is invoked on it.
<code>coyield</code> pauses the current fiber and execution is returned to the previous fiber that invoked <code>coresume</code>.</p>
<a href="#concurrency">^topic</a>
<h3 id="passing-arguments">Passing arguments. <a href="#passing-arguments">#</a></h3>
<p>Arguments after the callee are passed into the entry function:</p>
<pre><code class="language-cy">var count = 0

var increment = func (inc):
    count += inc

var task = coinit(increment, 5)
coresume task
print count          -- '5'
</code></pre>
<p>When the fiber is created, the arguments are saved inside the fiber's stack. Once the first <code>coresume</code> is invoked, the entry function is invoked with the saved arguments.</p>
<a href="#concurrency">^topic</a>
<h3 id="reset-state">Reset state. <a href="#reset-state">#</a></h3>
<p>To reset a fiber to its initial state, invoke <code>reset()</code>. <em>Planned Feature</em>
When reset, the existing stack is unwinded, the program counter returns to the starting point, and the state is set to <code>.init</code>:</p>
<pre><code class="language-cy">func fib(n int) int:
    coyield n
    if n < 2:
        return n
    return fib(n - 1) + fib(n - 2)

var task = coinit(fib, 10)

-- Progress the fiber...
print(coresume task)    -- Prints "10"
print(coresume task)    -- Prints "9"
print(coresume task)    -- Prints "8"

-- Reset back to the start with the `.init` state.
task.reset()
print(coresume task)    -- Prints "10"
</code></pre>
<a href="#concurrency">^topic</a>
<h3 id="rebinding-arguments">Rebinding arguments. <a href="#rebinding-arguments">#</a></h3>
<p>Arguments attached to the fiber can be rebinded with a different set of values. <em>Planned Feature</em>
This allows fiber reuse, instead of creating a new fiber:</p>
<pre><code class="language-cy">var task = coinit(fib, 10)

-- Run task to completion.
var res = 0
while task.status() != .done:
    res = coresume fiber
print res

task.reset()
task.bindArgs(20)

-- Run task again with the new argument...
</code></pre>
<a href="#concurrency">^topic</a>
<h3 id="fiber-block">Fiber block. <a href="#fiber-block">#</a></h3>
<p>A fiber block is used to construct a fiber without an entry function. <em>Planned Feature</em> The counting example can be rewritten to:</p>
<pre><code class="language-cy">var count = 0

var task = coinit:
    count += 1       -- `count is captured`
    coyield
    count += 1

print count          -- '0'
coresume task
print count          -- '1'
coresume task
print count          -- '2'
</code></pre>
<p>Referencing parent variables from the fiber block automatically captures them just like a function closure.</p>
<a href="#concurrency">^topic</a>
<h3 id="pause-and-resume">Pause and resume. <a href="#pause-and-resume">#</a></h3>
<p><code>coyield</code> can be used anywhere in a fiber's call stack to pause execution and return to the previous fiber.</p>
<pre><code class="language-cy">func foo():
    print 'foo'
    bar()

func bar():
    -- Nested coyield in call stack.
    coyield
    print 'bar'

var task = coinit(foo)
coresume task
</code></pre>
<p><code>coresume</code> also returns the resulting value.</p>
<pre><code class="language-cy">func foo():
    return 123

var task = coinit(foo)
print(coresume task)    -- '123'
</code></pre>
<p><code>coyield</code> can return a value back to <code>coresume</code>. <em>Planned Feature</em></p>
<a href="#concurrency">^topic</a>
<h3 id="fiber-state">Fiber state. <a href="#fiber-state">#</a></h3>
<p>Use <code>Fiber.status()</code> to get the current state of the fiber.</p>
<pre><code class="language-cy">func foo():
    coyield
    print 'done'

var task = coinit(foo)
print task.status()   -- '.paused'
coresume task
print task.status()   -- '.paused'
coresume task
print task.status()   -- '.done'
</code></pre>
<p>The main execution context is a fiber as well. Once the main fiber has finished, the VM is done and control is returned to the host.</p>
<a href="#concurrency">^topic</a>
<h2 id="gas-mileage">Gas mileage. <a href="#gas-mileage">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#concurrency">^topic</a>
<h1 id="dynamic-typing">Dynamic Typing. <a href="#dynamic-typing">#</a></h1>
<ul>
<li><a href="#dynamic-variables" title="">Dynamic variables.</a></li>
<li><a href="#runtime-type-checking" title="">Runtime type checking.</a></li>
<li><a href="#dynamic-tables" title="">Dynamic tables.</a></li>
<li><a href="#dynamic-inference" title="">Dynamic inference.</a></li>
</ul>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Dynamic typing is supported with a less restrictive syntax. This can reduce the amount of friction when writing code, but it can also result in more runtime errors.</p>
<p>In Cyber, the <code>dyn</code> keyword is used exclusively for dynamic declarations.</p>
<h2 id="dynamic-variables">Dynamic variables. <a href="#dynamic-variables">#</a></h2>
<p>Variables declared with <code>dyn</code> are implicitly given the <code>dyn</code> type:</p>
<pre><code class="language-cy">dyn a = 123
</code></pre>
<p>Typically a dynamic variable defers type checking to runtime, but if the compiler determines that an operation will always fail at runtime, a compile error is reported instead:</p>
<pre><code class="language-cy">dyn a = '100'

print a / 2
--> CompileError: Can not find the symbol `$infix/` in `String`
</code></pre>
<p>When <code>a</code> is assigned a different type of value, its <strong>recent type</strong> is updated so the compiler can continue to surface errors ahead of time:</p>
<pre><code class="language-cy">a = {1, 2, 3}
print a / 2
--> CompileError: Can not find the symbol `$infix/` in `List`
</code></pre>
<a href="#dynamic-typing">^topic</a>
<h2 id="runtime-type-checking">Runtime type checking. <a href="#runtime-type-checking">#</a></h2>
<p>If the type of a dynamic variable can not be determined at compile-time, type checking is deferred to runtime.</p>
<p>In this example, the type for <code>a</code> is unknown after assigning the return of a dynamic call to <code>erase</code>.
Any operation on <code>a</code> would defer type checking to runtime:</p>
<pre><code class="language-cy">dyn a = erase(123)

print a(1, 2, 3)
--> panic: Expected a function.
</code></pre>
<p>If a dynamic variable's <strong>recent type</strong> differs between two branches of execution, the type is considered unknown after the branches are merged. Any operations on the variable afterwards will defer type checking to runtime:</p>
<pre><code class="language-cy">dyn a = 123
if a > 20:
    a = 'hello'

-- Branches are merged. `a` has an unknown type.

print a(1, 2, 3)
--> panic: Expected a function.
</code></pre>
<a href="#dynamic-typing">^topic</a>
<h2 id="dynamic-tables">Dynamic tables. <a href="#dynamic-tables">#</a></h2>
<p>The builtin <code>Table</code> type is used to create dynamic objects.
Tables are initialized with the record literal:</p>
<pre><code class="language-cy">dyn a = {}
a.name = 'Nova'
print a.name     --> Nova
</code></pre>
<p>Read more about how to use <a href="#tables" title="">Tables</a>.</p>
<a href="#dynamic-typing">^topic</a>
<h2 id="dynamic-inference">Dynamic inference. <a href="#dynamic-inference">#</a></h2>
<p>When the inference tag is used in a dynamic context, it will attempt to resolve its value at runtime.
In this example, the dynamic value <code>a</code> resolves to a <code>String</code> at runtime and invokes the typed method <code>trim</code>.
<code>.left</code> then infers to the correct value at runtime:</p>
<pre><code class="language-cy">print str.trim(.left, ' ')
</code></pre>
<a href="#dynamic-typing">^topic</a>
<h1 id="metaprogramming">Metaprogramming. <a href="#metaprogramming">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#operator-overloading-1" title="">Operator overloading.</a><ul>
<li><a href="#builtin-operators" title="">Builtin operators.</a></li>
<li><a href="#custom-operators" title="">Custom operators.</a></li>
</ul>
</li>
<li><a href="#magic-functions" title="">Magic functions.</a><ul>
<li><a href="#call-module" title="">Call module.</a></li>
<li><a href="#initrecord-method" title=""><code>$initRecord</code> method.</a></li>
<li><a href="#initpair-method" title=""><code>$initPair</code> method.</a></li>
<li><a href="#get-method" title=""><code>$get</code> method.</a></li>
<li><a href="#set-method" title=""><code>$set</code> method.</a></li>
<li><a href="#missing-method" title="">Missing method.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#reflection" title="">Reflection.</a></li>
<li><a href="#attributes" title="">Attributes.</a></li>
<li><a href="#templates" title="">Templates.</a><ul>
<li><a href="#value-templates" title="">Value templates.</a></li>
</ul>
</li>
<li><a href="#macros" title="">Macros.</a></li>
<li><a href="#compile-time-execution" title="">Compile-time execution.</a><ul>
<li><a href="#builtin-types" title="">Builtin types.</a></li>
<li><a href="#builtin-functions" title="">Builtin functions.</a></li>
<li><a href="#builtin-constants" title="">Builtin constants.</a></li>
</ul>
</li>
<li><a href="#runtime-execution" title="">Runtime execution.</a></li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="operator-overloading-1">Operator overloading. <a href="#operator-overloading-1">#</a></h2>
<p>All operators are implemented as object methods.</p>
<blockquote><p><em>Incomplete: Not all operators have transitioned to the method paradigm.</em></p>
</blockquote><p>To overload an operator for an object type, declare <code>$prefix</code>, <code>$infix</code>, <code>$postfix</code> methods. See the available <a href="#builtin-operators" title="">builtin operators</a>. Since operator names aren't allowed as standard identifiers, they are contained in a string literal.</p>
<pre><code class="language-cy">type Vec2:
    x float
    y float

    func '$infix+'(self, o Vec2) Vec2:
        return Vec2{
            x = x + o.x,
            y = y + o.y,
        }

    func '$prefix-'(self) Vec2:
        return Vec2{x=-x, y=-y}

var a = Vec2{x=1, y=2}
var b = a + Vec2{x=3, y=4}
var c = -a
</code></pre>
<p>Some special operators have their own name. This example overloads the <code>index</code> operator and the <code>set index</code> operator:</p>
<pre><code class="language-cy">type MyCollection:
    arr List

    func $index(self, idx):
        return arr[idx * 2]

    func $setIndex(self, idx, val):
        arr[idx * 2] = val 

var a = MyCollection{arr={1, 2, 3, 4}}
print a[1]        -- Prints `3`
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="builtin-operators">Builtin operators. <a href="#builtin-operators">#</a></h3>
<p>A list of all supported operators:</p>
<table><thead><tr><th>Operator</th><th>Name</th></tr></thead><tbody><tr><td>Bitwise not</td><td><code>$prefix~</code></td></tr><tr><td>Minus</td><td><code>$prefix-</code></td></tr><tr><td>Greater</td><td><code>$infix></code></td></tr><tr><td>Greater equal</td><td><code>$infix>=</code></td></tr><tr><td>Less</td><td><code>$infix<</code></td></tr><tr><td>Less equal</td><td><code>$infix<=</code></td></tr><tr><td>Add</td><td><code>$infix+</code></td></tr><tr><td>Subtract</td><td><code>$infix-</code></td></tr><tr><td>Multiply</td><td><code>$infix*</code></td></tr><tr><td>Divide</td><td><code>$infix/</code></td></tr><tr><td>Modulus</td><td><code>$infix%</code></td></tr><tr><td>Power</td><td><code>$infix^</code></td></tr><tr><td>Bitwise and</td><td><code>$infix&</code></td></tr><tr><td>Bitwise or</td><td><code>$infix|</code></td></tr><tr><td>Bitwise xor</td><td><code>$infix||</code></td></tr><tr><td>Bitwise left shift</td><td><code>$infix<<</code></td></tr><tr><td>Bitwise right shift</td><td><code>$infix>></code></td></tr><tr><td>Index</td><td><code>$index</code></td></tr><tr><td>Set index</td><td><code>$setIndex</code></td></tr><tr><td>Slice</td><td><code>$slice</code></td></tr></tbody></table><a href="#metaprogramming">^topic</a>
<h3 id="custom-operators">Custom operators. <a href="#custom-operators">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#metaprogramming">^topic</a>
<h2 id="magic-functions">Magic functions. <a href="#magic-functions">#</a></h2>
<a href="#metaprogramming">^topic</a>
<h3 id="call-module">Call module. <a href="#call-module">#</a></h3>
<p>Declare a <code>$call</code> function to allow invoking a module as a function.</p>
<pre><code class="language-cy">-- Object types are also modules.
type Vec2:
    x float
    y float

func Vec2.$call(x float, y float) Vec2:
    return Vec2{x=x, y=y}

var v = Vec2(1, 2)
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="initrecord-method"><code>$initRecord</code> method. <a href="#initrecord-method">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#metaprogramming">^topic</a>
<h3 id="initpair-method"><code>$initPair</code> method. <a href="#initpair-method">#</a></h3>
<p>The <code>$initPair</code> method overrides the record initializer.
After an instance of the type is created from its default record initializer, this method is invoked for each key-value pair in the record literal:</p>
<pre><code class="language-cy">type MyMap:
    func $initPair(self, key any, value any) void:
        print "$(key) = $(value)"

var m = MyMap{a=123, b=234}
--> a = 123
--> b = 234
</code></pre>
<p><code>$initPair</code> is only allowed if the type has a default record initializer or <code>$initRecord</code> is declared.</p>
<a href="#metaprogramming">^topic</a>
<h3 id="get-method"><code>$get</code> method. <a href="#get-method">#</a></h3>
<p>The <code>$get</code> method allows overriding field accesses for <strong>undeclared fields</strong>:</p>
<pre><code class="language-cy">type Foo:
    func $get(self, name String):
        return name.len()

var f = Foo{}
print f.abc      --> 3
print f.hello    --> 5
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="set-method"><code>$set</code> method. <a href="#set-method">#</a></h3>
<p>The <code>$set</code> method allows overriding field assignments for <strong>undeclared fields</strong>:</p>
<pre><code class="language-cy">type Foo:
    func $set(self, name String, value any):
        print "setting $(name) $(value)"

var f = Foo{}
f.abc = 123      --> setting abc 123
</code></pre>
<a href="#metaprogramming">^topic</a>
<h3 id="missing-method">Missing method. <a href="#missing-method">#</a></h3>
<p>Declare a <code>$missing</code> method as a fallback when a method was not found in an instance.</p>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><pre><code class="language-cy">type A:

    func $missing(self, args...):
        return args.len

var a = A{}
print a.foo()      -- Output: '0'
print a.bar(1, 2)  -- Output: '2'
</code></pre>
<a href="#metaprogramming">^topic</a>
<h2 id="reflection">Reflection. <a href="#reflection">#</a></h2>
<p>A <a href="#type-metatype" title=""><code>type metatype</code></a> object references an internal type. Use the <code>typeof</code> builtin to get the <code>metatype</code> of a value.</p>
<pre><code class="language-cy">var val = 123
print typeof(val)   -- 'type: float'

-- Referencing a type as a value also returns its `metatype`.
print bool          -- 'type: bool'
</code></pre>
<a href="#metaprogramming">^topic</a>
<h2 id="attributes">Attributes. <a href="#attributes">#</a></h2>
<p>Attributes start with <code>@</code>. They are used as declaration modifiers.</p>
<blockquote><p><code>@host</code></p>
<p>Bind a function, variable, or type to the host. See <a href="#libcyber" title="">libcyber</a>.</p>
</blockquote><a href="#metaprogramming">^topic</a>
<h2 id="templates">Templates. <a href="#templates">#</a></h2>
<p>Templates enables parametric polymorphism for types and functions. Template arguments are passed to templates to generate specialized code. This facilitates developing container types and algorithms that operate on different types.</p>
<p>See <a href="#type-templates" title="">Type Declarations / Type templates</a> and <a href="#function-templates" title="">Functions / Function templates</a>.</p>
<a href="#metaprogramming">^topic</a>
<h3 id="value-templates">Value templates. <a href="#value-templates">#</a></h3>
<p>A value template returns a memoized value after being invoked with template arguments at compile-time. It's declared with <code>def</code>:</p>
<pre><code class="language-cy">def StrType[ID String] type:
    if ID == 'bool':
        return bool
    else ID == 'int':
        return int
    else ID == 'String':
        return String
    else
        throw error.Unsupported

var a StrType['int'] = 123
print a         --> 123
</code></pre>
<p>This can be useful to evaluate compile-time logic to create new types or specialize other templates.
Any compile-time compatible type can also be returned.</p>
<a href="#metaprogramming">^topic</a>
<h2 id="macros">Macros. <a href="#macros">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#metaprogramming">^topic</a>
<h2 id="compile-time-execution">Compile-time execution. <a href="#compile-time-execution">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#metaprogramming">^topic</a>
<h3 id="builtin-types">Builtin types. <a href="#builtin-types">#</a></h3>
<p>Builtin types are used internally by the compiler to define it's own primitive types such as <code>bool</code>, <code>int</code>, and <code>float</code>.</p>
<blockquote><p><code>type bool_t</code></p>
</blockquote><blockquote><p><code>type int64_t</code></p>
</blockquote><blockquote><p><code>type float64_t</code></p>
</blockquote><a href="#metaprogramming">^topic</a>
<h3 id="builtin-functions">Builtin functions. <a href="#builtin-functions">#</a></h3>
<blockquote><p><code>func genLabel(name String)</code></p>
<p>Emits a label during codegen for debugging.</p>
</blockquote><a href="#metaprogramming">^topic</a>
<h3 id="builtin-constants">Builtin constants. <a href="#builtin-constants">#</a></h3>
<blockquote><p><code>var modUri String</code></p>
<p>Evaluates to the module's URI as a string. See <a href="#module-uri" title="">Module URI</a>.</p>
</blockquote><a href="#metaprogramming">^topic</a>
<h2 id="runtime-execution">Runtime execution. <a href="#runtime-execution">#</a></h2>
<p><code>cy.eval</code> evaluates source code in an isolated VM.
If the last statement is an expression, a primitive or String can be returned to the caller:</p>
<pre><code class="language-cy">use cy

var res = cy.eval('1 + 2')
print res        --> 3
</code></pre>
<a href="#metaprogramming">^topic</a>
<h1 id="libcyber">libcyber. <a href="#libcyber">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#getting-started" title="">Getting started.</a><ul>
<li><a href="#create-vm" title="">Create VM.</a></li>
<li><a href="#override-print" title="">Override <code>print</code>.</a></li>
<li><a href="#eval-script" title="">Eval script.</a></li>
</ul>
</li>
<li><a href="#module-loader" title="">Module Loader.</a><ul>
<li><a href="#default-module-loader" title="">Default module loader.</a></li>
<li><a href="#bind-functions" title="">Bind functions.</a></li>
<li><a href="#variable-loader" title="">Variable loader.</a></li>
<li><a href="#bind-types" title="">Bind types.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#host-functions" title="">Host functions.</a></li>
<li><a href="#host-types" title="">Host types.</a><ul>
<li><a href="#getchildren" title=""><code>getChildren</code></a></li>
<li><a href="#finalizer-1" title=""><code>finalizer</code></a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p><code>libcyber</code> allows embedding the Cyber compiler and VM into applications. Cyber's core types and the CLI app were built using the library.</p>
<p>The API is defined in the <a href="https://github.com/fubark/cyber/blob/master/src/include/cyber.h" title="">C header file</a>.
The examples shown below can be found in the repository under <a href="https://github.com/fubark/cyber/blob/master/examples/c-embedded" title="">c-embedded</a>. C is used as the host language, but it can be easily translated to C++ or any C-ABI compatible language.</p>
<p>Types and constants from the C-API begin with <code>CL</code> and functions begin with <code>cl</code>.</p>
<h2 id="getting-started">Getting started. <a href="#getting-started">#</a></h2>
<a href="#libcyber">^topic</a>
<h3 id="create-vm">Create VM. <a href="#create-vm">#</a></h3>
<p>Most operations are tied to a VM handle. To create a new VM instance, call <code>clCreate</code>:</p>
<pre><code class="language-c">#include "cyber.h"

int main() {
    CLVM* vm = clCreate();
    // ...
    clDestroy(vm);
    return 0;
}
</code></pre>
<a href="#libcyber">^topic</a>
<h3 id="override-print">Override <code>print</code>. <a href="#override-print">#</a></h3>
<p>The builtin <code>print</code> function does nothing by default, so it needs to be overrided to print to stdout for example:</p>
<pre><code class="language-c">void printer(CLVM* vm, CLStr str) {
    printf("Invoked printer: %.*s\n", (int)str.len, str.buf);
}

int main() {
    // ...
    clSetPrinter(vm, printer);
    // ...
}
</code></pre>
<p>Note that <code>print</code> invokes the printer twice, once for the value's string and another for the new line character.</p>
<a href="#libcyber">^topic</a>
<h3 id="eval-script">Eval script. <a href="#eval-script">#</a></h3>
<p><code>clEval</code> compiles and evaluates a script:</p>
<pre><code class="language-c">CLStr src = STR(
    "var a = 1\n"
    "print(a + 2)\n"
);

CLValue val;
CLResultCode res = clEval(vm, src, &val);
if (res == CL_SUCCESS) {
    printf("Success!\n");
    clRelease(vm, val);
} else {
    CLStr report = clNewLastErrorReport(vm);
    printf("%s\n", report);
    clFree(vm, report);
}
</code></pre>
<p>If a value is returned from the main block of the script, it's saved to the result value argument.
Memory is managed by ARC so a value that points to a heap object requires a <code>clRelease</code> when it's no longer needed.</p>
<p><code>clEval</code> returns a result code that indicates whether it was successful.</p>
<a href="#libcyber">^topic</a>
<h2 id="module-loader">Module Loader. <a href="#module-loader">#</a></h2>
<p>A module loader describes how a module is loaded when <code>use</code> import statement is encountered during script execution.
Only one module loader can be active and is set using <code>clSetModuleLoader</code>:</p>
<pre><code class="language-c">bool modLoader(CLVM* vm, CLStr spec, CLModule* res) {
    if (strncmp("my_mod", spec.buf, spec.len) == 0) {
        CLStr src = STR(
            "@host func add(a float, b float) float\n"
            "@host var .MyConstant float\n"
            "@host var .MyList     List[dyn]\n"
            "\n"
            "@host\n"
            "type MyNode _:\n"
            "    @host func asList(self) any"
            "\n"
            "@host func MyNode.new(a any, b any) MyNode\n"
        );
        *res = clCreateModule(vm, spec, src);
        CLModuleConfig config = (CLModuleConfig){
            .funcs = (CLSlice){ .ptr = funcs, .len = 3 },
            .types = (CLSlice){ .ptr = types, .len = 1 },
            .varLoader = varLoader,
        };
        clSetModuleConfig(vm, *res, &config);
        return true;
    } else {
        // Fallback to the default module loader to load `core`.
        return clDefaultModuleLoader(vm, spec, out);
    }
}

int main() {
    //...
    clSetModuleLoader(vm, modLoader);
    //...
}
</code></pre>
<p>The above example checks whether "my_mod" was imported and returns it's source code. Additional loaders are returned to load the functions, variables, and types from the source code.</p>
<a href="#libcyber">^topic</a>
<h3 id="default-module-loader">Default module loader. <a href="#default-module-loader">#</a></h3>
<p>Since only one module loader can be set to the VM instance, a custom loader is required to handle the "core" import which contains all of the core types and functions in Cyber. This can simply be delegated to <code>clDefaultModuleLoader</code>.</p>
<a href="#libcyber">^topic</a>
<h3 id="bind-functions">Bind functions. <a href="#bind-functions">#</a></h3>
<p>An array of function definitions can be assigned to <code>CLModuleConfig.funcs</code>.
When a <code>@host</code> function is encountered by the compiler, it will use this mapping to find the correct function pointer:</p>
<pre><code class="language-c">CLHostFuncEntry funcs[] = {
    CL_FUNC("add",           add),
    CL_FUNC("MyNode.asList", myNodeAsList),
    CL_FUNC("MyNode.new",    myNodeNew),
};
</code></pre>
<p>A fallback function loader can be assigned to <code>CLModuleConfig.func_loader</code>.
It's invoked if a function could not be found in <code>CLModuleConfig.funcs</code>.</p>
<pre><code class="language-c">bool funcLoader(CLVM* vm, CLFuncInfo info, CLFuncResult* out) {
    // Check that the name matches before setting the function pointer.
    if (strncmp("missing_func", info.name.buf, info.name.len) == 0) {
        out->ptr = myMissingFunc;
        return true;
    } else {
        return false;
    }
}
</code></pre>
<a href="#libcyber">^topic</a>
<h3 id="variable-loader">Variable loader. <a href="#variable-loader">#</a></h3>
<p>A variable loader describes how to load a <code>@host</code> variable when it's encountered by the compiler:</p>
<pre><code class="language-c">// C has limited static initializers (and objects require a vm instance) so initialize them in `main`.
typedef struct { char* n; CLValue v; } NameValue;
NameValue vars[2];

bool varLoader(CLVM* vm, CLVarInfo info, CLValue* out) {
    // Check that the name matches before setting the value.
    if (strncmp(vars[info.idx].n, info.name.buf, info.name.len) == 0) {
        // Objects are consumed by the module.
        *out = vars[info.idx].v;
        return true;
    } else {
        return false;
    }
}

int main() {
    // ...

    // Initialize var array for loader.
    vars[0] = (NameValue){".MyConstant", clFloat(1.23)};
    CLValue myInt = clInteger(123);
    vars[1] = (NameValue){".MyList", clNewList(vm, &myInt, 1)};

    // ...
}
</code></pre>
<p>This example uses the same technique as the function loader, but it can be much simpler. It doesn't matter how the mapping is done as long as the variable loader returns a <code>CLValue</code>.</p>
<a href="#libcyber">^topic</a>
<h3 id="bind-types">Bind types. <a href="#bind-types">#</a></h3>
<p>An array of type definitions can be assigned to <code>CLModuleConfig.types</code>.
When a <code>@host</code> type is encountered by the compiler, it will use this mapping to initialize the type:</p>
<pre><code class="language-c">CLTypeId myNodeId;

CLHostTypeEntry types[] = {
    CL_CUSTOM_TYPE("MyNode", &myNodeId, myNodeGetChildren, myNodeFinalizer),
};
</code></pre>
<p>When binding to the "MyNode" type, it's type id is saved to <code>myNodeId</code>. This id is then used to create new instances of this type. See <a href="#host-types" title="">Host types</a>.</p>
<p>A fallback type loader can be assigned to <code>CLModuleConfig.type_loader</code>.
It's invoked if a type could not be found in <code>CLModuleConfig.types</code>.</p>
<pre><code class="language-c">bool typeLoader(CLVM* vm, CLTypeInfo info, CLTypeResult* out) {
    if (strncmp("MissingType", info.name.buf, info.name.len) == 0) {
        out->type = CS_TYPE_OBJECT;
        out->data.object.outTypeId = &myNodeId;
        out->data.object.getChildren = myNodeGetChildren;
        out->data.object.finalizer = myNodeFinalizer;
        return true;
    } else {
        return false;
    }
}
</code></pre>
<a href="#libcyber">^topic</a>
<h2 id="host-functions">Host functions. <a href="#host-functions">#</a></h2>
<p>A host function requires a specific function signature:</p>
<pre><code class="language-c">CLValue add(CLVM* vm, const CLValue* args, uint8_t nargs) {
    double res = clAsFloat(args[0]) + clAsFloat(args[1]);
    return clFloat(res);
}
</code></pre>
<p>A host function should always return a <code>CLValue</code>. <code>clNone()</code> can be returned if the function does not intend to return any value.</p>
<a href="#libcyber">^topic</a>
<h2 id="host-types">Host types. <a href="#host-types">#</a></h2>
<p>A host type are types that are opaque to Cyber scripts but still behave like an object. They can have type functions and methods.</p>
<p>Only the host application can directly create new instances of them, so usually a function is binded to expose a constructor to the user script:</p>
<pre><code class="language-c">// Binding a C struct with it's own children and finalizer.
// This struct retains 2 VM values and has 2 arbitrary data values unrelated to the VM.
typedef struct MyNode {
    CLValue val1;
    CLValue val2;
    int a;
    double b;
} MyNode;

// Implement the `new` function in MyNode.
CLValue myNodeNew(CLVM* vm, const CLValue* args, uint8_t nargs) {
    // Instantiate our object.
    CLValue new = clNewHostObject(vm, myNodeId, sizeof(MyNode));
    MyNode* my = (MyNode*)clAsHostObject(new);

    // Assign the constructor args passed in and retain them since the new object now references them.
    clRetain(vm, args[0]);
    my->val1 = args[0];
    clRetain(vm, args[1]);
    my->val2 = args[1];

    // Assign non VM values.
    my->a = 123;
    my->b = 9999.999;
    return new;
}
</code></pre>
<p><code>clNewHostObject</code> takes the type id (returned from the <a href="#bind-types" title="">Type loader</a>) and size (in bytes) and returns a new heap object. Note that the size is allowed to vary. Different instances of the same type can occupy different amounts of memory.</p>
<a href="#libcyber">^topic</a>
<h3 id="getchildren"><code>getChildren</code> <a href="#getchildren">#</a></h3>
<p>Since <code>MyNode</code> contains <code>CLValue</code> children, the <a href="#bind-types" title="">Type loader</a> requires a <code>getChildren</code> callback so that memory management can reach them:</p>
<pre><code class="language-c">CLValueSlice myNodeGetChildren(CLVM* vm, void* obj) {
    MyNode* my = (MyNode*)obj;
    return (CLValueSlice){ .ptr = &my->val1, .len = 2 };
}
</code></pre>
<a href="#libcyber">^topic</a>
<h3 id="finalizer-1"><code>finalizer</code> <a href="#finalizer-1">#</a></h3>
<p>A type finalizer is optional since the memory and children of an instance will be freed automatically by ARC.
However, it can be useful to perform additional cleanup tasks for instances that contain external resources.</p>
<pre><code class="language-c">void myNodeFinalizer(CLVM* vm, void* obj) {
    printf("MyNode finalizer was called.\n");
}
</code></pre>
<a href="#libcyber">^topic</a>
<h1 id="memory">Memory. <a href="#memory">#</a></h1>
<table><tr>
<td valign="top">
<ul>
<li><a href="#structured-memory" title="">Structured memory.</a><ul>
<li><a href="#value-ownership" title="">Value ownership.</a></li>
<li><a href="#copy-semantics" title="">Copy semantics.</a></li>
<li><a href="#cloning" title="">Cloning.</a></li>
<li><a href="#moving" title="">Moving.</a></li>
<li><a href="#references" title="">References.</a></li>
<li><a href="#exclusive-reference" title="">Exclusive reference.</a></li>
<li><a href="#self-reference" title=""><code>self</code> reference.</a></li>
<li><a href="#lifted-values" title="">Lifted values.</a></li>
<li><a href="#deferred-references" title="">Deferred references.</a></li>
<li><a href="#implicit-lifetimes" title="">Implicit lifetimes.</a></li>
<li><a href="#explicit-reference-lifetimes" title="">Reference lifetimes.</a></li>
<li><a href="#shared-ownership" title="">Shared ownership.</a></li>
<li><a href="#deinitializer" title="">Deinitializer.</a></li>
<li><a href="#pointer-interop" title="">Pointer interop.</a></li>
</ul>
</li>
</ul>
</td><td valign="top">
<ul>
<li><a href="#automatic-memory" title="">Automatic memory.</a><ul>
<li><a href="#arc" title="">ARC.</a></li>
<li><a href="#object-destructor" title="">Object destructor.</a></li>
<li><a href="#retain-optimizations" title="">Retain optimizations.</a></li>
<li><a href="#closures-1" title="">Closures.</a></li>
<li><a href="#fibers-1" title="">Fibers.</a></li>
<li><a href="#heap-objects" title="">Heap objects.</a></li>
<li><a href="#gc" title="">GC.</a></li>
</ul>
</li>
<li><a href="#manual-memory" title="">Manual memory.</a><ul>
<li><a href="#memory-allocations" title="">Memory allocations.</a></li>
<li><a href="#runtime-memory-checks" title="">Runtime memory checks.</a></li>
</ul>
</li>
</ul>
</td>
</tr></table>
<p><a href="#table-of-contents" title="">^top</a></p>
<p>Cyber provides memory safety by default with structured and automatic memory.
Manual memory is also supported but discouraged.</p>
<h2 id="structured-memory">Structured memory. <a href="#structured-memory">#</a></h2>
<p><em>Structured memory is very much incomplete. It will be centered around single value ownership but the semantics are subject to change.</em>
Cyber uses single value ownership and variable scopes to determine the lifetime of values and references.
When lifetimes are known at compile-time, the memory occupied by values do not need to be manually managed which prevents memory bugs such as:</p>
<ul>
<li>Use after free.</li>
<li>Use after invalidation.</li>
<li>Free with wrong allocator.</li>
<li>Double free.</li>
<li>Memory leaks.</li>
<li>Null pointer dereferencing.</li>
</ul>
<p>At the same time, structured memory allows performant code to be written since it provides safe semantics to directly reference values and child values.
These safety features are guaranteed for debug and optimized builds with no additional runtime cost.</p>
<a href="#memory">^topic</a>
<h3 id="value-ownership">Value ownership. <a href="#value-ownership">#</a></h3>
<p>Every value in safe memory has a single owner.
An owner can be a variable that binds to a value. Otherwise, the owner can be a parent value or the value itself.
The owner is responsible for deinitializing or dropping the value when it has gone out of scope (no longer reachable).
For example, at the end of the block, a variable can no longer be accessed so it drops the value that it owns:</p>
<pre><code class="language-cy">var a = 123
print a    --> 123
-- Deinit `a`.
</code></pre>
<p>In this case, there is nothing to deinitialize since the value is an integer.</p>
<p>If the value was a <code>String</code>, the deinit logic would release (-1) on a reference counted byte buffer since strings are just immutable views over byte buffers:</p>
<pre><code class="language-cy">var a = 'hello'
print a    --> hello
-- Deinit `a`.
-- `a.buf` is released.
-- `a.buf` is freed.
</code></pre>
<p>Since the string buffer's reference count reaches 0, it's freed as well.</p>
<p>Finally, let's take a look at <code>ListValue</code> which manages a dynamically sized array of elements:</p>
<pre><code class="language-cy">var a = ListValue[int]{1, 2, 3}
print a    --> {1, 2, 3}
-- Deinit `a`.
-- `a.buf` is freed.
</code></pre>
<p>When <code>a</code> is deinitialized, the buffer that holds the 3 integer elements is freed.
You may have surmised that it's named <code>ListValue</code> because it's a value type (it can only be passed around by copying itself). The object type, <a href="#lists" title=""><code>List</code></a>, wraps <code>ListValue</code> and can be passed around by reference.</p>
<p>The concept of a value having a single owner is very simple yet powerful.
A value can represent any data structure from primitives to dynamically allocated buffers.
A value always knows <strong>how</strong> to deinitialize itself, and the owner knows <strong>when</strong> to deinitialize the value.
Later, we'll see that this same concept also applies to <a href="#shared-ownership" title="">shared ownership</a>.</p>
<a href="#memory">^topic</a>
<h3 id="copy-semantics">Copy semantics. <a href="#copy-semantics">#</a></h3>
<p>By default, values are passed around by copying (shallow copying), but not all values can perform a copy.</p>
<p>A primitive, such as an integer, can always be copied:</p>
<pre><code class="language-cy">var a = 123
var b = a
-- Deinit `b`.
-- Deinit `a`.
</code></pre>
<p>After a copy, a new value is created and given the owner of <code>b</code>. At the end of the block, both <code>a</code> and <code>b</code> are deinitialized (which does nothing since they are just primitives).</p>
<p>Strings are also copyable since they are immutable views over byte buffers:</p>
<pre><code class="language-">var a = 'hello'
var b = a
-- Deinit `b`.
-- `b.buf` is released.
-- Deinit `a`.
-- `a.buf` is released.
-- `a.buf` is freed.
</code></pre>
<p>The copy <code>b</code> also reuses the byte buffer of <code>a</code> by retaining (+1) on the reference counted byte buffer. The byte buffer is finally freed once there are no references pointing to it.</p>
<p>Unlike the integer and string, a <code>ListValue</code> can not be copied since doing so requires duping a heap allocated buffer which is considered expensive:</p>
<pre><code class="language-cy">var a = ListValue[int]{1, 2, 3}
var b = a      --> error: Can not copy `ListValue`. Can only be cloned or moved.
</code></pre>
<p>Instead <code>a</code> can only be <a href="#cloned" title="">cloned</a> or <a href="#moving" title="">moved</a>.</p>
<p>By default, a declared value type is copyable if all of it's members are also copyable:</p>
<pre><code class="language-cy">type Foo struct:
    a int
    b String

var a = Foo{a=123, b='hello'}
var b = a
</code></pre>
<p>Since integers and strings are both copyable, <code>Foo</code> is also copyable.</p>
<p><code>Foo</code> is non-copyable if it contains at least one non-copyable member:</p>
<pre><code class="language-cy">type Foo struct:
    a int
    b String
    c ListValue[int]

var a = Foo{a=123, b='hello'}
var b = a      --> error: Can not copy `Foo`. Can only be moved.
</code></pre>
<p><code>Foo</code> is also non-copyable if it contains unsafe types such as pointers or pointer slices:</p>
<pre><code class="language-cy">type Foo struct:
    a int
    b String
    c *Bar
    d [*]float
</code></pre>
<p><code>Foo</code> can implement <code>Copyable</code> to override the default behavior and define it's own copy logic:</p>
<pre><code class="language-cy">type Foo struct:
    with Copyable
    a int
    b String
    c *Bar
    d [*]float

    func copy(self) Foo:
        return .{
            a = self.a,
            b = self.b,
            c = self.c,
            d = self.d,
        }
</code></pre>
<p>Likewise, <code>Foo</code> can implement <code>NonCopyable</code> which indicates that it can never be copied:</p>
<pre><code class="language-cy">type Foo struct:
    with NonCopyable
    a int
    b String
</code></pre>
<a href="#memory">^topic</a>
<h3 id="cloning">Cloning. <a href="#cloning">#</a></h3>
<p>Some value types are not allowed to be copied by default and must be cloned instead:</p>
<pre><code class="language-cy">var a = ListValue[int]{1, 2, 3}
var b = a.clone()
</code></pre>
<p>Any <code>Copyable</code> type is also <code>Cloneable</code>. For example, performing a clone on an integer will simply perform a copy:</p>
<pre><code class="language-cy">var a = 123
var b = a.clone()
</code></pre>
<p>A value type can implement <code>Cloneable</code> to override the default behavior and define it's own clone logic:</p>
<pre><code class="language-cy">type Foo struct:
    with Cloneable
    a int
    b String

    func clone(self) Foo:
        return .{
            a = self.a + 1,
            b = self.b,
        }
</code></pre>
<p>Likewise, <code>Foo</code> can implement <code>NonCloneable</code> which indicates that it can never be cloned:</p>
<pre><code class="language-cy">type Foo struct:
    with NonCloneable
    a int
    b String
</code></pre>
<a href="#memory">^topic</a>
<h3 id="moving">Moving. <a href="#moving">#</a></h3>
<p>Values can be moved, thereby transfering ownership from one variable to another:</p>
<pre><code class="language-cy">var a = 123
var b = move a
print a     --> error: `a` does not own a value.
</code></pre>
<p>Some types such as <code>ListValue</code> can not be passed around by default without moving (or cloning) the value:</p>
<pre><code class="language-cy">var a = ListValue[int]{1, 2, 3}
print computeSum(move a)    --> 6
</code></pre>
<p>In this case, the list value is moved into the <code>computeSum</code> function, so the list is deinitialized in the function before the function returns.</p>
<a href="#memory">^topic</a>
<h3 id="references">References. <a href="#references">#</a></h3>
<p>References are safe pointers to values.
Unlike unsafe pointers, a reference is never concerned with when to free or deinitialize a value since that responsibility always belongs to the value's owner.
They are considered safe pointers because they are guaranteed to point to their values and never outlive the lifetime of their values.</p>
<p>References grant <strong>in-place mutability</strong> which allows a value to be modified as long as it does not invalidate other references.
<strong>Multiple</strong> references can be alive at once as long as an <a href="#exclusive-reference" title="">exclusive reference</a> is not also alive.</p>
<p>The <code>&</code> operator is used to obtain a reference to a value:</p>
<pre><code class="language-cy">var a = 123
var ref = &a
ref.* = 234
print a        --> 234
</code></pre>
<p>A reference can not outlive the value it's referencing:</p>
<pre><code class="language-cy">var a = 123
var ref = &a
if true:
    var b = 234
    ref = &b   --> error: `ref` can not outlive `b`.
</code></pre>
<p>A reference type is denoted as <code>&T</code> where <code>T</code> is the type that the reference points to:</p>
<pre><code class="language-cy">var a = 123

func inc(a &int):
    a.* = a.* + 1
</code></pre>
<p>References allow in-place mutation:</p>
<pre><code class="language-cy">var a = ListValue[int]{1, 2, 3}
var third = &a[2]
third.* = 300
print a        --> {1, 2, 300}
</code></pre>
<p>The element that <code>third</code> points to can be mutated because it does not invalidate other references.</p>
<p>References however can not perform an unstable mutation.
An unstable mutation requires an exclusive reference:</p>
<pre><code class="language-cy">var a = ListValue[int]{1, 2, 3}
var ref = &a
ref.append(4)  --> error: Expected exclusive reference.
</code></pre>
<a href="#memory">^topic</a>
<h3 id="exclusive-reference">Exclusive reference. <a href="#exclusive-reference">#</a></h3>
<p>An exclusive reference grants <strong>full mutability</strong> which allows a value to be modified even if could potentially invalidate unsafe pointers.</p>
<p>A <strong>single</strong> exclusive reference can be alive as long as no other references are also alive.
Since no other references (safe pointers) are allowed to be alive at the same time, no references can become invalidated.</p>
<p>The <code>&!</code> operator is used to obtain an exclusive reference to a value.
An exclusive reference type is denoted as <code>&!T</code> where <code>T</code> is the type that the reference points to.</p>
<p><code>ListValue</code> is an example of a type that requires an exclusive reference for operations that can resize or reallocate its dynamic buffer:</p>
<pre><code class="language-cy">var a = ListValue[int]{1, 2, 3}
a.append(4)
print a        --> {1, 2, 3, 4}
</code></pre>
<p>Note that invoking the method <code>append</code> here automatically obtains an exclusive reference for <code>self</code> without an explicit <code>&!</code> operator.</p>
<p>If another reference is alive before <code>append</code>, the compiler will not allow an exclusive reference to be obtained from <code>a</code>.
Doing so would allow <code>append</code> to potentially reallocate its dynamic buffer, thereby invalidating other references:</p>
<pre><code class="language-cy">var a = ListValue[int]{1, 2, 3}
var third = &a[2]
a.append(4)    --> error: Can not obtain exclusive reference, `third` is still alive.
print third
</code></pre>
<a href="#memory">^topic</a>
<h3 id="self-reference"><code>self</code> reference. <a href="#self-reference">#</a></h3>
<p>By default <code>self</code> has a type of <code>&T</code> when declared in a value <code>T</code>'s method:</p>
<pre><code class="language-cy">type Pair struct:
    a int
    b int

    func sum(self) int:
        return self.a + self.b
</code></pre>
<p>If <code>self</code> requires an exclusive reference, then it must be prepended with <code>!</code>:</p>
<pre><code class="language-cy">type Pair struct:
    a int
    b int

    func sum(!self) int:
        return self.a + self.b
</code></pre>
<p>Invoking methods automatically obtains the correct reference as specified by the method:</p>
<pre><code class="language-cy">var p = Pair{a=1, b=2}
print p.sum()     --> 3
</code></pre>
<a href="#memory">^topic</a>
<h3 id="lifted-values">Lifted values. <a href="#lifted-values">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="deferred-references">Deferred references. <a href="#deferred-references">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="implicit-lifetimes">Implicit lifetimes. <a href="#implicit-lifetimes">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="reference-lifetimes">Reference lifetimes. <a href="#reference-lifetimes">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="shared-ownership">Shared ownership. <a href="#shared-ownership">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="deinitializer">Deinitializer. <a href="#deinitializer">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="pointer-interop">Pointer interop. <a href="#pointer-interop">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h2 id="automatic-memory">Automatic memory. <a href="#automatic-memory">#</a></h2>
<p>Cyber uses an ARC/GC hybrid to automatically manage objects instantiated from object types. Value types typically do not need to be automatically managed unless they were lifted by a <a href="#closures-1" title="">closure</a> or a dynamic container.</p>
<a href="#memory">^topic</a>
<h3 id="arc">ARC. <a href="#arc">#</a></h3>
<p>ARC also known as automatic reference counting is deterministic and has less overhead compared to a tracing garbage collector. Reference counting distributes memory management, which reduces GC pauses and makes ARC suitable for realtime applications. One common issue in ARC implementations is reference cycles which Cyber addresses with a <a href="#gc" title="">GC</a> supplement when it is required.</p>
<p>Objects are managed by ARC. Each object has its own reference counter. Upon creating a new object, it receives a reference count of 1. When the object is copied, it's <strong>retained</strong> and the reference count increments by 1. When an object value is removed from it's parent or is no longer reachable in the current stack frame, it is <strong>released</strong> and the reference count decrements by 1.</p>
<p>Once the reference count reaches 0 the object begins its <a href="#object-destructor" title="">destruction</a> procedure.</p>
<a href="#memory">^topic</a>
<h3 id="object-destructor">Object destructor. <a href="#object-destructor">#</a></h3>
<p>An object's destructor invoked from ARC performs the following in order:</p>
<ol>
<li>Release child references thereby decrementing their reference counts by 1. If any child reference counts reach 0, their destructors are invoked.</li>
<li>If the object has a finalizer, it's invoked.</li>
<li>The object is freed from memory.</li>
</ol>
<p>If the destructor is invoked by the GC instead of ARC, cyclable child references are not released in step 1.
Since objects freed by the GC either belongs to a reference cycle or branched from one, the GC will still end up invoking the destructor of all unreachable objects.
This implies that the destructor order is not reliable, but destructors are guaranteed to be invoked for all unreachable objects.</p>
<a href="#memory">^topic</a>
<h3 id="retain-optimizations">Retain optimizations. <a href="#retain-optimizations">#</a></h3>
<p>When the lifetime of an object's reference is known on the stack, a large amount of retain/release ops can be avoided.
For example, calling a function with an object doesn't need a retain since it is guaranteed to be alive when the function returns.
This leaves only cases where an object must retain to ensure correctness such as escaping the stack.</p>
<p>When using dynamic types, the compiler can omit retain/release ops when it can infer the actual type even though they are dynamically typed to the user.</p>
<a href="#memory">^topic</a>
<h3 id="closures-1">Closures. <a href="#closures-1">#</a></h3>
<p>When primitive variables are captured by a <a href="#closures" title="">closure</a>, they are boxed and allocated on the heap. This means they are managed by ARC and cleaned up when there are no more references to them.</p>
<a href="#memory">^topic</a>
<h3 id="fibers-1">Fibers. <a href="#fibers-1">#</a></h3>
<p><a href="#fibers" title="">Fibers</a> are freed by ARC just like any other object. Once there are no references to the fiber, it begins to release it's child references by unwinding it's call stack.</p>
<a href="#memory">^topic</a>
<h3 id="heap-objects">Heap objects. <a href="#heap-objects">#</a></h3>
<p>Many object types are small enough to be at or under 40 bytes. To take advantage of this, object pools are reserved to quickly allocate and free these small objects with very little bookkeeping. Bigger objects are allocated and managed by <code>mimalloc</code> which has proven to be a fast and reliable general-purpose heap allocator.</p>
<a href="#memory">^topic</a>
<h3 id="gc">GC. <a href="#gc">#</a></h3>
<p>The garbage collector is only used if the program may contain objects that form reference cycles. This property is statically determined by the compiler. Since ARC frees most objects, the GC's only responsibility is to free abandoned objects that form reference cycles.
This reduces the amount of work for GC marking since only cyclable objects (objects that may contain a reference cycle) are considered.</p>
<p>Weak references are not supported for object types because objects are intended to behave like GC objects (the user should not be concerned with reference cycles). If weak references do get supported in the future, they will be introduced as a <code>Weak[T]</code> type that is used with an explicit reference counted <code>Rc[T]</code> type.</p>
<p>Currently, the GC can be manually invoked. However, the plan is for this to be automatic by either running in a separate thread or per virtual thread by running the GC incrementally.</p>
<p>To invoke the GC, call the builtin function: <code>performGC</code>. <em>Incomplete Feature: Only the main fiber stack is cleaned up at the moment.</em></p>
<pre><code class="language-cy">func foo():
    -- Create a reference cycle.
    var a = {_}
    var b = {_}
    a.append(b)
    b.append(a)

    -- Cycle still alive in the current stack so no cleanup is done.
    var res = performGC()
    print res['numCycFreed']    -- Output: 0
    print res['numObjFreed']    -- Output: 0

foo()
-- `a` and `b` are no longer reachable, so the GC does work.
var res = performGC()
print res['numCycFreed']      -- Output: 2
print res['numObjFreed']      -- Output: 2
</code></pre>
<a href="#memory">^topic</a>
<h2 id="manual-memory">Manual memory. <a href="#manual-memory">#</a></h2>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="memory-allocations">Memory allocations. <a href="#memory-allocations">#</a></h3>
<blockquote><p><em>Planned Feature</em></p>
</blockquote><a href="#memory">^topic</a>
<h3 id="runtime-memory-checks">Runtime memory checks. <a href="#runtime-memory-checks">#</a></h3>
<p><em>Planned Feature</em>
When runtime memory checks are enabled, the compiler will insert traps and runtime logic to prevent the following unsafe uses of pointers and memory allocations:</p>
<ul>
<li>Use after free.</li>
<li>Double free.</li>
<li>Out of bounds memory access.</li>
<li>Null pointer access.</li>
<li>Misaligned pointer access.</li>
<li>Unfreed memory.</li>
</ul>
<p>With these checks in place, using manual memory will be much less error prone at the cost of some runtime performance and memory cost. Pointers will occupy an extra word size and the runtime will maintain an allocation table that contains the raw pointer and metadata.</p>
<a href="#memory">^topic</a>
<h1 id="cli">CLI. <a href="#cli">#</a></h1>
<ul>
<li><a href="#basic-commands" title="">Basic commands.</a></li>
<li><a href="#repl" title="">REPL.</a></li>
<li><a href="#jit-compiler" title="">JIT compiler.</a></li>
<li><a href="#c-backend" title="">C backend.</a></li>
</ul>
<p><a href="#table-of-contents" title="">^top</a></p>
<h2 id="basic-commands">Basic commands. <a href="#basic-commands">#</a></h2>
<p>To compile and run a program with the VM, provide the path to the main Cyber source file:</p>
<pre><code class="language-bash">cyber foo.cy
cyber path/to/main.cy
</code></pre>
<p>To see more options and commands, print the help screen:</p>
<pre><code class="language-bash">cyber help

# These are aliases to the help command.
cyber -h
cyber --help
</code></pre>
<a href="#cli">^topic</a>
<h2 id="repl">REPL. <a href="#repl">#</a></h2>
<p>The REPL is started by running the CLI without any arguments:</p>
<pre><code class="language-bash">cyber
</code></pre>
<p>The REPL starts new sessions with <a href="#use-global" title=""><code>use $global</code></a>. This allows undeclared variables to be used similar to other dynamic languages:</p>
<pre><code class="language-bash">> a = 123
> a * 2
`int` 246
</code></pre>
<p>When the first input ends with <code>:</code>, the REPL will automatically indent the next line. To recede the indentation, provide an empty input. Once the indent returns to the beginning, the entire code block is submitted for evaluation:</p>
<pre><code class="language-bash">> if true:
    | print 'hello!'
    | 
hello!
</code></pre>
<p>Top level declarations such as imports, types, and functions can be referenced in subsequent evals:</p>
<pre><code class="language-bash">> use math
> math.random()
`float` 0.3650744641604983
</code></pre>
<pre><code class="language-bash">> type Foo:
    | a int
    |
> f = Foo{a=123}
> f.a
`int` 123
</code></pre>
<p>Local variables <strong>can not</strong> be referenced in subsequent evals, since their scope ends with each eval input:</p>
<pre><code class="language-bash">> var a = 123
> a
panic: Variable is not defined in `$global`.

input:1:1 main:
a
^
</code></pre>
<a href="#cli">^topic</a>
<h2 id="jit-compiler">JIT compiler. <a href="#jit-compiler">#</a></h2>
<p>Cyber's just-in-time compiler is incomplete and unstable. To run your script with JIT enabled:</p>
<pre><code class="language-bash">cyber -jit &lt;script&gt;
</code></pre>
<p>The goal of the JIT compiler is to be fast at compilation while still being significantly faster than the interpreter. The codegen involves stitching together pregenerated machine code that targets the same runtime stack slots used by the VM. This technique is also known as <code>copy-and-patch</code>. As the VM transitions to unboxed data types, the generated code will see more performance gains.</p>
<a href="#cli">^topic</a>
<h2 id="c-backend">C backend. <a href="#c-backend">#</a></h2>
<p>The C backend generates a static binary from Cyber source code by first transpiling to C code and relying on a C compiler to produce the final executable.
The user can specify the system's <code>cc</code> compiler or the builtin <code>tinyc</code> compiler that is bundled with the CLI.
<em>This is currently in progress.</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>

</main>
<script>/*!
  Highlight.js v11.9.0 (git: b7ec4bfafc)
  (c) 2006-2023 undefined and other contributors
  License: BSD-3-Clause
 */
var hljs=function(){"use strict";function e(t){
return t instanceof Map?t.clear=t.delete=t.set=()=>{
throw Error("map is read-only")}:t instanceof Set&&(t.add=t.clear=t.delete=()=>{
throw Error("set is read-only")
}),Object.freeze(t),Object.getOwnPropertyNames(t).forEach((n=>{
const i=t[n],s=typeof i;"object"!==s&&"function"!==s||Object.isFrozen(i)||e(i)
})),t}class t{constructor(e){
void 0===e.data&&(e.data={}),this.data=e.data,this.isMatchIgnored=!1}
ignoreMatch(){this.isMatchIgnored=!0}}function n(e){
return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#x27;")
}function i(e,...t){const n=Object.create(null);for(const t in e)n[t]=e[t]
;return t.forEach((e=>{for(const t in e)n[t]=e[t]})),n}const s=e=>!!e.scope
;class o{constructor(e,t){
this.buffer="",this.classPrefix=t.classPrefix,e.walk(this)}addText(e){
this.buffer+=n(e)}openNode(e){if(!s(e))return;const t=((e,{prefix:t})=>{
if(e.startsWith("language:"))return e.replace("language:","language-")
;if(e.includes(".")){const n=e.split(".")
;return[`${t}${n.shift()}`,...n.map(((e,t)=>`${e}${"_".repeat(t+1)}`))].join(" ")
}return`${t}${e}`})(e.scope,{prefix:this.classPrefix});this.span(t)}
closeNode(e){s(e)&&(this.buffer+="</span>")}value(){return this.buffer}span(e){
this.buffer+=`<span class="${e}">`}}const r=(e={})=>{const t={children:[]}
;return Object.assign(t,e),t};class a{constructor(){
this.rootNode=r(),this.stack=[this.rootNode]}get top(){
return this.stack[this.stack.length-1]}get root(){return this.rootNode}add(e){
this.top.children.push(e)}openNode(e){const t=r({scope:e})
;this.add(t),this.stack.push(t)}closeNode(){
if(this.stack.length>1)return this.stack.pop()}closeAllNodes(){
for(;this.closeNode(););}toJSON(){return JSON.stringify(this.rootNode,null,4)}
walk(e){return this.constructor._walk(e,this.rootNode)}static _walk(e,t){
return"string"==typeof t?e.addText(t):t.children&&(e.openNode(t),
t.children.forEach((t=>this._walk(e,t))),e.closeNode(t)),e}static _collapse(e){
"string"!=typeof e&&e.children&&(e.children.every((e=>"string"==typeof e))?e.children=[e.children.join("")]:e.children.forEach((e=>{
a._collapse(e)})))}}class c extends a{constructor(e){super(),this.options=e}
addText(e){""!==e&&this.add(e)}startScope(e){this.openNode(e)}endScope(){
this.closeNode()}__addSublanguage(e,t){const n=e.root
;t&&(n.scope="language:"+t),this.add(n)}toHTML(){
return new o(this,this.options).value()}finalize(){
return this.closeAllNodes(),!0}}function l(e){
return e?"string"==typeof e?e:e.source:null}function g(e){return h("(?=",e,")")}
function u(e){return h("(?:",e,")*")}function d(e){return h("(?:",e,")?")}
function h(...e){return e.map((e=>l(e))).join("")}function f(...e){const t=(e=>{
const t=e[e.length-1]
;return"object"==typeof t&&t.constructor===Object?(e.splice(e.length-1,1),t):{}
})(e);return"("+(t.capture?"":"?:")+e.map((e=>l(e))).join("|")+")"}
function p(e){return RegExp(e.toString()+"|").exec("").length-1}
const b=/\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./
;function m(e,{joinWith:t}){let n=0;return e.map((e=>{n+=1;const t=n
;let i=l(e),s="";for(;i.length>0;){const e=b.exec(i);if(!e){s+=i;break}
s+=i.substring(0,e.index),
i=i.substring(e.index+e[0].length),"\\"===e[0][0]&&e[1]?s+="\\"+(Number(e[1])+t):(s+=e[0],
"("===e[0]&&n++)}return s})).map((e=>`(${e})`)).join(t)}
const E="[a-zA-Z]\\w*",x="[a-zA-Z_]\\w*",w="\\b\\d+(\\.\\d+)?",y="(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)",_="\\b(0b[01]+)",O={
begin:"\\\\[\\s\\S]",relevance:0},v={scope:"string",begin:"'",end:"'",
illegal:"\\n",contains:[O]},k={scope:"string",begin:'"',end:'"',illegal:"\\n",
contains:[O]},N=(e,t,n={})=>{const s=i({scope:"comment",begin:e,end:t,
contains:[]},n);s.contains.push({scope:"doctag",
begin:"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)",
end:/(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,excludeBegin:!0,relevance:0})
;const o=f("I","a","is","so","us","to","at","if","in","it","on",/[A-Za-z]+['](d|ve|re|ll|t|s|n)/,/[A-Za-z]+[-][a-z]+/,/[A-Za-z][a-z]{2,}/)
;return s.contains.push({begin:h(/[ ]+/,"(",o,/[.]?[:]?([.][ ]|[ ])/,"){3}")}),s
},S=N("//","$"),M=N("/\\*","\\*/"),R=N("#","$");var j=Object.freeze({
__proto__:null,APOS_STRING_MODE:v,BACKSLASH_ESCAPE:O,BINARY_NUMBER_MODE:{
scope:"number",begin:_,relevance:0},BINARY_NUMBER_RE:_,COMMENT:N,
C_BLOCK_COMMENT_MODE:M,C_LINE_COMMENT_MODE:S,C_NUMBER_MODE:{scope:"number",
begin:y,relevance:0},C_NUMBER_RE:y,END_SAME_AS_BEGIN:e=>Object.assign(e,{
"on:begin":(e,t)=>{t.data._beginMatch=e[1]},"on:end":(e,t)=>{
t.data._beginMatch!==e[1]&&t.ignoreMatch()}}),HASH_COMMENT_MODE:R,IDENT_RE:E,
MATCH_NOTHING_RE:/\b\B/,METHOD_GUARD:{begin:"\\.\\s*"+x,relevance:0},
NUMBER_MODE:{scope:"number",begin:w,relevance:0},NUMBER_RE:w,
PHRASAL_WORDS_MODE:{
begin:/\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/
},QUOTE_STRING_MODE:k,REGEXP_MODE:{scope:"regexp",begin:/\/(?=[^/\n]*\/)/,
end:/\/[gimuy]*/,contains:[O,{begin:/\[/,end:/\]/,relevance:0,contains:[O]}]},
RE_STARTERS_RE:"!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~",
SHEBANG:(e={})=>{const t=/^#![ ]*\//
;return e.binary&&(e.begin=h(t,/.*\b/,e.binary,/\b.*/)),i({scope:"meta",begin:t,
end:/$/,relevance:0,"on:begin":(e,t)=>{0!==e.index&&t.ignoreMatch()}},e)},
TITLE_MODE:{scope:"title",begin:E,relevance:0},UNDERSCORE_IDENT_RE:x,
UNDERSCORE_TITLE_MODE:{scope:"title",begin:x,relevance:0}});function A(e,t){
"."===e.input[e.index-1]&&t.ignoreMatch()}function I(e,t){
void 0!==e.className&&(e.scope=e.className,delete e.className)}function T(e,t){
t&&e.beginKeywords&&(e.begin="\\b("+e.beginKeywords.split(" ").join("|")+")(?!\\.)(?=\\b|\\s)",
e.__beforeBegin=A,e.keywords=e.keywords||e.beginKeywords,delete e.beginKeywords,
void 0===e.relevance&&(e.relevance=0))}function L(e,t){
Array.isArray(e.illegal)&&(e.illegal=f(...e.illegal))}function B(e,t){
if(e.match){
if(e.begin||e.end)throw Error("begin & end are not supported with match")
;e.begin=e.match,delete e.match}}function P(e,t){
void 0===e.relevance&&(e.relevance=1)}const D=(e,t)=>{if(!e.beforeMatch)return
;if(e.starts)throw Error("beforeMatch cannot be used with starts")
;const n=Object.assign({},e);Object.keys(e).forEach((t=>{delete e[t]
})),e.keywords=n.keywords,e.begin=h(n.beforeMatch,g(n.begin)),e.starts={
relevance:0,contains:[Object.assign(n,{endsParent:!0})]
},e.relevance=0,delete n.beforeMatch
},H=["of","and","for","in","not","or","if","then","parent","list","value"],C="keyword"
;function $(e,t,n=C){const i=Object.create(null)
;return"string"==typeof e?s(n,e.split(" ")):Array.isArray(e)?s(n,e):Object.keys(e).forEach((n=>{
Object.assign(i,$(e[n],t,n))})),i;function s(e,n){
t&&(n=n.map((e=>e.toLowerCase()))),n.forEach((t=>{const n=t.split("|")
;i[n[0]]=[e,U(n[0],n[1])]}))}}function U(e,t){
return t?Number(t):(e=>H.includes(e.toLowerCase()))(e)?0:1}const z={},W=e=>{
console.error(e)},X=(e,...t)=>{console.log("WARN: "+e,...t)},G=(e,t)=>{
z[`${e}/${t}`]||(console.log(`Deprecated as of ${e}. ${t}`),z[`${e}/${t}`]=!0)
},K=Error();function F(e,t,{key:n}){let i=0;const s=e[n],o={},r={}
;for(let e=1;e<=t.length;e++)r[e+i]=s[e],o[e+i]=!0,i+=p(t[e-1])
;e[n]=r,e[n]._emit=o,e[n]._multi=!0}function Z(e){(e=>{
e.scope&&"object"==typeof e.scope&&null!==e.scope&&(e.beginScope=e.scope,
delete e.scope)})(e),"string"==typeof e.beginScope&&(e.beginScope={
_wrap:e.beginScope}),"string"==typeof e.endScope&&(e.endScope={_wrap:e.endScope
}),(e=>{if(Array.isArray(e.begin)){
if(e.skip||e.excludeBegin||e.returnBegin)throw W("skip, excludeBegin, returnBegin not compatible with beginScope: {}"),
K
;if("object"!=typeof e.beginScope||null===e.beginScope)throw W("beginScope must be object"),
K;F(e,e.begin,{key:"beginScope"}),e.begin=m(e.begin,{joinWith:""})}})(e),(e=>{
if(Array.isArray(e.end)){
if(e.skip||e.excludeEnd||e.returnEnd)throw W("skip, excludeEnd, returnEnd not compatible with endScope: {}"),
K
;if("object"!=typeof e.endScope||null===e.endScope)throw W("endScope must be object"),
K;F(e,e.end,{key:"endScope"}),e.end=m(e.end,{joinWith:""})}})(e)}function V(e){
function t(t,n){
return RegExp(l(t),"m"+(e.case_insensitive?"i":"")+(e.unicodeRegex?"u":"")+(n?"g":""))
}class n{constructor(){
this.matchIndexes={},this.regexes=[],this.matchAt=1,this.position=0}
addRule(e,t){
t.position=this.position++,this.matchIndexes[this.matchAt]=t,this.regexes.push([t,e]),
this.matchAt+=p(e)+1}compile(){0===this.regexes.length&&(this.exec=()=>null)
;const e=this.regexes.map((e=>e[1]));this.matcherRe=t(m(e,{joinWith:"|"
}),!0),this.lastIndex=0}exec(e){this.matcherRe.lastIndex=this.lastIndex
;const t=this.matcherRe.exec(e);if(!t)return null
;const n=t.findIndex(((e,t)=>t>0&&void 0!==e)),i=this.matchIndexes[n]
;return t.splice(0,n),Object.assign(t,i)}}class s{constructor(){
this.rules=[],this.multiRegexes=[],
this.count=0,this.lastIndex=0,this.regexIndex=0}getMatcher(e){
if(this.multiRegexes[e])return this.multiRegexes[e];const t=new n
;return this.rules.slice(e).forEach((([e,n])=>t.addRule(e,n))),
t.compile(),this.multiRegexes[e]=t,t}resumingScanAtSamePosition(){
return 0!==this.regexIndex}considerAll(){this.regexIndex=0}addRule(e,t){
this.rules.push([e,t]),"begin"===t.type&&this.count++}exec(e){
const t=this.getMatcher(this.regexIndex);t.lastIndex=this.lastIndex
;let n=t.exec(e)
;if(this.resumingScanAtSamePosition())if(n&&n.index===this.lastIndex);else{
const t=this.getMatcher(0);t.lastIndex=this.lastIndex+1,n=t.exec(e)}
return n&&(this.regexIndex+=n.position+1,
this.regexIndex===this.count&&this.considerAll()),n}}
if(e.compilerExtensions||(e.compilerExtensions=[]),
e.contains&&e.contains.includes("self"))throw Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation.")
;return e.classNameAliases=i(e.classNameAliases||{}),function n(o,r){const a=o
;if(o.isCompiled)return a
;[I,B,Z,D].forEach((e=>e(o,r))),e.compilerExtensions.forEach((e=>e(o,r))),
o.__beforeBegin=null,[T,L,P].forEach((e=>e(o,r))),o.isCompiled=!0;let c=null
;return"object"==typeof o.keywords&&o.keywords.$pattern&&(o.keywords=Object.assign({},o.keywords),
c=o.keywords.$pattern,
delete o.keywords.$pattern),c=c||/\w+/,o.keywords&&(o.keywords=$(o.keywords,e.case_insensitive)),
a.keywordPatternRe=t(c,!0),
r&&(o.begin||(o.begin=/\B|\b/),a.beginRe=t(a.begin),o.end||o.endsWithParent||(o.end=/\B|\b/),
o.end&&(a.endRe=t(a.end)),
a.terminatorEnd=l(a.end)||"",o.endsWithParent&&r.terminatorEnd&&(a.terminatorEnd+=(o.end?"|":"")+r.terminatorEnd)),
o.illegal&&(a.illegalRe=t(o.illegal)),
o.contains||(o.contains=[]),o.contains=[].concat(...o.contains.map((e=>(e=>(e.variants&&!e.cachedVariants&&(e.cachedVariants=e.variants.map((t=>i(e,{
variants:null},t)))),e.cachedVariants?e.cachedVariants:q(e)?i(e,{
starts:e.starts?i(e.starts):null
}):Object.isFrozen(e)?i(e):e))("self"===e?o:e)))),o.contains.forEach((e=>{n(e,a)
})),o.starts&&n(o.starts,r),a.matcher=(e=>{const t=new s
;return e.contains.forEach((e=>t.addRule(e.begin,{rule:e,type:"begin"
}))),e.terminatorEnd&&t.addRule(e.terminatorEnd,{type:"end"
}),e.illegal&&t.addRule(e.illegal,{type:"illegal"}),t})(a),a}(e)}function q(e){
return!!e&&(e.endsWithParent||q(e.starts))}class J extends Error{
constructor(e,t){super(e),this.name="HTMLInjectionError",this.html=t}}
const Y=n,Q=i,ee=Symbol("nomatch"),te=n=>{
const i=Object.create(null),s=Object.create(null),o=[];let r=!0
;const a="Could not find the language '{}', did you forget to load/include a language module?",l={
disableAutodetect:!0,name:"Plain text",contains:[]};let p={
ignoreUnescapedHTML:!1,throwUnescapedHTML:!1,noHighlightRe:/^(no-?highlight)$/i,
languageDetectRe:/\blang(?:uage)?-([\w-]+)\b/i,classPrefix:"hljs-",
cssSelector:"pre code",languages:null,__emitter:c};function b(e){
return p.noHighlightRe.test(e)}function m(e,t,n){let i="",s=""
;"object"==typeof t?(i=e,
n=t.ignoreIllegals,s=t.language):(G("10.7.0","highlight(lang, code, ...args) has been deprecated."),
G("10.7.0","Please use highlight(code, options) instead.\nhttps://github.com/highlightjs/highlight.js/issues/2277"),
s=e,i=t),void 0===n&&(n=!0);const o={code:i,language:s};N("before:highlight",o)
;const r=o.result?o.result:E(o.language,o.code,n)
;return r.code=o.code,N("after:highlight",r),r}function E(e,n,s,o){
const c=Object.create(null);function l(){if(!N.keywords)return void M.addText(R)
;let e=0;N.keywordPatternRe.lastIndex=0;let t=N.keywordPatternRe.exec(R),n=""
;for(;t;){n+=R.substring(e,t.index)
;const s=_.case_insensitive?t[0].toLowerCase():t[0],o=(i=s,N.keywords[i]);if(o){
const[e,i]=o
;if(M.addText(n),n="",c[s]=(c[s]||0)+1,c[s]<=7&&(j+=i),e.startsWith("_"))n+=t[0];else{
const n=_.classNameAliases[e]||e;u(t[0],n)}}else n+=t[0]
;e=N.keywordPatternRe.lastIndex,t=N.keywordPatternRe.exec(R)}var i
;n+=R.substring(e),M.addText(n)}function g(){null!=N.subLanguage?(()=>{
if(""===R)return;let e=null;if("string"==typeof N.subLanguage){
if(!i[N.subLanguage])return void M.addText(R)
;e=E(N.subLanguage,R,!0,S[N.subLanguage]),S[N.subLanguage]=e._top
}else e=x(R,N.subLanguage.length?N.subLanguage:null)
;N.relevance>0&&(j+=e.relevance),M.__addSublanguage(e._emitter,e.language)
})():l(),R=""}function u(e,t){
""!==e&&(M.startScope(t),M.addText(e),M.endScope())}function d(e,t){let n=1
;const i=t.length-1;for(;n<=i;){if(!e._emit[n]){n++;continue}
const i=_.classNameAliases[e[n]]||e[n],s=t[n];i?u(s,i):(R=s,l(),R=""),n++}}
function h(e,t){
return e.scope&&"string"==typeof e.scope&&M.openNode(_.classNameAliases[e.scope]||e.scope),
e.beginScope&&(e.beginScope._wrap?(u(R,_.classNameAliases[e.beginScope._wrap]||e.beginScope._wrap),
R=""):e.beginScope._multi&&(d(e.beginScope,t),R="")),N=Object.create(e,{parent:{
value:N}}),N}function f(e,n,i){let s=((e,t)=>{const n=e&&e.exec(t)
;return n&&0===n.index})(e.endRe,i);if(s){if(e["on:end"]){const i=new t(e)
;e["on:end"](n,i),i.isMatchIgnored&&(s=!1)}if(s){
for(;e.endsParent&&e.parent;)e=e.parent;return e}}
if(e.endsWithParent)return f(e.parent,n,i)}function b(e){
return 0===N.matcher.regexIndex?(R+=e[0],1):(T=!0,0)}function m(e){
const t=e[0],i=n.substring(e.index),s=f(N,e,i);if(!s)return ee;const o=N
;N.endScope&&N.endScope._wrap?(g(),
u(t,N.endScope._wrap)):N.endScope&&N.endScope._multi?(g(),
d(N.endScope,e)):o.skip?R+=t:(o.returnEnd||o.excludeEnd||(R+=t),
g(),o.excludeEnd&&(R=t));do{
N.scope&&M.closeNode(),N.skip||N.subLanguage||(j+=N.relevance),N=N.parent
}while(N!==s.parent);return s.starts&&h(s.starts,e),o.returnEnd?0:t.length}
let w={};function y(i,o){const a=o&&o[0];if(R+=i,null==a)return g(),0
;if("begin"===w.type&&"end"===o.type&&w.index===o.index&&""===a){
if(R+=n.slice(o.index,o.index+1),!r){const t=Error(`0 width match regex (${e})`)
;throw t.languageName=e,t.badRule=w.rule,t}return 1}
if(w=o,"begin"===o.type)return(e=>{
const n=e[0],i=e.rule,s=new t(i),o=[i.__beforeBegin,i["on:begin"]]
;for(const t of o)if(t&&(t(e,s),s.isMatchIgnored))return b(n)
;return i.skip?R+=n:(i.excludeBegin&&(R+=n),
g(),i.returnBegin||i.excludeBegin||(R=n)),h(i,e),i.returnBegin?0:n.length})(o)
;if("illegal"===o.type&&!s){
const e=Error('Illegal lexeme "'+a+'" for mode "'+(N.scope||"<unnamed>")+'"')
;throw e.mode=N,e}if("end"===o.type){const e=m(o);if(e!==ee)return e}
if("illegal"===o.type&&""===a)return 1
;if(I>1e5&&I>3*o.index)throw Error("potential infinite loop, way more iterations than matches")
;return R+=a,a.length}const _=O(e)
;if(!_)throw W(a.replace("{}",e)),Error('Unknown language: "'+e+'"')
;const v=V(_);let k="",N=o||v;const S={},M=new p.__emitter(p);(()=>{const e=[]
;for(let t=N;t!==_;t=t.parent)t.scope&&e.unshift(t.scope)
;e.forEach((e=>M.openNode(e)))})();let R="",j=0,A=0,I=0,T=!1;try{
if(_.__emitTokens)_.__emitTokens(n,M);else{for(N.matcher.considerAll();;){
I++,T?T=!1:N.matcher.considerAll(),N.matcher.lastIndex=A
;const e=N.matcher.exec(n);if(!e)break;const t=y(n.substring(A,e.index),e)
;A=e.index+t}y(n.substring(A))}return M.finalize(),k=M.toHTML(),{language:e,
value:k,relevance:j,illegal:!1,_emitter:M,_top:N}}catch(t){
if(t.message&&t.message.includes("Illegal"))return{language:e,value:Y(n),
illegal:!0,relevance:0,_illegalBy:{message:t.message,index:A,
context:n.slice(A-100,A+100),mode:t.mode,resultSoFar:k},_emitter:M};if(r)return{
language:e,value:Y(n),illegal:!1,relevance:0,errorRaised:t,_emitter:M,_top:N}
;throw t}}function x(e,t){t=t||p.languages||Object.keys(i);const n=(e=>{
const t={value:Y(e),illegal:!1,relevance:0,_top:l,_emitter:new p.__emitter(p)}
;return t._emitter.addText(e),t})(e),s=t.filter(O).filter(k).map((t=>E(t,e,!1)))
;s.unshift(n);const o=s.sort(((e,t)=>{
if(e.relevance!==t.relevance)return t.relevance-e.relevance
;if(e.language&&t.language){if(O(e.language).supersetOf===t.language)return 1
;if(O(t.language).supersetOf===e.language)return-1}return 0})),[r,a]=o,c=r
;return c.secondBest=a,c}function w(e){let t=null;const n=(e=>{
let t=e.className+" ";t+=e.parentNode?e.parentNode.className:""
;const n=p.languageDetectRe.exec(t);if(n){const t=O(n[1])
;return t||(X(a.replace("{}",n[1])),
X("Falling back to no-highlight mode for this block.",e)),t?n[1]:"no-highlight"}
return t.split(/\s+/).find((e=>b(e)||O(e)))})(e);if(b(n))return
;if(N("before:highlightElement",{el:e,language:n
}),e.dataset.highlighted)return void console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.",e)
;if(e.children.length>0&&(p.ignoreUnescapedHTML||(console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."),
console.warn("https://github.com/highlightjs/highlight.js/wiki/security"),
console.warn("The element with unescaped HTML:"),
console.warn(e)),p.throwUnescapedHTML))throw new J("One of your code blocks includes unescaped HTML.",e.innerHTML)
;t=e;const i=t.textContent,o=n?m(i,{language:n,ignoreIllegals:!0}):x(i)
;e.innerHTML=o.value,e.dataset.highlighted="yes",((e,t,n)=>{const i=t&&s[t]||n
;e.classList.add("hljs"),e.classList.add("language-"+i)
})(e,n,o.language),e.result={language:o.language,re:o.relevance,
relevance:o.relevance},o.secondBest&&(e.secondBest={
language:o.secondBest.language,relevance:o.secondBest.relevance
}),N("after:highlightElement",{el:e,result:o,text:i})}let y=!1;function _(){
"loading"!==document.readyState?document.querySelectorAll(p.cssSelector).forEach(w):y=!0
}function O(e){return e=(e||"").toLowerCase(),i[e]||i[s[e]]}
function v(e,{languageName:t}){"string"==typeof e&&(e=[e]),e.forEach((e=>{
s[e.toLowerCase()]=t}))}function k(e){const t=O(e)
;return t&&!t.disableAutodetect}function N(e,t){const n=e;o.forEach((e=>{
e[n]&&e[n](t)}))}
"undefined"!=typeof window&&window.addEventListener&&window.addEventListener("DOMContentLoaded",(()=>{
y&&_()}),!1),Object.assign(n,{highlight:m,highlightAuto:x,highlightAll:_,
highlightElement:w,
highlightBlock:e=>(G("10.7.0","highlightBlock will be removed entirely in v12.0"),
G("10.7.0","Please use highlightElement now."),w(e)),configure:e=>{p=Q(p,e)},
initHighlighting:()=>{
_(),G("10.6.0","initHighlighting() deprecated.  Use highlightAll() now.")},
initHighlightingOnLoad:()=>{
_(),G("10.6.0","initHighlightingOnLoad() deprecated.  Use highlightAll() now.")
},registerLanguage:(e,t)=>{let s=null;try{s=t(n)}catch(t){
if(W("Language definition for '{}' could not be registered.".replace("{}",e)),
!r)throw t;W(t),s=l}
s.name||(s.name=e),i[e]=s,s.rawDefinition=t.bind(null,n),s.aliases&&v(s.aliases,{
languageName:e})},unregisterLanguage:e=>{delete i[e]
;for(const t of Object.keys(s))s[t]===e&&delete s[t]},
listLanguages:()=>Object.keys(i),getLanguage:O,registerAliases:v,
autoDetection:k,inherit:Q,addPlugin:e=>{(e=>{
e["before:highlightBlock"]&&!e["before:highlightElement"]&&(e["before:highlightElement"]=t=>{
e["before:highlightBlock"](Object.assign({block:t.el},t))
}),e["after:highlightBlock"]&&!e["after:highlightElement"]&&(e["after:highlightElement"]=t=>{
e["after:highlightBlock"](Object.assign({block:t.el},t))})})(e),o.push(e)},
removePlugin:e=>{const t=o.indexOf(e);-1!==t&&o.splice(t,1)}}),n.debugMode=()=>{
r=!1},n.safeMode=()=>{r=!0},n.versionString="11.9.0",n.regex={concat:h,
lookahead:g,either:f,optional:d,anyNumberOfTimes:u}
;for(const t in j)"object"==typeof j[t]&&e(j[t]);return Object.assign(n,j),n
},ne=te({});return ne.newInstance=()=>te({}),ne}()
;"object"==typeof exports&&"undefined"!=typeof module&&(module.exports=hljs);/*! `bash` grammar compiled for Highlight.js 11.9.0 */
(()=>{var e=(()=>{"use strict";return e=>{const s=e.regex,t={},n={begin:/\$\{/,
end:/\}/,contains:["self",{begin:/:-/,contains:[t]}]};Object.assign(t,{
className:"variable",variants:[{
begin:s.concat(/\$[\w\d#@][\w\d_]*/,"(?![\\w\\d])(?![$])")},n]});const a={
className:"subst",begin:/\$\(/,end:/\)/,contains:[e.BACKSLASH_ESCAPE]
},i=e.inherit(e.COMMENT(),{match:[/(^|\s)/,/#.*$/],scope:{2:"comment"}}),c={
begin:/<<-?\s*(?=\w+)/,starts:{contains:[e.END_SAME_AS_BEGIN({begin:/(\w+)/,
end:/(\w+)/,className:"string"})]}},o={className:"string",begin:/"/,end:/"/,
contains:[e.BACKSLASH_ESCAPE,t,a]};a.contains.push(o);const r={begin:/\$?\(\(/,
end:/\)\)/,contains:[{begin:/\d+#[0-9a-f]+/,className:"number"},e.NUMBER_MODE,t]
},l=e.SHEBANG({binary:"(fish|bash|zsh|sh|csh|ksh|tcsh|dash|scsh)",relevance:10
}),m={className:"function",begin:/\w[\w\d_]*\s*\(\s*\)\s*\{/,returnBegin:!0,
contains:[e.inherit(e.TITLE_MODE,{begin:/\w[\w\d_]*/})],relevance:0};return{
name:"Bash",aliases:["sh"],keywords:{$pattern:/\b[a-z][a-z0-9._-]+\b/,
keyword:["if","then","else","elif","fi","for","while","until","in","do","done","case","esac","function","select"],
literal:["true","false"],
built_in:["break","cd","continue","eval","exec","exit","export","getopts","hash","pwd","readonly","return","shift","test","times","trap","umask","unset","alias","bind","builtin","caller","command","declare","echo","enable","help","let","local","logout","mapfile","printf","read","readarray","source","type","typeset","ulimit","unalias","set","shopt","autoload","bg","bindkey","bye","cap","chdir","clone","comparguments","compcall","compctl","compdescribe","compfiles","compgroups","compquote","comptags","comptry","compvalues","dirs","disable","disown","echotc","echoti","emulate","fc","fg","float","functions","getcap","getln","history","integer","jobs","kill","limit","log","noglob","popd","print","pushd","pushln","rehash","sched","setcap","setopt","stat","suspend","ttyctl","unfunction","unhash","unlimit","unsetopt","vared","wait","whence","where","which","zcompile","zformat","zftp","zle","zmodload","zparseopts","zprof","zpty","zregexparse","zsocket","zstyle","ztcp","chcon","chgrp","chown","chmod","cp","dd","df","dir","dircolors","ln","ls","mkdir","mkfifo","mknod","mktemp","mv","realpath","rm","rmdir","shred","sync","touch","truncate","vdir","b2sum","base32","base64","cat","cksum","comm","csplit","cut","expand","fmt","fold","head","join","md5sum","nl","numfmt","od","paste","ptx","pr","sha1sum","sha224sum","sha256sum","sha384sum","sha512sum","shuf","sort","split","sum","tac","tail","tr","tsort","unexpand","uniq","wc","arch","basename","chroot","date","dirname","du","echo","env","expr","factor","groups","hostid","id","link","logname","nice","nohup","nproc","pathchk","pinky","printenv","printf","pwd","readlink","runcon","seq","sleep","stat","stdbuf","stty","tee","test","timeout","tty","uname","unlink","uptime","users","who","whoami","yes"]
},contains:[l,e.SHEBANG(),m,r,i,c,{match:/(\/[a-z._-]+)+/},o,{match:/\\"/},{
className:"string",begin:/'/,end:/'/},{match:/\\'/},t]}}})()
;hljs.registerLanguage("bash",e)})();/*! `c` grammar compiled for Highlight.js 11.9.0 */
(()=>{var e=(()=>{"use strict";return e=>{const n=e.regex,t=e.COMMENT("//","$",{
contains:[{begin:/\\\n/}]
}),s="decltype\\(auto\\)",a="[a-zA-Z_]\\w*::",r="("+s+"|"+n.optional(a)+"[a-zA-Z_]\\w*"+n.optional("<[^<>]+>")+")",i={
className:"type",variants:[{begin:"\\b[a-z\\d_]*_t\\b"},{
match:/\batomic_[a-z]{3,6}\b/}]},l={className:"string",variants:[{
begin:'(u8?|U|L)?"',end:'"',illegal:"\\n",contains:[e.BACKSLASH_ESCAPE]},{
begin:"(u8?|U|L)?'(\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)|.)",
end:"'",illegal:"."},e.END_SAME_AS_BEGIN({
begin:/(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/,end:/\)([^()\\ ]{0,16})"/})]},o={
className:"number",variants:[{begin:"\\b(0b[01']+)"},{
begin:"(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)"
},{
begin:"(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)"
}],relevance:0},c={className:"meta",begin:/#\s*[a-z]+\b/,end:/$/,keywords:{
keyword:"if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include"
},contains:[{begin:/\\\n/,relevance:0},e.inherit(l,{className:"string"}),{
className:"string",begin:/<.*?>/},t,e.C_BLOCK_COMMENT_MODE]},d={
className:"title",begin:n.optional(a)+e.IDENT_RE,relevance:0
},g=n.optional(a)+e.IDENT_RE+"\\s*\\(",u={
keyword:["asm","auto","break","case","continue","default","do","else","enum","extern","for","fortran","goto","if","inline","register","restrict","return","sizeof","struct","switch","typedef","union","volatile","while","_Alignas","_Alignof","_Atomic","_Generic","_Noreturn","_Static_assert","_Thread_local","alignas","alignof","noreturn","static_assert","thread_local","_Pragma"],
type:["float","double","signed","unsigned","int","short","long","char","void","_Bool","_Complex","_Imaginary","_Decimal32","_Decimal64","_Decimal128","const","static","complex","bool","imaginary"],
literal:"true false NULL",
built_in:"std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr"
},m=[c,i,t,e.C_BLOCK_COMMENT_MODE,o,l],_={variants:[{begin:/=/,end:/;/},{
begin:/\(/,end:/\)/},{beginKeywords:"new throw return else",end:/;/}],
keywords:u,contains:m.concat([{begin:/\(/,end:/\)/,keywords:u,
contains:m.concat(["self"]),relevance:0}]),relevance:0},p={
begin:"("+r+"[\\*&\\s]+)+"+g,returnBegin:!0,end:/[{;=]/,excludeEnd:!0,
keywords:u,illegal:/[^\w\s\*&:<>.]/,contains:[{begin:s,keywords:u,relevance:0},{
begin:g,returnBegin:!0,contains:[e.inherit(d,{className:"title.function"})],
relevance:0},{relevance:0,match:/,/},{className:"params",begin:/\(/,end:/\)/,
keywords:u,relevance:0,contains:[t,e.C_BLOCK_COMMENT_MODE,l,o,i,{begin:/\(/,
end:/\)/,keywords:u,relevance:0,contains:["self",t,e.C_BLOCK_COMMENT_MODE,l,o,i]
}]},i,t,e.C_BLOCK_COMMENT_MODE,c]};return{name:"C",aliases:["h"],keywords:u,
disableAutodetect:!0,illegal:"</",contains:[].concat(_,p,m,[c,{
begin:e.IDENT_RE+"::",keywords:u},{className:"class",
beginKeywords:"enum class struct union",end:/[{;:<>=]/,contains:[{
beginKeywords:"final class struct"},e.TITLE_MODE]}]),exports:{preprocessor:c,
strings:l,keywords:u}}}})();hljs.registerLanguage("c",e)})();</script>
<script>
hljs.registerLanguage('cy', function() {
    return {
    keywords: {
        keyword: [
            'func', 'mod', 'for', 'coinit', 'coresume', 'coyield', 'use', 'await', 'context',
            'return', 'if', 'else', 'as', 'while', 'var', 'let', 'dynobject', 'object', 'struct', 'cstruct', 'with', 'caught',
            'break', 'continue', 'switch', 'pass', 'or', 'and', 'not', 'is', 'error', 'throws', 'move',
            'true', 'false', 'none', 'throw', 'try', 'catch', 'recover', 'enum', 'type', 'case', 'trait'
        ],
        type: [
            'float', 'String', 'Array', 'bool', 'any', 'int', 'List', 'Map', 'symbol', 'dyn'
        ],
    },
    contains: [
        {
            scope: 'string',
            begin: "\"", end: "\""
        },
        {
            scope: 'string',
            begin: "'", end: "'"
        },
        /*
        {
            scope: 'symbol',
            begin: '.', end: /\w(?=[^\w])/
        },*/
        hljs.COMMENT(
        '\-\-', // begin
        '\n', // end
        {
            contains: [
            ]
        }
        ),
        hljs.C_NUMBER_MODE,
    ]
    };
})
hljs.highlightAll();
</script>
</body>
</html>