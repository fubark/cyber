#!cyber
use os
use io
use cy
use c

-- usage: ./cbindgen.cy -o=llvm.cy /path/to/LLVM.h -lib-path='libLLVM.dylib' -strip-prefix=LLVM
-- `-clang -I/opt/homebrew/Cellar/llvm/20.1.7/lib/clang/20/include` if missing libc headers.

use clang 'clang_bs.cy'

POST_HEADER := '''
'''

global args os.ArgsResult = { opts={}, rest={} }
global prefix str = ''
global reserved_keywords Map[str, bool] = {}

args = os.parseArgs({'o', 'lib-path', 'strip-prefix'})
prefix = args.get('strip-prefix') ?else 'DONT_MATCH'
reserved_keywords = {
    type = true,
    'Fn' = true,
}

-- Record incomplete types in `fromCType` and visiting StructDecl.
global is_type_incomplete Map[str, bool] = {}

-- Headers that should be generated. Derived from the initial header file.
global include_headers Map[str, bool] = {}

out_path := args.get('o') ?else 'bindings.cy'

found_existing_lib_path := false
markerPos := 0
existing := ''

user_imports := Map[str, bool]{}

-- Determine where in the output file to emit generated bindings.
-- Also collect existing symbols that should be skipped.
-- Build skip map.
existing = os.read_file_str(out_path) !else ''
if existing != '':
    markerPos = existing.index('\n-- CBINDGEN MARKER') ?else existing.len()

    -- Only parse section before the marker since the gen part could contain bad syntax.
    res := cy.parse(existing[0..markerPos])
    for res.root.?.!root.stmts |stmt|:
        if markerPos > stmt.pos():
            switch stmt.*:
                case .func_decl |decl|:
                    func_overrides[decl.name.name()] = true
                case .cstruct_decl |decl|:
                    skipMap[decl.name.name()] = true
                case .struct_decl |decl|:
                    skipMap[decl.name.name()] = true
                case .const_decl |decl|:
                    if decl.name.name() == 'libPath':
                        found_existing_lib_path = true
                case .import_stmt |stmt|:
                    user_imports[stmt.name.name()] = true
                else: pass

if args.rest.len() <= 1:
    print('Missing path to header file.')
    os.exit(1)

headerPath := args.rest[1]

headerSrc := os.read_file_str(headerPath)!
headerSrc = POST_HEADER + headerSrc

log(headerSrc)

-- Parse includes for the headers we want to generate bindings for.
reader := io.Reader(headerSrc)
scanner := io.Scanner(&reader)
while scanner.next_line()! |line|:
    line_str := str(line)
    if !line_str.starts_with('#include'):
        continue

    line_str = line_str[8..].trim({' ', '<', '>', '"'})
    file_name := os.baseName(line_str)
    include_headers[file_name] = true

-- Also include any declarations from the root `gen.h`.
file_name := os.baseName(headerPath)
include_headers[file_name] = true

unit := getTranslationUnit(headerPath)!

for 0..clang.getNumDiagnostics(unit) |i|:
    diag := clang.getDiagnostic(unit, i)
    spelling := clang.getDiagnosticSpelling(diag)
    print(c.from_strz(spelling.data))

cursor := clang.getTranslationUnitCursor(unit)

skipMap['__gnuc_va_list'] = true
skipMap['va_list'] = true
skipMap['true'] = true
skipMap['false'] = true

out += '-- Code below is generated by cbindgen.cy\n'

libPath := if (found_existing_lib_path) 'libPath' else "'%{args.get('lib-path') ?else 'lib.dll'}'"

if !user_imports.contains('c'):
    out += 'use c\n'

if !user_imports.contains('meta'):
    out += 'use meta\n'

out += """
type u16 = r16
type u32 = r32
type u64 = r64
type c_int = c.c_int
type c_uint = c.c_uint
type c_char = c.c_char
#if meta.is_vm_target():
    #c.bind_lib(%{libPath})
"""

_ = clang.visitChildren(cursor, visitor, none)

out += '-- Incomplete types.\n'
for is_type_incomplete |entry|:
    if entry.value:
        out += 'type %{getApiName(entry.key)}\n'

-- Generate macros.
genMacros(headerPath)!

-- Final output.
out = existing[0..markerPos] + '\n-- CBINDGEN MARKER\n' + out

os.write_file(out_path, out)!

-- Symbols that were overriden. (declared above the MARKER)
global func_overrides Map[str, bool] = {}

global skipMap Map[str, bool] = {}

-- Map to avoid dupe macro definitions.
global macros Map[str, bool] = {}

-- Build output string.
global out str = ''
global aliases Map[str, str] = {}

global structMap Map[str, Struct] = {}
global structs []str = {}
global funcs []Function = {}

fn getClangArgs() -> []str:
    clang_args := []str{}
    i := 0
    while i < args.rest.len():
        if args.rest[i] == '-clang':
            i += 1
            clang_args += args.rest[i]
        i += 1
    return clang_args

fn getTranslationUnit(headerPath str) -> !Ptr[void]:
    clang_args := getClangArgs()

    cargs := as[Ptr[Ptr[byte]]] os.malloc(8 * clang_args.len())!
    for clang_args |i, arg|:
        print('clang arg: %{arg}')
        cargs[i] = c.to_strz(arg)

    cpath := c.to_strz(headerPath)
    index := clang.createIndex(0, 0)
    return clang.parseTranslationUnit(index, cpath, cargs, i32(clang_args.len()), none, 0,
        -- clang.CXTranslationUnit_DetailedPreprocessingRecord || clang.CXTranslationUnit_SkipFunctionBodies | clang.CXTranslationUnit_SingleFileParse)
        clang.CXTranslationUnit_DetailedPreprocessingRecord || clang.CXTranslationUnit_KeepGoing)

fn getMacrosTranslationUnit(hppPath str) -> !Ptr[void]:
    clang_args := getClangArgs()

    cargs := as[Ptr[Ptr[byte]]] os.malloc(8 * clang_args.len())!
    for clang_args |i, arg|:
        cargs[i] = c.to_strz(arg)

    cpath := c.to_strz(hppPath)
    index := clang.createIndex(0, 0)
    return clang.parseTranslationUnit(index, cpath, cargs, i32(clang_args.len()), none, 0,
        clang.CXTranslationUnit_SkipFunctionBodies || clang.CXTranslationUnit_KeepGoing)

type Struct:
    fieldTypes []str = {}
    fieldNames []str = {}

type Union:
    cases      []str = {}
    case_types []str = {}

#[extern]
fn visitor(cursor, parent clang.CXCursor, data Ptr[void]) -> i32:
    cxName := clang.getCursorDisplayName(cursor)
    name := fromCXString(cxName)

    -- log('visitor: %{cursor.kind} %{name}')

    -- NOTE: Cannot rely on system header check to filter out irrelevant declarations.
    -- if clang.Location_isInSystemHeader(loc) != 0:

    loc := clang.getCursorLocation(cursor)
    file := as[clang.CXFile] 0
    clang.getSpellingLocation(loc, *file, none, none, none)
    if file == none:
        return clang.CXChildVisit_Continue
    cx_file_name := clang.getFileName(file)
    file_name := fromCXString(cx_file_name)
    base_name := os.baseName(file_name)
    if !include_headers.contains(base_name):
        -- Not a relevant header.
        return clang.CXChildVisit_Continue

    switch cursor.kind:
        case clang.CXCursor_MacroDefinition:
            if clang.Cursor_isMacroBuiltin(cursor) != 0:
                return clang.CXChildVisit_Continue
            if clang.Cursor_isMacroFunctionLike(cursor) != 0:
                return clang.CXChildVisit_Continue

            -- Append to macros.
            macros[name] = true

        case clang.CXCursor_MacroExpansion,
            clang.CXCursor_InclusionDirective: pass

        case clang.CXCursor_TypedefDecl: 
            -- eprint('typedef %{name}')

            if skipMap.contains(name):
                out += '-- typedef %{name}\n\n'
            else:
                target_t := clang.getTypedefDeclUnderlyingType(cursor)
                target_name := fromCType(target_t)
                if target_name != name:
                    final_name := getApiName(name)
                    aliases[final_name] = target_name
                    out += 'type %{final_name} = %{target_name}\n\n'

        case clang.CXCursor_UnionDecl:
            eff_name := name + '_U'
            state := Union{}
            _ = clang.visitChildren(cursor, unionVisitor, as &state)

            out += 'type %{getApiName(eff_name)} cunion:\n'

            for state.cases |i, name|:
                case_t := state.case_types[i]
                out += '    case %{name} %{case_t}\n'
            out += '\n'

        case clang.CXCursor_StructDecl:
            -- eprint('struct %{name}')

            decl_t := clang.getCursorType(cursor)
            assert(decl_t.kind == clang.CXType_Record)

            effName := name + '_S'
            if !is_type_incomplete.contains(effName):
                size := clang.Type_getSizeOf(decl_t)
                is_type_incomplete[effName] = size == clang.CXTypeLayoutError_Incomplete
            if is_type_incomplete[effName]:
                return clang.CXChildVisit_Continue

            state := Struct{}
            _ = clang.visitChildren(cursor, structVisitor, as &state)
            structMap[effName] = state
            structs += effName

            skip_children := false
            if skipMap.contains(effName):
                out += '-- type %{getApiName(effName)} cstruct:\n'
                skip_children = true
            else:
                out += 'type %{getApiName(effName)} cstruct:\n'

            for state.fieldNames |i, name|:
                if skip_children:
                    out += '-- '

                fieldt := state.fieldTypes[i]
                out += '    %{name} %{fieldt}\n'
            out += '\n'

        case clang.CXCursor_EnumDecl:
            -- print('enum ' + name)

            if name.starts_with('enum '):
                -- panic('unexpected: ' + name)
                return clang.CXChildVisit_Continue

            eff_name := getApiName(name + '_E')
            out += 'type %{eff_name} = c_int\n'
            aliases[eff_name] = 'c_int'

            _ = clang.visitChildren(cursor, enumVisitor, none)
            out += '\n'

        case clang.CXCursor_FunctionDecl:
            eprint('fn ' + name)
            def := clang.getCursorDefinition(cursor)
            if clang.Cursor_isNull(def) == 0:
                -- Skip declarations with function bodies.
                -- NOTE: This assumes `clang.CXTranslationUnit_SkipFunctionBodies` was not set. Otherwise, isNull will always return true.
                return clang.CXChildVisit_Continue

            cxName := clang.getCursorSpelling(cursor)
            funcName := fromCXString(cxName)
            func := Function{}
            func.name = funcName

            cxFunc := clang.getCursorType(cursor)
            cxRet := clang.getResultType(cxFunc)

            api_name := getApiName(funcName)
            has_override := func_overrides.contains(api_name)

            outFunc := ''
            if api_name != funcName or has_override:
                outFunc = "#[extern='%{funcName}']\n"
            else:
                outFunc = "#[extern]\n"
            if has_override:
                outFunc += 'fn c%{api_name}('
            else:
                outFunc += 'fn %{api_name}('

            -- Parse params.
            fnParamTypes := []str{}
            numParams := clang.getNumArgTypes(cxFunc)
            for 0..numParams |i|:
                cxParam := clang.Cursor_getArgument(cursor, i)
                cxParamName := clang.getCursorSpelling(cxParam)
                paramName := fromCXString(cxParamName)
                if paramName == '' or reserved_keywords.contains(paramName):
                    paramName = 'param%{i}'
                cxParamType := clang.getArgType(cxFunc, i)
                paramT := fromCType(cxParamType)

                outFunc += '%{paramName} %{paramT}'
                if i < numParams-1:
                    outFunc += ', '

                fnParamTypes += paramT

            outFunc += ') -> '

            retT := fromCType(cxRet)
            outFunc += retT

            outFunc += '\n\n'

            out += outFunc

            func.params = fnParamTypes
            func.ret = retT
            funcs += func

        case clang.CXCursor_VarDecl:
            cx_name := clang.getCursorSpelling(cursor)
            name := fromCXString(cx_name)
            res := evalVarInit(cursor) ?else:
                eprint('TODO: global %{name}')
                return clang.CXChildVisit_Continue
            out += 'global %{getApiName(name)} %{res.init_t} = %{res.init}\n'

        case clang.CXCursor_StaticAssert:
            -- TODO: compile-time assert
            pass

        else:
            panic('visitor invoked kind=%{cursor.kind} name=%{name}')

    return clang.CXChildVisit_Continue

#[extern]
fn unionVisitor(cursor, parent clang.CXCursor, data Ptr[void]) -> i32:
    state := as[&Union] data
    cxName := clang.getCursorDisplayName(cursor)
    name := fromCXString(cxName)

    -- eprint('unionVisitor: %{cursor.kind} %{name}')

    switch cursor.kind:
        case clang.CXCursor_FieldDecl:
            -- print 'field %{cursor.kind} %{name}'
            case_t := clang.getCursorType(cursor)
            state.cases += name
            state.case_types += fromCType(case_t)
        else: 
            panic('unsupported %{cursor.kind} %{name}')
    return clang.CXChildVisit_Continue

#[extern]
fn structVisitor(cursor, parent clang.CXCursor, data Ptr[void]) -> i32:
    state := as[&Struct] data
    cxName := clang.getCursorDisplayName(cursor)
    name := fromCXString(cxName)

    -- eprint('structVisitor: %{cursor.kind} %{name}')

    switch cursor.kind:
        case clang.CXCursor_FieldDecl:
            -- print 'field %{cursor.kind} %{name}'
            ftype := clang.getCursorType(cursor)
            fsym := fromCType(ftype)

            state.fieldTypes += fsym
            state.fieldNames += name
        else: 
            panic('unsupported %{cursor.kind} %{name}')
    return clang.CXChildVisit_Continue

#[extern]
fn enumVisitor(cursor, parent clang.CXCursor, data Ptr[void]) -> i32:
    cxName := clang.getCursorDisplayName(cursor)
    name := fromCXString(cxName)
    val := clang.getEnumConstantDeclValue(cursor)
        
    out += 'const %{getApiName(name)} = c_int(%{val})\n'
    return clang.CXChildVisit_Continue

fn genMacros(headerPath str) -> !void:
    abs_path := os.resolve_path(headerPath)!

    hpp := ''
    hpp += '#include "%{abs_path}"\n\n'
    for macros |e|:
        hpp += 'auto var_%{e.key} = %{e.key};\n'
    os.write_file('macros.hpp', hpp)!

    unit := getMacrosTranslationUnit('macros.hpp')!
    cursor := clang.getTranslationUnitCursor(unit)

    for 0..clang.getNumDiagnostics(unit) |i|:
        diag := clang.getDiagnostic(unit, i)
        spelling := clang.getDiagnosticSpelling(diag)
        print(c.from_strz(spelling.data))

    out += '-- Macros\n'

    _ = clang.visitChildren(cursor, macrosRootVisitor, none)

#[extern]
fn initListExpr(cursor, parent clang.CXCursor, data Ptr[void]) -> i32:
    -- eprint('initListExpr: %{cursor.kind}')
    state := as[&InitListExprState] data
    switch cursor.kind:
        case clang.CXCursor_IntegerLiteral:
            eval := clang.Cursor_Evaluate(cursor)
            val := clang.EvalResult_getAsLongLong(eval)
            state.args += str(val)
        else:
            panic('visitor invoked %{cursor.kind}')

    return clang.CXChildVisit_Continue

type InitVarState:
    type str   = ''
    args []str = {}

type InitListExprState:
    args []str = {}

#[extern]
fn initVarVisitor(cursor, parent clang.CXCursor, data Ptr[void]) -> i32:
    state := as[&InitVarState] data
    cxName := clang.getCursorDisplayName(cursor)
    name := fromCXString(cxName)

    -- eprint('initVarVisitor: %{cursor.kind} %{name}')

    switch cursor.kind:
        case clang.CXCursor_TypeRef:
            state.type = name
        case clang.CXCursor_InitListExpr:
            init_state := InitListExprState{}
            _ = clang.visitChildren(cursor, initListExpr, as &init_state)
            state.args = init_state.args
        else:
            panic('visitor invoked %{cursor.kind} %{name}')

    return clang.CXChildVisit_Continue

#[extern]
fn macrosRootVisitor(cursor, parent clang.CXCursor, data Ptr[void]) -> i32:
    cxName := clang.getCursorDisplayName(cursor)
    name := fromCXString(cxName)

    -- eprint('macros visitor: %{cursor.kind} %{name}')

    loc := clang.getCursorLocation(cursor)
    if clang.Location_isInSystemHeader(loc) != 0:
        -- Skip system headers.
        return clang.CXChildVisit_Continue

    switch cursor.kind:
        case clang.CXCursor_UnexposedDecl: pass
        case clang.CXCursor_MacroDefinition: pass
        case clang.CXCursor_MacroExpansion,
            clang.CXCursor_InclusionDirective: pass
        case clang.CXCursor_TypedefDecl: pass
        case clang.CXCursor_StructDecl: pass
        case clang.CXCursor_EnumDecl: pass
        case clang.CXCursor_FunctionDecl: pass
        case clang.CXCursor_LinkageSpec: pass
        case clang.CXCursor_VarDecl:
            if !name.starts_with('var_'):
                -- Skip non-macro vars.
                return clang.CXChildVisit_Continue

            if skipMap.contains(name[4..]):
                out += '-- '

            -- eprint('var %{name}')

            -- var finalName = getApiName(name[4..].trim(.left, '_'))
            finalName := getApiName(name[4..])
            res := evalVarInit(cursor) ?else:
                eprint('TODO: const %{name}')
                return clang.CXChildVisit_Continue
            out += 'const %{finalName} %{res.init_t} = %{res.init}\n'

        case clang.CXCursor_StaticAssert:
            pass

        else:
            panic('visitor invoked %{cursor.kind} %{name}')

    return clang.CXChildVisit_Continue

type EvalResult:
    init_t str
    init   str

fn evalVarInit(cursor clang.CXCursor) -> ?EvalResult:
    eval := clang.Cursor_Evaluate(cursor)
    kind := clang.EvalResult_getKind(eval)

    switch kind:
        case clang.CXEval_UnExposed:
            clang.EvalResult_dispose(eval)
            -- Can't eval to primitive. Check for struct intializer.
            initCur := clang.Cursor_getVarDeclInitializer(cursor)
            cxInitName := clang.getCursorDisplayName(initCur)
            initName := fromCXString(cxInitName)
            switch initCur.kind:
                case clang.CXCursor_InvalidFile
                case clang.CXCursor_UnexposedExpr: 
                    return none

                case clang.CXCursor_CXXNullPtrLiteralExpr:
                    return {init_t='Ptr[void]', init='none'}

                case clang.CXCursor_CXXFunctionalCastExpr:
                    state := InitVarState{}
                    _ = clang.visitChildren(initCur, initVarVisitor, as &state)

                    struct := getStruct(state.type).?
                    kvs := []str{}
                    for struct.fieldNames |i, fieldn|:
                        kvs += '%{fieldn}=%{state.args[i]}'
                    return {init_t='%{state.type}', init='{%{kvs.join(', ')}}'}

                case clang.CXCursor_CStyleCastExpr:
                    return none

                else:
                    clang.EvalResult_dispose(eval)
                    panic('init %{initName} %{initCur.kind}')

        case clang.CXEval_Int:
            val := clang.EvalResult_getAsLongLong(eval)
            clang.EvalResult_dispose(eval)
            val_t := clang.getCursorType(cursor)
            val_t = clang.getCanonicalType(val_t)
            type_name := fromCType(val_t)
            switch val_t.kind:
                case clang.CXType_UShort
                case clang.CXType_UInt
                case clang.CXType_ULongLong
                case clang.CXType_ULong:
                    return {init_t=type_name, init='%{val.ufmt()}'}
                else:
                    return {init_t=type_name, init='%{val}'}

        case clang.CXEval_Float:
            val := clang.EvalResult_getAsDouble(eval)
            clang.EvalResult_dispose(eval)
            val_t := clang.getCursorType(cursor)
            val_t = clang.getCanonicalType(val_t)
            return {init_t=fromCType(val_t), init='%{val}'}

        case clang.CXEval_StrLiteral:
            strz := clang.EvalResult_getAsStr(eval)
            str := c.from_strz(strz)
            clang.EvalResult_dispose(eval)
            return {init_t='EvalStr', init='"%{str}"' }

        else:
            clang.EvalResult_dispose(eval)
            panic('Unsupported: %{kind}')

fn fromCXString(cxStr clang.CXString) -> str:
    cname := clang.getCString(cxStr)
    return c.from_strz(cname)

fn resolveBindType(type_ str) -> str:
    if aliases.contains(type_):
        return aliases[type_]
    return type_

fn getStruct(name str) -> ?Struct:
    if structMap.contains(name):
        return structMap[name]
    if aliases.contains(name):
        alias := aliases[name]
        return structMap[alias]
    return none

fn fromCType(cxType clang.CXType) -> str:
    -- name := fromCXString(clang.getTypeSpelling(cxType))
    -- eprint('fromCType: %{name} %{cxType.kind}')
    switch cxType.kind:
        case clang.CXType_Float             : return 'f32'
        case clang.CXType_Double            : return 'float'
        case clang.CXType_Short             : return 'i16'
        case clang.CXType_UShort            : return 'u16'
        case clang.CXType_ULong             : return 'u64'
        case clang.CXType_Long              : return 'i64'
        case clang.CXType_LongLong          : return 'i64'
        case clang.CXType_ULongLong         : return 'u64'
        case clang.CXType_Void              : return 'void'
        case clang.CXType_Bool              : return 'bool'
        case clang.CXType_Int               : return 'c_int'
        case clang.CXType_UInt              : return 'c_uint'
        case clang.CXType_SChar             : return 'i8'
        case clang.CXType_Char_S            : return 'c_char'
        case clang.CXType_UChar             : return 'byte'
        case clang.CXType_Pointer:
            pointee := clang.getPointeeType(cxType)
            if pointee.kind == clang.CXType_FunctionProto:
                return fromCType(pointee)
            else:
                return 'Ptr[%{fromCType(pointee)}]'
        case clang.CXType_FunctionProto     :
            nparams := clang.getNumArgTypes(cxType)
            params := []str{}
            for 0..nparams |i|:
                params += fromCType(clang.getArgType(cxType, i))
            ret := fromCType(clang.getResultType(cxType))
            return '#[extern] fn(%{params.join(', ')})->%{ret}'

        case clang.CXType_IncompleteArray   : return 'Ptr[void]'
        case clang.CXCursor_IntegerLiteral  : return 'c_int'
        case clang.CXType_Typedef:
            name := fromCXString(clang.getTypedefName(cxType))
            switch name:
                case 'size_t'   : return 'u64'
                case 'int8_t'   : return 'i8'
                case 'uint8_t'  : return 'byte'
                case 'int16_t'  : return 'i16'
                case 'uint16_t' : return 'u16'
                case 'int32_t'  : return 'i32'
                case 'uint32_t' : return 'u32'
                case 'int64_t'  : return 'i64'
                case 'uint64_t' : return 'u64'
                case 'intptr_t' : return 'i64'
                case 'wchar_t'  : return 'u16'
                case 'va_list'  : return 'Ptr[void]'
                else:
                    return getApiName(name)

        case clang.CXType_Elaborated:
            -- e.g. struct Foo
            named_t := clang.Type_getNamedType(cxType)
            decl := clang.getTypeDeclaration(named_t)
            name := fromCXString(clang.getCursorSpelling(decl))

            if named_t.kind == clang.CXType_Typedef:
                return fromCType(named_t)
            else named_t.kind == clang.CXType_Record:
                -- struct Foo, union Foo
                if decl.kind == clang.CXCursor_StructDecl:
                    name += '_S'
                else decl.kind == clang.CXCursor_UnionDecl:
                    name += '_U'
                else:
                    panic('unexepcted')

                if !is_type_incomplete.contains(name):
                    size := clang.Type_getSizeOf(named_t)
                    incomplete := size == clang.CXTypeLayoutError_Incomplete
                    is_type_incomplete[name] = incomplete
                return getApiName(name)
            else named_t.kind == clang.CXType_Enum:
                return getApiName(name + '_E')

            panic('Unsupported elaborated type: %{name} %{named_t.kind}')

        case clang.CXType_ConstantArray:
            n := clang.getNumElements(cxType)
            cxElem := clang.getElementType(cxType)
            elem := fromCType(cxElem)
            return '[%{n}]%{elem}'

        else:
            panic('Unsupported type %{cxType.kind}')

fn getApiName(name str) -> str:
    api_name := name
    if api_name.starts_with(prefix):
        api_name = api_name[prefix.len()..]
    if api_name.starts_with('_'):
        api_name = api_name[1..]
    return api_name

type Function:
    name   str   = ''
    params []str = {}
    ret    str   = ''