<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Table of Contents on Cyber Docs v0.2</title><link>https://fubark.github.io/cyber/docs/toc/</link><description>Recent content in Table of Contents on Cyber Docs v0.2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://fubark.github.io/cyber/docs/toc/index.xml" rel="self" type="application/rss+xml"/><item><title>Syntax</title><link>https://fubark.github.io/cyber/docs/toc/syntax/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/syntax/</guid><description>Syntax # Cyber&amp;rsquo;s syntax is concise and easy to read.
Statements. # A statement ends with the new line.
-- An assignment statement. var a = 123 Blocks. # Some statements can start a new block with a colon. The first statement in a new block must be indented further. Spaces or tabs can be used for indentation but not both.
-- This `if` statement begins a new block. if true: var a = 234 Subsequent statements in the block must follow the same indentation.</description></item><item><title>Data Types</title><link>https://fubark.github.io/cyber/docs/toc/data-types/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/data-types/</guid><description>Data Types. # In Cyber, there are primitive types and object types. Primitives are copied around by value and don&amp;rsquo;t need additional heap memory or reference counts. Primitives include Booleans, Floats, Integers, Enums, Symbols, Errors, Static Strings, and the none value. Object types include Lists, Tuples, Maps, Strings, Custom Objects, Lambdas, Fibers, Errors with payloads, Pointers, and several internal object types.
The none value represents an empty value. This is similar to null in other languages.</description></item><item><title>Control Flow</title><link>https://fubark.github.io/cyber/docs/toc/control-flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/control-flow/</guid><description>Control Flow. # Cyber provides the common constructs to branch and enter loops.
Branching. # Use if and else statements to branch the execution of your code depending on conditions. The else clause can contain a condition which is only evaluated if the previous if or conditional else clause was false.
var a = 10 if a == 10: print &amp;#39;a is 10&amp;#39; else a == 20: print &amp;#39;a is 20&amp;#39; else: print &amp;#39;neither 10 nor 20&amp;#39; An if expression leads with the return expression for the true case.</description></item><item><title>Functions</title><link>https://fubark.github.io/cyber/docs/toc/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/functions/</guid><description>Functions. # In Cyber, there are first-class functions (or function values) and static functions.
Static Functions. # Static functions are not initially values themselves. They allow function calls to be optimal since they don&amp;rsquo;t need to resolve a dynamic value.
Static functions are declared with the func keyword and must have a name.
import math func dist(x0, y0, x1, y1): var dx = x0-x1 var dy = y0-y1 return math.</description></item><item><title>Modules</title><link>https://fubark.github.io/cyber/docs/toc/modules/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/modules/</guid><description>Modules. # Modules have their own namespace and contain accessible static symbols. By default, importing another Cyber script returns a module with its declared symbols.
Importing. # Import declarations create a local alias to the module referenced by the import specifier. The Cyber CLI comes with some builtin modules like math and test. If the specifier does not refer to a builtin module, it looks for a Cyber script file relative to the current script&amp;rsquo;s directory.</description></item><item><title>FFI</title><link>https://fubark.github.io/cyber/docs/toc/ffi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/ffi/</guid><description>FFI. # Cyber supports binding to an existing C ABI compatible library at runtime. This allows you to call into dynamic libraries created in C or other languages. Cyber uses libtcc to JIT compile the bindings so function calls are fast. bindLib is part of the os module and accepts the path to the library as a string and a list of CFunc or CStruct declarations.
import os var lib = os.</description></item><item><title>Error Handling</title><link>https://fubark.github.io/cyber/docs/toc/errors/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/errors/</guid><description>Error Handling. # Cyber provides error values and try/catch mechanisms to handle expected errors. For unexpected errors, panics can be used as a fail-fast mechanism to abort the currently running fiber.
Error value. # The error type is a primitive that contains either an enum value or a symbol value. Errors can wrap symbols for convenience but the underlying ID value won&amp;rsquo;t be consistent. Use your own enums if you want reliable ID values.</description></item><item><title>Concurrency</title><link>https://fubark.github.io/cyber/docs/toc/concurrency/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/concurrency/</guid><description>Concurrency. # Cyber supports fibers as a concurrency mechanism. There are plans to support preemptive concurrency with async/await as well as multithreading.
Fibers. # Fibers in Cyber allow representing execution contexts as first-class values. They contain their own call stack and program counters. Fibers by themselves do not enable parallelism.
The coinit creates a new fiber from a function call syntax. Using coyield inside a function pauses the current fiber and execution is returned to the fiber that invoked coresume.</description></item><item><title>Type System</title><link>https://fubark.github.io/cyber/docs/toc/type-system/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/type-system/</guid><description>Type System. # Cyber supports the use of both dynamically and statically typed code.
Dynamic typing. # Dynamic typing can reduce the amount of friction when writing code, but it can also result in more runtime errors.
dynamic vs any # Variables without a type specifier are implicitly assigned the dynamic type. dynamic values can be freely used and copied without any compile errors (if there is a chance it can succeed at runtime, see Recent type inference):</description></item><item><title>Metaprogramming</title><link>https://fubark.github.io/cyber/docs/toc/metaprogramming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/metaprogramming/</guid><description>Metaprogramming. # Operator overloading. # All operators are implemented as object methods.
Incomplete: Not all operators have transitioned to the method paradigm.
Normally this would impact performance, but Cyber generates specialized bytecode for builtin types like int and float. The VM performs inline caching at runtime to eliminate the overhead of evaluating on dynamic operands.
To overload an operator for an object type, declare $prefix, $infix, $postfix methods. See the available builtin operators.</description></item><item><title>Embedding</title><link>https://fubark.github.io/cyber/docs/toc/embedding/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/embedding/</guid><description>Embedding. # Planned Feature</description></item><item><title>Memory</title><link>https://fubark.github.io/cyber/docs/toc/memory/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/memory/</guid><description>Memory. # Cyber provides memory safety by default.
ARC. # Cyber uses ARC or automatic reference counting to manage memory. ARC is deterministic and has less overhead compared to a tracing garbage collector. Reference counting distributes memory management, which reduces GC pauses and makes ARC suitable for realtime applications. One common issue in ARC implementations is reference cycles which Cyber addresses with Weak References and it&amp;rsquo;s very own Cycle Detection.</description></item><item><title>AOT/JIT</title><link>https://fubark.github.io/cyber/docs/toc/aot-jit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://fubark.github.io/cyber/docs/toc/aot-jit/</guid><description>AOT and JIT # Planned Feature</description></item></channel></rss>